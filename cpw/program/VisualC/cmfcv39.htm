<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title></title>
</head>

<body bgcolor="#8080C0">
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="95%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="Vcidx098.htm">Visual 
    C++/C++</a> --&gt;</b> MFC邮递表的中文翻译(第三十九期)</span></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="1" width="95%" style="font-size: 9pt" bgcolor="#FFFFFF"
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"
    bordercolordark="#FFFFFF">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://chinaprog.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<h2 align="center"><span style="font-size: 9pt">MFC邮递表的中文翻译</span></h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;我是一名mfc程序设计的爱好者,订阅了mfc的maillist,利用业余时间 
    将它翻译出来,希望能对mfc编程的朋友有所帮助,请朋友们指正.<br>
    </p>
    <h3><font color="#FF0000">第三十九期目录</font> <fontsize="2">杨晓东 1999.5.25</h3>
    <ol>
      <li><a href="#volq1">系列化和CDocument版本</a> </li>
      <li><a href="#volq2">编译错误</a> </li>
      <li><a href="#volq3">内存空洞和CStringList</a> </li>
      <li><a href="#volq4">CRecordset中锁定记录</a> </li>
      <li><a href="#volq5">C4113警告是什么意思</a> </li>
      <li><a href="#volq6">打印</a> </li>
      <li><a href="#volq7">动态菜单</a> </li>
      <li><a href="#volq8">从CAsyncsocket::OnReceive消息中取得所有的数据</a> </li>
    </ol>
    <p><a name="volq1"></a></p>
    <p><br>
    </p>
    <font color="Red"><h3>系列化和CDocument版本</h3>
    </font><p>问：我想运行多个不同版本的对象，但CArchive::GetObjectSchema()总是返回-1<br>
    答：看一下MSDN技术文档：TN002: Persistent Object Data Format<br>
    “任何直接调用Serialize的可系列化对象不能使用CArchive::GetObjectSchema，或者 
    必须处理因未知版本而返回的值-1<br>
    你可以自己处理这个问题，象下面这样： </p>
    <pre>void CMyDoc::Serialize(CArchive&amp; ar)
{
   static const WORD MYDOC_VERSION = 3; // current version
   if (ar.IsStoring())
   {
      ar << MYDOC_VERSION; // serialize your data } else { WORD wVersion; ar>&gt; wVersion;
      switch(wVersion)
      {
      default: { /* this is not MyDoc data*/ }
      case 1: { /* implement serialize version-1 data*/ }
      case 2: { /* implement serialize version-2 data*/ }
      case 3: { /* implement serialize version-3 data*/ }
      }
   }
}</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq2"></a><br>
    </p>
    <font color="Red"><h3>编译错误</h3>
    </font><p>问:我编译程序时遇上下面这个错误: </p>
    <pre>cannot convert from void(unsigned long) to void(_cdecl*)(unsigned long)</pre>
    <p>答：在你的函数声明改成如下形式: </p>
    <pre>
extern 'C'
{
....
}</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq3"></a><br>
    </p>
    <font color="Red"><h3>内存空洞和CStringList</h3>
    </font><p>问：当我使用以下代码时，程序提供出现内存空洞 </p>
    <pre>pDocument-&gt;m_strlSourceFiles.AddHead(*new CString(&quot;Blah...blah...blah&quot;);</pre>
    <p>答：<br>
    1）不能用这种方法在堆里建立一个新CString。这几乎肯定能产生一个空洞，因为在 
    调用这个函数之后，你就再也不可能处理这块内存了。应该这样做： 
    </p>
    <pre>pDocument-&gt;m_strlSourceFiles.AddHead(CString(&quot;Blah...blah...blah&quot;));</pre>
    <p>事实上你可以在这里放置一个字符指针，MFC会帮助转换的。</p>
    <p>2）你应该知道，CStringList类在增加时需要一个LPCTSTR参数，然后将这个字符串 
    复制到列表中，当列表删除时，所有加入列有的字符串也都会被删除。有两个方法可 
    以解决你的问题，第一个方法较简单，推荐使用：<br>
    1. </p>
    <pre>  pDocument-&gt;m_strlSourceFiles.AddHead(&quot;Blah...blah...blah&quot;);</pre>
    <p>2. </p>
    <pre>  CString * pStr;
  pDocument-&gt;m_strlSourceFiles.AddHead(
    * (pStr =3D new CString(&quot;Blah...blah...blah&quot;)));
  delete pStr;</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq4"></a><br>
    </p>
    <font color="Red"><h3>CRecordset中锁定记录</h3>
    </font><p>问：有谁知道怎样将锁定记录？我使用是的MS SQL Server 6.5以及MFC 
    CRecordset类。</p>
    <p>答：锁定记录只能在DBMS中完成，CRectordset没有任何方法可完成。如果你的数据库 
    管理系统没有提供锁定的话（或者不支持你所说的锁定方式的话）你也就不能完成 
    这项工作。<br>
    即然你使用是的SQL Server，你应该找一个SQL Server的相关资料，里面会有锁定 
    记录的语法的说明，在CRecordset类中不能进行特别的调用（打开等操作不算）<br>
    CRecordset 和 CDatabase以所以没有提供锁定是因为<br>
    1）每个DBMS实现都有不同的方法，将其加入到里面会导致冲突。<br>
    2）ODBC API 也因此没有提供相应的功能。</p>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq5"></a><br>
    </p>
    <font color="Red"><h3>C4113警告是什么意思</h3>
    </font><p>问：请问下面的警告是什么意思？ </p>
    <pre>warning C4113: 'int (__stdcall *)()' differs in parameter lists from 'int
(__stdcall *)(struct HWND__ *,unsigned int ,unsigned int ,long )'</pre>
    <p>警告的行是这个样子的： </p>
    <pre>DialogBox(hInst,MAKEINTRESOURCE(DATAENTRYBOX),hDlg,lpprocDataEntry);</pre>
    <p>答<br>
    1）文档中DialogBox的声明是这样的： </p>
    <pre>int DialogBox( HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent,
DLGPROC lpDialogFunc );</pre>
    <p>DLGPROC的是这样定义的： </p>
    <pre>typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);</pre>
    <p>这样看来，你的lpprocDataEntry声明不正确，并不是希望中的四个参数，当然会发 
    生这种不愉快的事情了。</p>
    <p>2）这只是一个可能的原因，没有看过你的代码，不好下结论，是不是你的lpprocDataEntry 
    函数指针的类型是int (__stdcall *)()？文档说明指出DialogBox的最后一个参数 
    应该是这样： </p>
    <pre>     BOOL CALLBACK DialogProc(HWND hwndDlg,  // handle to dialog box
                              UINT uMsg,     // message
                              WPARAM wParam, // first message parameter
                              LPARAM lParam  // second message parameter);</pre>
    <p>如果你给的四个类型是int (__stdcall *)(struct HWND__ *,unsigned int , unsigned 
    int ,long )，那么警告是有道理的，你应当改成正确的参数。 <a
    href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq6"></a><br>
    </p>
    <font color="Red"><h3>打印</h3>
    </font><p>问：我有一个应用程序需要打印，我已经完成了这个工作，但问题是每次用一个新的 
    打印机时总需要改变我的代码，有没有方法可以在改变打印机时不需要改变我的代码？ 
    怎样我才能每次打印机都能正确打印？比如：一个普通打印机设置字体为60，而DeskJet 
    我要设置字体为30</p>
    <p>答：<br>
    1）你必须自己计算依靠DC的打印机的字体的大小，首先，你应该做下面一些事情： 
    </p>
    <pre>CDC dc;
CPrintDialog dlg(FALSE);
if (AfxGetApp()-&gt;GetPrinterDeviceDefaults(&amp;dlg.m_pd))
{
 // GetPrinterDC returns a HDC so attach it

  HDC hDC= dlg.CreatePrinterDC();
  ASSERT(hDC != NULL);
  dc.Attach(hDC);
}</pre>
    <p>然后，象这样计算字体的高度（这里是8号字体） </p>
    <pre>int nHeight = -( dc.GetDeviceCaps(LOGPIXELSY) * 8 / 72 );</pre>
    <p>然后建立新的字体： </p>
    <pre>m_printerFont.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0 ,0 ,
   238 , OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
   DEFAULT_QUALITY, DEFAULT_PITCH|FF_DONTCARE, &quot;Arial Narrow&quot;);</pre>
    <p>2)我认为你的问题是在打印时，每个打印机都选择了不同的字体。应该这样做：<br>
    选择一个字体必须是缺省的或者是最后一次GDI操作中选择的字体，如果你每次想使用 
    相同的字体的话，你应该自己选择字体再送到打印机DC中 </p>
    <pre>
StartDoc(.....);  // Omit if print job is already started.
StartPage( ..... );  // Omit if print job is already started.

// Get Printer DC from somewhere.......
CDC *pPrinterDC = ...

HFONT hCurrentFont = static_cast<HFONT>(
::GetCurrentObject(pPrinterDC-&gt;GetSafeHdc(), OBJ_FONT) );

if ( hCurrentFont )
{
    CFont fontTmp;

    LOGFONT current_FontInfo;

    // Get current font attributes.
    ::GetObject( hCurrentFont, sizeof(LOGFONT), &amp;current_FontInfo );

    // If this is not the font you want then create your own.
    if (........)
    {
        LOGFONT fontInfo;
        ZeroMemory( &amp;fontInfo, sizeof(LOGFONT) );

        //Create font.
        fontTmp.CreateFontIndirect( &amp;fontInfo );

        // Select font info the Printer DC.
        pPrinterDC-&gt;SelectObject( &amp;fontTmp );
    }

    // Do your drawing here..........
    pPrinterDC-&gt;TextOut( 0, 0, _T(&quot;Print here....&quot;) );

    // Select original font back into Printer DC.  This will
    // deselect fontTmp which will be deleted when it goes
    // out of scope.
    pPrinterDC-&gt;SelectObject( CFont::FromHandle(hCurrentFont) );
}

EndPage( .... );   // Omit if print job is already started.
EndDoc( ....... );  // Omit if print job is already started.</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq7"></a><br>
    </p>
    <font color="Red"><h3>动态菜单</h3>
    </font><p>问:在我的应用程序中(标准文档/视,带分隔),我想在按下鼠标后弹出一个上下文菜单. 
    这个菜单里包含几个主菜单项,我的问题是主菜单的ON_UPDATE_COMMAND_UI函数运行很 
    正常,但相同的弹出菜单却不能正常运行.</p>
    <p>答<br>
    1）先使用WM_INITMENUPOPUP消息,然后再调用TrackPopupMenu,那么一切都很正常. 
    </p>
    <pre>
AfxGetMainWnd()-&gt;SendMessage(WM_INITMENUPOPUP,
(WPARAM)pPopup-&gt;GetSafeHmenu(), (LPARAM)SubItem)

pPopup-&gt;TrackPopupMenu(TPM_LEFTALIGN, x, y, this);
</pre>
    <p>2）试一下这些:(BTW,这些代码已经是很久以前了,用的是VC2.0) </p>
    <pre>
BOOL CPopUpMenu::LocalRun (CPoint aPt, CWnd *pWnd, CMenu &amp;aMenu) const
{
    ASSERT (m_bIsSetup);
    if (!m_bIsSetup) return FALSE;

    if (m_bUseStringsNotIds)
        BuildMenu (m_nNumItems, aMenu, m_StringArray, m_pCommandIds);
      else
        BuildMenu (m_nNumItems, aMenu, m_pStringIds, m_pCommandIds);

    DoCommandUiProcessing(aMenu);
    HCURSOR hOldCursor = NULL;
    HCURSOR hStdCursor = ::LoadCursor (NULL, IDC_ARROW);
    if (hStdCursor != NULL)
        HCURSOR hOldCursor = ::SetCursor(hStdCursor);
    pWnd-&gt;ClientToScreen(&amp;aPt);
    BOOL bRet = aMenu.TrackPopupMenu(MENU_FLAGS, aPt.x, aPt.y, pWnd);
    if (hOldCursor != NULL)
        ::SetCursor (hOldCursor);
    return bRet;
}

void CPopUpMenu::DoCommandUiProcessing(CMenu &amp;aMenu) const
{
    CCmdUI menuState;
    menuState.m_pMenu = &amp;aMenu;
    menuState.m_nIndexMax = GetItemCount();
    menuState.m_pOther = NULL;
    menuState.m_pParentMenu = NULL;
    menuState.m_bEnableChanged = TRUE;
    UINT i;
    for (i=0; i<menuState.m_nIndexMax; ++i) { menuState.m_nIndex="i;" menuState.m_nID="GetItemId(i);" menuState.DoUpdate(AfxGetMainWnd(), TRUE); } }</pre>
<a
href="#PageBegin"></pre>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq8"></a><br>
    </p>
    <font color="Red"><h3>从CAsyncsocket::OnReceive消息中取得所有的数据</h3>
    </font><pre>问：微软推荐不要多重调用OnReceive函数。发送过来的数据大小是不固定的，但它的
数据头里面包含了一个大小信息。在缓冲区内我收到了很多的数据包，怎样我才能知道
里面有多少有用的信息？</pre>
    <p>答：<br>
    1）可以这样，先发送一个信息头，通知下一个数据包有多大？在CAsyncSocket继承的 
    类中加入些私有变量： Bool 数据头是否读取 long 接收数据的长度 long 
    目前收到的数据 char * 指向接收数据包的指针 char * 
    上述指针的偏移地址 
    当你收到数据头时：先设置布尔量通告你已经收到，将接收数据的长度设置为收到的 
    数据，目前收到的数据设置为零。分配接收数据包的指针，设置该指针的偏移地址。 
    每次OnReceive中收到数据时，如果此时已接收的数据包比数据包总长度小时，则将其 
    加入已接收的数据包中并对已接收的数据包作相应的调用。当两者相等时，就说明你已 
    经收到全部的数据。 至此已经可以正常工作了。</p>
    <p>2）我猜想你使用了一个从CSocket继承的类，并想从OnReceive()中得到所有的数据，如果 
    是这种情况的话，你可以建立一个CSocketFile，然后使用CArchive来接收数据。你首先 
    接收到的是头信息，告知你总的长度，然后准备接收后面的信息。下面是一个例子。 
    假设类的定义如CMySocket </p>
    <pre>CMySocket::CMySocket()
{
        m_pFile = new CSocketFile(this);
         m_pArchiveIn = new CArchive(m_pFile,CArchive::load);
        m_pArchiveOut = new CArchive(m_pFile,CArchive::store);
}

int CMySocket::Serialize(CArchive&amp; ar, BYTE *uszBuf, int iBufLen)
{
     if (ar.IsStoring())
     {
          // begin to Store - write data to the archive
            ar.Write((const char*)uszBuf, iBufLen);
            TRY
            {   ar.Flush();  }
            CATCH( CFileException, e )
            {
                  if( e-&gt;m_cause == CFileException::fileNotFound )
                  AfxErrorMessageBox( &quot;ERROR: File not found\n&quot;);
             }
              END_CATCH

              return iBufLen;
      }
     else
              // Begin to load - read data from the archive
              int iHeaderLen = 10;
              for (i=0; i<iHeaderLen; i+;) ar>&gt;uszBuf[i++];

              // Caculate your message len here, let suppose you get iMsgLen

                int iLoaded = iHeaderLen;
              do
              {
                    ar &gt;&gt;uszBuf[iLoaded++];
              }while ( iLoaded <iMsgLen && iLoaded <iBufLen); return(iLoaded); } } </pre>
然后在你的OnReceive()运行
</pre>
    <pre>Serialize(*m_pArchiveIn , uszBuf, iBufLen);</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <hr>
    <a href="cmfcv40.htm"><div align="center"><center><pre>前一期</a>|<a href="cmfcv37.htm">后一期</a>

<a
href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供!</pre>
    </center></div></td>
  </tr>
</table>
</center></div>

<p><a name="PageBegin"></a></p>
</body>
</html>
