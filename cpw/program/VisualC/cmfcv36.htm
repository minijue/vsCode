<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title></title>
</head>

<body bgcolor="#8080C0">
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="95%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="Vcidx098.htm">Visual 
    C++/C++</a> --&gt;</b> MFC邮递表的中文翻译(第三十六期)</span></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="1" width="95%" style="font-size: 9pt" bgcolor="#FFFFFF"
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"
    bordercolordark="#FFFFFF">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://chinaprog.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<h2 align="center"><span style="font-size: 9pt">MFC邮递表的中文翻译</span></h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;我是一名mfc程序设计的爱好者,订阅了mfc的maillist,利用业余时间 
    将它翻译出来,希望能对mfc编程的朋友有所帮助,请朋友们指正.<br>
    </p>
    <h3><font color="#FF0000">第三十六期目录</font> <fontsize="2">杨晓东 1999.5.4</h3>
    <ol>
      <li><a href="#volq1">打印机</a> </li>
      <li><a href="#volq2">通用对话框的问题</a> </li>
      <li><a href="#volq3">工具条类型</a> </li>
      <li><a href="#volq4">以不同的格式保存文件</a> </li>
      <li><a href="#volq5">列表视中的单行选择</a> </li>
      <li><a href="#volq6">MFC ActiveX事件引起的冲突</a> </li>
      <li><a href="#volq7">将一个自定义控件与自定义类相关联</a> </li>
      <li><a href="#volq8">非模态对话框浮在最上面</a> </li>
      <li><a href="#volq9">将一个自定义控件与自定义类相关联</a> </li>
      <li><a href="#volq10">在OnInitDialog中初始化所有的属性页</a> </li>
    </ol>
    <p><a name="volq1"></a></p>
    <p><br>
    </p>
    <font color="Red"><h3>打印机</h3>
    </font><p>问:在新的项目中,我想使用户能具体指定某台打印机来实现打印任务.怎样我才能从打印 
    机的基本数据中建立一个DEVMODE结构?</p>
    <p>答:我也曾经做过同样的事情,我是通过在注册表中保存用户所选择的打印机的名字 
    用EnumPrinter和Windows中的打印机相关联.在选择CR(打印机)用SelectPrinter() 
    前先取得该设备的名称以及端口就可以了.你也可以通过这种方法来保存更多的细节. 
    以此来调整更多的CR参数. 程序部分代码如下: </p>
    <pre>    //  检查系统打印机的资源信息,将相匹配的信息保存在注册表中,注意共享打印机
    //  是不能由&quot;通常&quot;的手段来检测的.因此我们需要两种函数形式以此来对应不同
    //  两种情况

    CString strReportPrinter;
    QRegistry::Get(QREG_REPORT_PRINTER_NAME, strReportPrinter);

    DWORD   cbNeeded            = 0;
    DWORD   dwPrinter           = 0;
    BYTE    byPrinterInfo[2048] = {0};
    DWORD   cbPrinterInfo       = sizeof(byPrinterInfo);
    DWORD   cReturned           = 0;

    PRINTER_INFO_2* ppri2 = reinterpret_cast<PRINTER_INFO_2*>(byPrinterInfo);

    if (EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS |
PRINTER_ENUM_SHARED,
        NULL, 2, byPrinterInfo, cbPrinterInfo, &amp;cbNeeded, &amp;cReturned))
    {
        for (dwPrinter = 0; dwPrinter <cReturned; dwPrinter++) { if (!strReportPrinter.CompareNoCase(ppri2[dwPrinter].pPrinterName)) break; } } if (dwPrinter>= cReturned)
    {
        if (EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
            NULL, 2, byPrinterInfo, cbPrinterInfo, &amp;cbNeeded, &amp;cReturned))
        {
            for (dwPrinter = 0; dwPrinter <cReturned; dwPrinter++) { if (!strReportPrinter.CompareNoCase(ppri2[dwPrinter].pPrinterName)) break; } } } // 如果找到了打印机名,那么就可以使用了,没有的话,可以用GetSelectedPrinter() // 函数返回的名字指定缺省的打印机.注意,下面的代码同样也设置了纸张的类型(A4) CString strDriverName; CString strPrinterName; CString strPortName; DEVMODE* pMode="NULL;" if (app->printJob-&gt;GetSelectedPrinter(strDriverName, strPrinterName,
strPortName, &amp;pMode))
    {
        ASSERT(pMode != NULL);

        pMode-&gt;dmTTOption    = DMTT_DOWNLOAD;
        pMode-&gt;dmOrientation = DMORIENT_LANDSCAPE;
        pMode-&gt;dmColor       = DMCOLOR_MONOCHROME;
        pMode-&gt;dmPaperSize   = DMPAPER_A4;

        if (dwPrinter <cReturned) { strDriverName="ppri2[dwPrinter].pDriverName;" strPrinterName="ppri2[dwPrinter].pPrinterName;" strPortName="ppri2[dwPrinter].pPortName;" } app->printJob-&gt;SelectPrinter(strDriverName, strPrinterName, strPortName,
pMode);
    }</pre>
    <p>2) 这儿有一种办法,下面代码中从打印机中取得DEVMODE结构,然后你就可以做你想做的 
    事情了 </p>
    <pre>PRINTDLG pd;
ZeroMemory(&amp;pd, sizeof(PRINTDLG));
AfxGetApp()-&gt;GetPrinterDeviceDefaults(&amp;pd);

DEVMODE* pDV = (LPDEVMODE) ::GlobalLock(pd.hDevMode);
//Do something with the data...
GlobalUnlock(pd.hDevMode);
</pre>
    <p>3) 我实现过这样的问题,我是将打印机名称保存在注册表中,同时还保存了我所感兴趣的 
    如纵向还是横向,纸张大小等等,比如可以保存为类似下面的信息. </p>
    <pre>
&quot;HP LaserJet 5Si/5Si MX PS&quot;
一旦有了打印机的名字,你就可以取得DEVMODE和DEVNAMES结构,就可以使用函数
CWinApp::SelectPrinter.为了得到DEVMODE结构,我采用了下面的函数.
HANDLE GetDevMode(LPCTSTR pszPrinter)
{
    // Open the printer
    HANDLE hPrinter;
    if (!::OpenPrinter(pszPrinter, &amp;hPrinter, NULL))
        return NULL;    // Failed to open printer
    // Get the size needed for the DEVMODE structure
    DWORD dwSize = ::DocumentProperties(NULL, hPrinter, pszPrinter,
                NULL, NULL, 0);
    if (!dwSize) {
        ::ClosePrinter(hPrinter);
        return NULL;
    }
    // Allocate a DEVMODE buffer
    HANDLE hDevMode;
    if ((hDevMode = ::GlobalAlloc(GMEM_ZEROINIT|GMEM_MOVEABLE, dwSize)) ==
NULL) {
        ::ClosePrinter(hPrinter);
        return NULL;
    }
    // Lock memory (sheesh ... )
    LPDEVMODE pDevMode = (LPDEVMODE)::GlobalLock(hDevMode);
    if (!pDevMode) {
        ::GlobalFree(hDevMode);
        ::ClosePrinter(hPrinter);
        return NULL;
    }
    // Fetch DEVMODE structure for this printer
    ::DocumentProperties(NULL, hPrinter, pszPrinter,
        pDevMode, NULL, DM_OUT_BUFFER);
    // Now we can unlock the structure
    ::GlobalUnlock(hDevMode);
    // Return the DEVMODE handle
    return hDevMode;
}
</pre>
    <p>我又用下面的函数取得DEVNAMES结构. </p>
    <pre>HANDLE GetDevNames(LPCTSTR pszPrinter)
{
    // Open the printer
    HANDLE hPrinter;
    if (!::OpenPrinter(pszPrinter, &amp;hPrinter, NULL))
        return NULL;
    // We need the port and driver names, so
    // we need to fetch a PRINTER_INFO_2
    // structure
    DWORD cbNeeded;
    // First, get the size of the structure
    // that we will need to allocate
    if (::GetPrinter(hPrinter, 2, NULL, 0, &amp;cbNeeded)) {
        if (::GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            ::ClosePrinter(hPrinter);
            return NULL;
        }
    }
    // Allocate the buffer
    PRINTER_INFO_2* pi = (PRINTER_INFO_2*)new BYTE [cbNeeded];
    if (!pi) {
        ::ClosePrinter(hPrinter);
        return NULL;
    }
    // Get the PRINTER_INFO_2
    // structure
    DWORD cbUsed;
    if (!::GetPrinter(hPrinter, 2, (LPBYTE)pi, cbNeeded, &amp;cbUsed)) {
        delete [] pi;
        ::ClosePrinter(hPrinter);
        return NULL;
    }
    // Get the driver/port name
    CString strDriver = pi-&gt;pDriverName;
    CString strPort = pi-&gt;pPortName;
    delete [] pi;
    ::ClosePrinter(hPrinter);
    // Now create the DEVNAMES structure
    int nDriverLen = strDriver.GetLength();
    int nDeviceLen = _tcslen(pszPrinter);
    int nPortLen = strPort.GetLength();
    // Allocate size of everything + 5 extra bytes for zeroes
    DWORD dwSize = sizeof(DEVNAMES) + ((nDriverLen + nDeviceLen +
            nPortLen + 5) * sizeof(TCHAR));
    HANDLE hDevNames;
    if ((hDevNames = ::GlobalAlloc(GMEM_ZEROINIT|GMEM_MOVEABLE, dwSize)) ==
NULL)
        return NULL;
    // Lock the ptr
    LPDEVNAMES pDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);
    if (!pDevNames)
        return NULL;
    // Fill in the structure details
    pDevNames-&gt;wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
    _tcscpy((LPTSTR)pDevNames + pDevNames-&gt;wDriverOffset, strDriver);
    pDevNames-&gt;wDeviceOffset = pDevNames-&gt;wDriverOffset + nDriverLen + 1 ;
    _tcscpy((LPTSTR)pDevNames + pDevNames-&gt;wDeviceOffset, pszPrinter);
    pDevNames-&gt;wOutputOffset = pDevNames-&gt;wDeviceOffset + nDeviceLen + 1 ;
    _tcscpy((LPTSTR)pDevNames + pDevNames-&gt;wOutputOffset, strPort);
    // Unlock memory
    ::GlobalUnlock(hDevNames);
    // Return the DEVNAMES handle
    return hDevNames;
}</pre>
    <p>然后,在CWinApp继承的类中,我就可以改变打印机的选择了. 
    SelectPrinter(GetDevNames(&quot;printer name&quot;), GetDevMode(&quot;printer 
    name&quot;)); 上面的代码在9x以及NT中运行通过.为了设置打印机的一些参数,比如纸张大小等等, 
    我在我的文档继承类中使用:(在CWinApp::SelectPrinter之后调用) </p>
    <pre>PRINTDLG pd;
::ZeroMemory(&amp;pd, sizeof(pd));
pd.lStructSize = sizeof(PRINTDLG);
if (theApp.GetPrinterDeviceDefaults(&amp;pd)) {
    LPDEVMODE pDevMode = (LPDEVMODE)::GlobalLock(pd.hDevMode);
    LPDEVNAMES pDevNames = (LPDEVNAMES)::GlobalLock(pd.hDevNames);
    if (pDevMode &amp;&amp; pDevNames) {
        HANDLE hPrinter;
        // Get the device name
        char *pDevice = (char *)pDevNames + pDevNames-&gt;wDeviceOffset;
        // Open printer
        if (::OpenPrinter(pDevice, &amp;hPrinter, NULL)) {
            // Set portrait/landscape, paper size, etc.
            if (pDevMode-&gt;dmFields &amp; DM_ORIENTATION)
                pDevMode-&gt;dmOrientation = m_nOrientation;
            if (pDevMode-&gt;dmFields &amp; DM_PAPERSIZE)
                pDevMode-&gt;dmPaperSize = m_nPaperSize;
            if (pDevMode-&gt;dmFields &amp; DM_DUPLEX)
                pDevMode-&gt;dmDuplex = m_nDuplex;
            // Apply new settings
            ::DocumentProperties(NULL, hPrinter, pDevice,
                pDevMode, pDevMode, DM_IN_BUFFER|DM_OUT_BUFFER);
            ::ClosePrinter(hPrinter);
        }
    }
    ::GlobalUnlock(pd.hDevMode);
    ::GlobalUnlock(pd.hDevNames);
}</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq2"></a><br>
    </p>
    <font color="Red"><h3>通用对话框的问题</h3>
    </font><p>问:如果我在文件对话框中选择了某个文件,然后点击&quot;打开&quot;按钮,DoModal()函数返回 
    1(IDOK),但如果我选择了多个文件,DoModal()函数却返回2(IDCANCEL)</p>
    <p>答:如果设置了OFN_ALLOWMULTISELECT标志,而又选择了多个文件时.指针指向一个可以容纳 
    所选择文件名的区域.这个缓冲区包括了所选择的文件的文件名以及路径.在Explorer 
    类型的对话框中,路径和文件名字符串是用NULL分隔的,在最后一个文件名中以NULL结尾. 
    老式的对话框中,串是用空格来分隔的.你可以使用FindFirstFile函数来转换长文件名 
    和短文件名,如果这个缓冲区太小的话,函数将会返回FALSE,CommDlgExtendedError() 
    函数返回FNERR_BUFFERTOOSMALL,在这种情况下,最前两个字节指出缓冲区应该的大小, 
    单位是字节或者是字符数.<br>
    nMaxFile<br>
    指定缓冲区的大小,以一个字节为单位(ANSI或UNICODE),如果该区域太小不能容纳 
    文件信息时,GetOpenFileName和GetSaveFileName函数返回FALSE.该区域至少为 256字符数<br>
    简单地说,你需要提供比文件对话框提供的空间一个更大的空间,前者只有_MAX_PATH长.<br>
    2)你是否调用了CommDlgExtendError取得更详细的资料?<br>
    我想可能是给OPENFILENAME结构的缓冲区太小了,MFC中只提供了_MAX_PATH或260个字符 
    而这对选择多个文件来说,显得小了些.<br>
    你可以调用CommDlgExtendedError函数,应该返回一个FNERR_BUFFERTOOSMALL,参照 
    文件说明中的OPENFILENAME结构.<br>
    <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq3"></a><br>
    </p>
    <font color="Red"><h3>工具条类型</h3>
    </font><p>问:我有一个编好的项目,里面有一些老式的工具条.现在我想将它转换为VC6,并希望 
    工具条能够象IEcplorer工具条那样,从一个新的VC6项目中建立的那样.怎样我才能不 
    必重新建立整个项目?</p>
    <p>答:用向导建立两个项目,一个为老式工具条,一个为新类型.使用WinDif比较它们,看看 
    它们有什么不同,然后再运用到你的项目中去.<br>
    注意1:IE类型的工具条不支持停靠/浮动,它只能在最上面,在你改变之前先检查一下.<br>
    2.你可以用与Dev-Studio或者Office类似的工具条替换IE工具条,只需要简单的加一 
    个标志就可以实现,比起IE类型的要简单多了.<br>
    2) 在调用Create()建立工具条(通常在CMainFrame::OnCreate())后加入一行 </p>
    <pre>m_wndToolBar.ModifyStyle(0, TBSTYLE_FLAT);</pre>
    <p>其中,m_wndToolBar则你的工具条的名称.<br>
    <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq4"></a><br>
    </p>
    <font color="Red"><h3>以不同的格式保存文件</h3>
    </font><p>问:我写了一个MDI程序,用来显示一些图形.[snip]在一些操作之后,我想以不同的格式 
    保存文件,问题是在MFC中该如何保存文件的不同格式?当&quot;保存文件&quot;对话框出现后,文件 
    类型的下拉框里只有预先设定的类型,怎样才能加入更多的文件类型?</p>
    <p>答:解决的方法是重载<br>
    OnFileOpen 在 CWinApp.<br>
    OnFileSave 在 CDocument<br>
    OnFileSaveAs 在 CDocument<br>
    我通常为了以下目的:<br>
    *在文件对话框里加入新的文件类型<br>
    *记住最后一个使用的文件的路径<br>
    *记住最后一个使用的文件类型<br>
    最简单的方法是看一下MFC是如何实现的,然后将它们重制到你所想加入的地方.<br>
    <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq5"></a><br>
    </p>
    <font color="Red"><h3>列表视中的单行选择</h3>
    </font><p>问:怎样才能在一个列表视中关闭选择多行的属性?我使用LVS_FULLROWSELECT 
    选择一整行.</p>
    <p>答:你可以在资源编辑器中关闭选择多行的性质.在列表控件的属性中,选择类型属性 
    页.选中单个选择(single selection)属性.这就是你要做的全部.<br>
    2) 请加入LVS_SINGLESEL类型,缺省值是多行选择.<br>
    <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq6"></a><br>
    </p>
    <font color="Red"><h3>MFC ActiveX事件引起的冲突.</h3>
    </font><p>问:我用程序向导生成了简单的ActiveX控件,里面有多个自定义的属性,方法和事件. 
    现在我想扩展该控件的一个事件,当用户或程序员改变时,这些改变由该控件决定程序 
    下一步的流向,谁能告诉我在VC5中该如何处理?</p>
    <p>答:1)在事件中加入变量,以此为参考.从类向导中作为一个指针来选择你的类型.<br>
    2) 试一下用 long* 和VARIANT_BOOL作为参数来替换 long和BOOL<br>
    (VB中不会将BOOL理解为Boolean)<a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq7"></a><br>
    </p>
    <font color="Red"><h3>将一个自定义控件与自定义类相关联.</h3>
    </font><p>问: 怎样我才能将我自己的Combobox控件与自定义控件相匹配,让它能在视中显示出来?</p>
    <p>答:1)看一下SubclasWindow().<br>
    2)你可以通过自定义类来完成此类任务.你所定义的是一个窗口类,所以要用RegisterWinClass 
    为你的类选择一个唯一的名称.<br>
    我是用这种方法来实现的:首先为该控件调用RegisterClass来准备一个窗口过程. 
    这个窗口过程的目的是为了建立一个新的实例,并与窗口对象相匹配.<br>
    1).在类声明中加入下列的代码,比如在.h文件中 </p>
    <pre>
public:
        static BOOL RegisterControlClass();
protected:
   virtual void PostNcDestroy();
        static LRESULT CALLBACK EXPORT WndProcHook(HWND, UINT, WPARAM, LPARAM);
</pre>
    <p>2.在定义文件加入下列代码 </p>
    <pre>
LRESULT CALLBACK EXPORT
CYourComboClass::WndProcHook(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
        // create new item and attach it
        CYourComboClass* pCombo = new CDoorMon();
        pCombo-&gt;Attach(hWnd);

        // set up wndproc to AFX one, and call it
        pCombo-&gt;m_pfnSuper = CYourComboClass::lpfnSuperEdit;
        ::SetWindowLong(hWnd, GWL_WNDPROC, (DWORD)AfxWndProc);

        // then call it for this first message
#ifdef STRICT
        return ::CallWindowProc(AfxWndProc, hWnd, msg, wParam, lParam);
#else
        return ::CallWindowProc((FARPROC)AfxWndProc, hWnd, msg, wParam, lParam);
#endif
}

void CYourComboClass::PostNcDestroy()
{
        // needed to clean up the C++ CWnd object
        delete this;
}

BOOL CYourComboClass::RegisterControlClass()
{
        WNDCLASS wcls;

        // check to see if class already registered
        static const TCHAR szClass[] = _T(&quot;YOURCOMBOCLASSNAME&quot;);
        if (::GetClassInfo(AfxGetInstanceHandle(), szClass, &amp;wcls))
        {
                // name already registered - ok if it was us
                return (wcls.lpfnWndProc == (WNDPROC)CYourComboClass::WndProcHook);
        }

        // set new values
        wcls.style = CS_SAVEBITS;
        wcls.lpfnWndProc = CDoorMon::WndProcHook;
        wcls.cbClsExtra = 0;
        wcls.cbWndExtra = 0;
        wcls.hInstance = AfxGetInstanceHandle();
        wcls.hIcon = NULL;
        wcls.hCursor = NULL;
        wcls.hbrBackground = (HBRUSH)(1+COLOR_BACKGROUND);
        wcls.lpszMenuName = NULL;
        wcls.lpszClassName = szClass;
        return (RegisterClass(&amp;wcls) != 0);
}
</pre>
    <p>然后从你的DllMain函数中调用CYourComboClass::RegisterControlClass. <a
    href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq8"></a><br>
    </p>
    <font color="Red"><h3>非模态对话框浮在最上面.</h3>
    </font><p>问:建立非模态对话框时,它总是在主窗口的最上面,如何才能使它的主窗口显示在上面.</p>
    <p>答:1)你有没有试过AfxGetMainWnd()-&gt;SetForegroundWindow(),在建立你的非模态 
    对话框之后?<br>
    2)当你建立对话框时,向导建立的构造函数有一个指针指出该对话框的父窗口,如果 
    你输入一个窗口,那么该对话框将总是显示在该窗口的上面,如果你输入一个NULL 
    那么该对话框就可以在主程序窗口的上面或者下面了.不过这时要仔细考虑用户界 
    面,如果非模态对话框在主窗口消失,会不会让你的用户产生误会?是否将非模态对 
    话框显示在任务条上.<br>
    <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq9"></a><br>
    </p>
    <font color="Red"><h3>如何将视与文档相匹配</h3>
    </font><p>问:我有四本关于VC的书,他们讨论了怎样动态建立一个视,但没有涉及如何将视与文档 
    相关联.我建立了两个视,但无法匹配.</p>
    <p>答:将一个视关联到一个文档,可以在建立视时,将相关联的文档指针指向你建立的对象中. 
    </p>
    <pre>
CCreateContext context;
context.m_pCurrentDoc = GetDocument();
</pre>
    <p>2)假定你使用的是单文档.为了将左视与已存在的文档相关联,在视的CPP文件中 
    加入一个函数GetDocument() </p>
    <pre>
    CMyDoc* CLeftView::GetDocument()
    {
        ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CMyDoc)));
        return (CMyDoc*)m_pDocument;
    }
</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq10"></a><br>
    </p>
    <p>在OnInitDialog中初始化所有的属性页. 问:一个属性表中有三个属性页,缺省的第一页是在DoModal调用时被建立.而第二页 
    第三页必须由自己建立,怎样我才能一下子全部建立? 答:可以这样做: 
    1.用资源编辑器建立对话框模板. 2.为每个模板建立一个新的类,从CPropertyPage类中继承.为每个控件加数据成员. 
    3.从CPropertySheet类中继承一个新类. 4. 在新建的sheet类中,为每一个页类加入一个数据成员. 
    5. 在sheet的构造函数中,为每个页调用一次成员函数AddPage().通过参数将页对象加 
    入到表中. 6. 在程序中加入: CMyPropertySheet cps(&quot;My Sheet Caption&quot;); 
    cps.DoModal(); 2)过去,在显示对话框之前,我都是激活所有的页,用CPropertySheet::SetActivePage. 
    是粗糙了,但工作很正常 <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <hr>
    <a href="cmfcv37.htm"><p align="center">前一期</a>|<a href="cmfcv35.htm">后一期</a><br>
    <a href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供! 
    </td>
  </tr>
</table>
</center></div>

<p><a name="PageBegin"></a></p>
</body>
</html>
