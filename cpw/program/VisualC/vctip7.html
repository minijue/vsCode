<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<meta NAME="doccomm" CONTENT="sss">
<meta NAME="Template" CONTENT="C:\MSOffice\Template\Sl_BOOK.dot">
<meta NAME="Author" CONTENT="Cheng Jinxing">
<title>Visual C++编程技巧之七</title>
</head>

<body TEXT="#000000" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"
background="../../res/back.JPG" style="font-size: 9pt">

<p align="center"><strong><font face="Arial" size="4">Visual C++</font><font size="4">编程技巧之七 
</font></strong></p>

<p align="center">转载于&quot;<a href="http://kahn.xj.cninfo.net/wwchina/"
target="_blank">程序员集中营</a>&quot;</p>

<p><a HREF="#tip49"><font SIZE="+0" FACE="Times New Roman">49</font><font SIZE="+0">、如何实现一个橡皮区矩形</font></a> 
</p>

<p><a HREF="#tip50"><font SIZE="+0" FACE="Times New Roman">50</font><font SIZE="+0">、如何更新翻转背景颜色的文本</font></a> 
</p>

<p><a HREF="#tip51"><font SIZE="+0" FACE="Times New Roman">51</font><font SIZE="+0">、如何创建一个具有特定点大小的字体</font></a> 
</p>

<p><a HREF="#tip52"><font SIZE="+0" FACE="Times New Roman">52</font><font SIZE="+0">、如何计算一个串的大小</font></a> 
</p>

<p><a HREF="#tip53"><font SIZE="+0" FACE="Times New Roman">53</font><font SIZE="+0">、如何显示旋转文本</font></a> 
</p>

<p><font FACE="宋体"><a HREF="#tip54">54、如何正确显示包含标签字符的串</a></font> 
</p>

<p><a HREF="#tip55"><font SIZE="+0" FACE="Times New Roman">55</font><font SIZE="+0">、串太长时如何在其末尾显示一个省略号</font></a> 
</p>

<p><a HREF="#tip56"><font SIZE="+0" FACE="Times New Roman">56</font><font SIZE="+0">、如何快速地格式化一个</font><font
SIZE="+0" FACE="Times New Roman">CString</font><font SIZE="+0">对象</font></a> </p>

<p><font SIZE="+2"><b>　</b></font> </p>

<p><a NAME="tip49"></a><b><font SIZE="+2"><font FACE="Times New Roman">49</font><font
FACE="黑体">、如何实现一个橡皮区矩形</font></font></b> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">CRectTracker</font>是一个很有用的类，可以通过调用<font
FACE="Times New Roman">CRectTracker:: TrackRubberBand</font>响应<font
FACE="Times New Roman">WM_LBUTTONDOWN</font>消息来创建一个橡皮区矩形。下例表明使用<font
FACE="Times New Roman">CRectTracker</font>移动和重置视窗中的蓝色椭圆的大小是很容易的事情。</font> 
</p>

<p><font SIZE="+0">首先，在文件档中声明一个<font FACE="Times New Roman">CRectTracker</font>数据成员：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">class CSampleView : Public CView</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">public :</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CrectTracker m_tracker;</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">};</font> </p>

<p><font SIZE="+0">其次，在文档类的构造函数中初始化<font
FACE="Times New Roman">CRectTracker </font>对象：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CSampleDoc:: CSampleDOC ()</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Initialize tracker position, size and style.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">m_tracker.m_rect.SetRect (0, 0, 10, 10);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_tracker.m_nStyle=CRectTracker:: resizeInside |</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">CRectTracker:: dottedLine;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">然后，在<font FACE="Times New Roman">OnDraw</font>函数中画椭圆和踪迹矩形：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CSampleDoc* pDoc=GetDocument ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (pDoc);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Select blue brush into device context.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush brush (RGB (0, 0, 255));</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush* pOldBrush=pDC-&gt;SelectObject 
(&amp;brush);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//draw ellipse in tracking rectangle.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">Crect rcEllipse;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDoc-&gt;m_tracker.GetTrueRect (rcEllipse);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;Ellipse (rcEllipse);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw tracking rectangle.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDoc-&gt;m_tracker.Draw (pDC);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Select blue brush out of device context.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;Selectobject (pOldBrush);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">最后，使用<font FACE="Times New Roman">ClassWizard</font>处理<font
FACE="Times New Roman">WM_LBUTTONDOWN</font>消息，并增加下述代码。该段代码根据鼠标击键情况可以拖放、移动或者重置椭圆的大小。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView::OnLButtonDown (UINT nFlags, 
CPoint point)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Get pointer to document.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CSampleDoc* pDoc=GetDocument ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (pDoc);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//If clicked on ellipse, drag or resize it. 
Otherwise create a</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//rubber-band rectangle nd create a new ellipse.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">BOOL bResult=pDoc-&gt;m_tracker.HitTest 
(point)!=</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRectTracker::hitNothing;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Tracker rectangle changed so update views.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">if (bResult)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDoc-&gt;m_tracker.Track (this,point,TRue);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">pDoc-&gt;SetModifiedFlag ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDoc-&gt;UpdateAllViews (NULL);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">else</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDoc-&gt;m-tracker.TrackRubberBand 
(this,point,TRUE);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CView:: onLButtonDown (nFlags,point);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip50"></a><b><font SIZE="+2"><font FACE="Times New Roman">50</font><font
FACE="黑体">、如何更新翻转背景颜色的文本</font></font></b> </p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">CDC:: SetBkmode</font>并传送<font
FACE="Times New Roman">OPAQUE</font>用当前的背景颜色填充背景，或者调用<font
FACE="Times New Roman">CDC::SetBkMode</font>并传送<font FACE="Times New Roman">TRANSPAARENT</font>使背景保持不变，这两种方法都可以设置背景模式。下例设置背景模式为<font
FACE="Times New Roman">TRANSPARENT</font>，可以两次更新串，用花色带黑阴影更新文本。黑色串在红色串之后，但由于设置了背景模式仍然可见。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Determint size of view.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect rcView;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetClientRect (rcVieew);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Create sample string to display.</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">CString str (_T (&quot;Awesome Shadow Text</font>．．．<font
FACE="Times New Roman">&quot;));</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Set the background mode to transparent.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SetBKMode (TRANSPARENT);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw black shadow text.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">rcView.OffsetRect (1, 1);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDc-&gt;SetTextColor (RGB (0, 0, 0));</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;DrawText (str, str.GetLength (), rcView,</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">DT_SINGLELINE | DT_CENTER | DT_VCENTER);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw red text.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">rcView.OffsetRect (-1,-1);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDc-&gt;SetTextColor (RGB (255, 0, 0));</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;DrawText (str, str.GetLength (), rcView,</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">DT_SINGLELINE | DT_CENTER | DT_VCENTER);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip51"></a><b><font SIZE="+2"><font FACE="Times New Roman">51</font><font
FACE="黑体">、如何创建一个具有特定点大小的字体</font></font></b> </p>

<p><font SIZE="+0">可以指定字体逻辑单位的大小，但有时指定字体的点的大小可能会更方便一些。可以如下将字体的点转换为字体的高度：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">int nHeigth=mulDiv (nPointSize, 
-dc.GetDeviceCaps (LOGPIXELSY), 72);</font> </p>

<p><font SIZE="+0">下例创建了一个<font FACE="Times New Roman">8</font>点的<font
FACE="Times New Roman">Apial</font>字体：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CClientDC dc (AqfxGetMainWnd ());</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_font. CreateFont (MulDiv (8, -dc.GetDeviceCaps 
(LOGPIXELSY),</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">72),0,0,0,FW_NORMAL,0,0,0,ANSI_CHARSET,</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">OUT_STROKE_PRECIS,CLIP_STROKE_PRECIS,DRAFT_QUALITY,</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">VARIABLE_PITCH | FF-SWISS,_T 
(&quot;Arial&quot;));</font> </p>

<p><a NAME="tip52"></a><b><font SIZE="+2"><font FACE="Times New Roman">52</font><font
FACE="黑体">、如何计算一个串的大小</font></font></b> </p>

<p><font SIZE="+0">函数<font FACE="Times New Roman">CDC:: Det text Extent </font>根据当前选择的字体计算一个串的高度和宽度。如果使用的不是系统字体而是其他字体，则在调用<font
FACE="Times New Roman">GetTextExtent</font>之前将字体选进设备上下文中是很重要的，否则计算高度和宽度时将依据系统字体，由此得出的结果当然是不正确的。下述样板程序当改变下压按钮的标题时动态调整按钮的大小，按钮的大小由按钮的字体和标题的大小而定。响应消息<font
FACE="Times New Roman">WM_SETTEXT</font>时调用<font FACE="Times New Roman">OnSetText</font>，该消息使用<font
FACE="Times New Roman">ON_MESSAE</font>宏指令定义的用户自定义消息。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">LRESULT CMyButton:: OnSettext (WPARAM wParam, 
LPARAM lParam)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Pass message to window procedure.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">LRESULT bResult=CallWindowProc 
(*GetSuperWndProcAddr (),</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_hWnd, GetCurrentMessage () 
-&gt;message,wParam,lParam);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Get title of push button.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CString strTitle;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetWindowText (strTitle);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Select current font into device context.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">CDC* pDC=GetDc ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CFont*pFont=GetFont ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CFont*pOldFont=pDC-&gt;SelectObject (pFont);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Calculate size of title.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CSize size=pDC-&gt;GetTextExent 
(strTitle,strTitle.GetLength ());</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Adjust the button's size based on its title.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Add a 5-pixel border around the button.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">SetWindowPos (NULL, 0, 0, size.cx+10, 
size.cy+10,</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Clean up.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SelectFont (pOldFont);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ReleaseDC (pDC);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return bResult;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip53"></a><b><font SIZE="+2"><font FACE="Times New Roman">53</font><font
FACE="黑体">、如何显示旋转文本</font></font></b> </p>

<p><font SIZE="+0">只要用户使用<font FACE="Times New Roman">TrueType</font>或者<font
FACE="Times New Roman">GDI</font>笔或字体就可以显示旋转文本<font
FACE="Times New Roman">(</font>有些硬件设备也支持旋转光栅字体）。<font
FACE="Times New Roman">LOGFONT</font>结构中的<font FACE="Times New Roman">ifEscapement</font>成员指定了文本行和<font
FACE="Times New Roman">x</font>轴的角度，角度的单位是十分之一度而不是度，例如，<font
FACE="Times New Roman">ifEscapement</font>为<font FACE="Times New Roman">450</font>表示字体旋转<font
FACE="Times New Roman">45</font>度。为确保所有的字体沿坐标系统的同一方向旋转，一定要设置<font
FACE="Times New Roman">ifEscapement</font>成员的<font FACE="Times New Roman">CLIP_LH_ANGLES</font>位，否则，有些字体可能反向旋转。下例使用了<font
FACE="Times New Roman">14</font>点<font FACE="Times New Roman">Arial</font>字体每间隔<font
FACE="Times New Roman">15</font>度画一个串。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Determine the size of the window.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect rcClient;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetClientRect (rcClient);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Create sample string.</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">CString str (_T (&quot;Wheeee</font>．．．<font
FACE="Times New Roman">I am rotating!&quot;));</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw transparent, red text.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SetBkMode (TRANSPARENT);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SetTextColor (RGB (255,0,0));</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CFont font; //font object</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">LOGFONT stFont; //font definition</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Set font attributes that will not change.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">memset (&amp;stFont, 0, sizeof (LOGFONT));</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">stFont.ifheight=MulDiv (14, 
-pDC-&gt;GetDeviceCaps (LOGPIXELSY), 72);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">stFont.ifWeight=FW_NORMAL;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">stFont.ifClipPrecision=LCIP_LH_ANGLES;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">strcpy (stFont.lfFaceName, &quot;Arial&quot;);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw text at 15degree intervals.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">for (int nAngle=0; nAngle&lt;3600; nAngle+=150)</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Specify new angle.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">stFont.lfEscapement=nAngle;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Create and select font into dc.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">font.CreateFontIndirect (&amp;stfont);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CFont* pOldFont=pDC-&gt;SelectObject 
(&amp;font);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw the text.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SelectObject (pOldFont);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">font.DelectObjext ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip54"></a><font SIZE="+2" FACE="黑体">54、如何正确显示包含标签字符的串</font> 
</p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">GDI</font>文本绘画函数时需要展开标签字符，这可以通过调用<font
FACE="Times New Roman">CDC:: TabbedTextOut</font>或者<font FACE="Times New Roman">CDC:: 
DrawText</font>并指定<font FACE="Times New Roman">DT_EXPANDTABS</font>标志来完成。<font
FACE="Times New Roman">TabbedTextOut</font>函数允许指定标签位的数组，下例指定每<font
FACE="Times New Roman">20</font>设备单位展开一个标签：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CTestDoc* pDoc=GetDocument ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (pDoC);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CString str;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">str.Format (_T 
(&quot;Cathy\tNorman\tOliver&quot;));</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">int nTabStop=20; //tabs are every 20 pixels</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;TabbedtextOut (10, 10, str, 1, 
&amp;nTabStop, 10);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip55"></a><b><font SIZE="+2"><font FACE="Times New Roman">55</font><font
FACE="黑体">、串太长时如何在其末尾显示一个省略号</font></font></b> </p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">CDC:: DrawText</font>并指定<font
FACE="Times New Roman">DT_END_ELLIPSIS</font>标志，这样就可以用小略号取代串末尾的字符使其适合于指定的边界矩形。如果要显示路径信息，指定<font
FACE="Times New Roman">DT_END_ELLIPSIS</font>标志并省略号取代串中间的字符。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CTestDoc* pDoc=GetDocument ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (pDoc);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Add ellpsis to end of string if it does not 
fit</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;Drawtext (CString (&quot;This is a long 
string&quot;),</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect (10, 10, 80, 30), DT_LEFT | 
DT_END_ELLIPSIS);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Add ellpsis to middle of string if it does not 
fit</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;DrawText (AfxgetApp () 
-&gt;m_pszhelpfilePath,</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect (10, 40, 200, 60), DT_LEFT | 
DT_PATH_ELLIPSIS);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip56"></a><b><font SIZE="+2"><font FACE="Times New Roman">56</font><font
FACE="黑体">、如何快速地格式化一个</font><font FACE="Times New Roman">CString</font><font
FACE="黑体">对象</font></font></b> </p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">CString:: Format</font>，该函数和<font
FACE="Times New Roman">printf</font>函数具有相同的参数，下例说明了如何使用<font
FACE="Times New Roman">Format</font>函数：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Get size of window.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect rcWindow;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetWindowRect (rcWindow);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Format message string.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CString strMessage;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">strMessage.Format (_T (&quot;Window Size (%d, 
%d)&quot;),</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">rcWindow.Width (), rcWindow.Height ());</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Display the message.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">MessageBox (strmessage);</font> </p>
</body>
</html>
