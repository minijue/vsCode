<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>Visual C++编程技巧十</title>
</head>

<body style="font-size: 9pt" background="../../res/back.JPG">

<p align="center"><strong><font face="Arial" size="4">Visual C++</font><font size="4">编程技巧第十期</font></strong></p>

<p align="center">转载于<font face="Arial">&quot;</font>玉海园<font face="Arial">&quot;</font>网站</p>

<p><strong>一.在树形控件坐标的捕获</strong><br>
问：我想捕获右键单击时的坐标，但遇上了问题。(为的是单击右键时显示<br>
一个快捷菜单.<br>
我在对话框里使用了一个树形控件,对事件NM_RCLICK进行处理,其声明是这样的:<br>
void CTreeDlg::OnRClickTree1(NMHDR* pNMHDR, LRESULT* pResult)<br>
问题是无论是参数pNMHDR还是pResult 都不包含坐标,原先以为第二个参数会包含<br>
坐标值,但失败了,我试过测试单击事件,但没有什么帮助.<br>
<br>
答:<br>
1)使用GetMessagePos得到本次事件中光标的位置,下面一段代码是我处理树形视中的<br>
的双击,你可以照此参考一下.<br>
void CMyTreeView::OnDblclk(NMHDR* /*pNMHDR*/, LRESULT* pResult)<br>
{<br>
// A double-click only counts if the mouse was clicked on<br>
// the item (e.g. the label, the icon, or a state icon, if it exists)<br>
CPoint pt(::GetMessagePos());<br>
ScreenToClient(&amp;pt);<br>
UINT ClickLocation;<br>
HTREEITEM hItem = GetTreeCtrl().HitTest(pt, &amp;ClickLocation);<br>
if ((hItem != NULL) &amp;&amp; (ClickLocation &amp; TVHT_ONITEM))<br>
{<br>
// ... do something with double-clicked item at hItem.<br>
}<br>
*pResult = 0;<br>
}<br>
2)这是我做的,希望能解决你的问题.<br>
Here's what I do, hope this solves your problem.<br>
<br>
void CTreeDlg::OnRClickTree(NMHDR* pNMHDR, LRESULT* pResult) )<br>
// created by classwizard<br>
{<br>
TreeViewPopup(); // common function also used by<br>
application button on keyboard<br>
<br>
*pResult = 0;<br>
}<br>
<br>
void CTreeDlg::OnRButtonDown(UINT nFlags, CPoint point) //<br>
created by classwizard<br>
{<br>
// The OnContextMenu event doesn't work for mouse clicks<br>
on treeviews,<br>
// so trap the right button down, convert the mouse<br>
position<br>
// from client to screen coordinates and bring up the<br>
menu<br>
// on a right click. The right click gets called after<br>
the<br>
// right button down message.<br>
<br>
m_cLastRClickPoint = point; // store this point in a<br>
CPoint member variable<br>
ClientToScreen(&amp;m_cLastRClickPoint);<br>
<br>
CTreeView::OnRButtonDown(nFlags, point);<br>
}<br>
<br>
void CTreeDlg::OnContextMenu(CWnd* pWnd, CPoint point) //<br>
created by classwizard<br>
{<br>
CPoint origin(-1,-1);<br>
<br>
if (point==origin) // Pop up activated through keyboard<br>
{ //<br>
Shift-F10 or &quot;Application&quot; key<br>
CPoint Ppoint;<br>
if (GetCursorPos(&amp;Ppoint))<br>
{<br>
m_cLastRClickPoint = Ppoint;<br>
// Do NOT convert these co-ordinates<br>
this time<br>
TreeViewPopup();<br>
}<br>
}<br>
}<br>
<br>
void CTreeDlg::TreeViewPopup() // created manually<br>
{<br>
CChildFrame* pChild = GetChildFrame(); // route messages<br>
to the app's CChildFrame class<br>
// write your own function to get this window<br>
if (pChild == NULL) return;<br>
<br>
CMenu PopUpMenu;<br>
PopUpMenu.LoadMenu(IDR_YOUR_TREEVIEW_POPUP_MENU);<br>
PopUpMenu.GetSubMenu(0)-&gt;TrackPopupMenu(TPM_LEFTALIGN |<br>
TPM_RIGHTBUTTON,<br>
<br>
m_cLastRClickPoint.x,<br>
<br>
m_cLastRClickPoint.y,<br>
<br>
GetChildFrame());<br>
}<br>
<br>
<br>
<br>
<strong>二.只读CEdit的前/背景色</strong><br>
问:在我的程序中有一个编辑控件,我想让它为黑背景白文本.<br>
我在对话框的OnCtlColor作改动时,如果此编辑控件非只读则可以实现我的想法,<br>
那么在只读情况下我该怎么办?<br>
<br>
答:<br>
当编辑控件为只读,OnCtlColor()调用时,参数nCtlColor须设置为CTLCOLOR_STATIC<br>
而不是CTLCOLOR_EDIT.<br>
<br>
<br>
<br>
<strong>三.怎样将消息发送给多个用户?</strong><br>
问:我有一个server/client程序,我想给所有的客户程序发送一个消息,目前我是通过使用<br>
CAsyncSocket Send()来发送,我想问可不可以对局域网中的所有的IP地址完成相同的事情?<br>
<br>
答:<br>
1)你可以使用广播或多点传送,但这与你的网络紧密相关,不能保证能全部正常运行.一<br>
个较好的办法是将你的客户机登录到你的服务器,然后给服务器一个消息,告诉服务器<br>
该向哪儿发送消息.我们在一个UDP socket实现此过程,传递给服务器那个端口在诊听.<br>
甚至我们在internet上也实现得很好,服务器使用SendTo方法发送消息给服务器,这种<br>
方法在TCP/IP工作方式下运行很好.如果你想支持多协议,那你就需要看一些像NetBIOS 
API<br>
等,对此我没有编过程序,但我相信它们也能工作.<br>
2)如果你的平台是NU,你能通过NetMessageBufferSend函数来对相同的domain域之下的用户<br>
发送消息.如果是98或95,你可以改变IP,根据IP的掩码来广播.<br>
<br>
<br>
<strong>四.MFC扩展DLL</strong><br>
问：我使用了一个MFC扩展DLL，现在我碰上了下面这个问题:<br>
在DLL中，我用AFX_EXT_CLASS导出(export)类A<br>
class AFX_EXT_CLASS B<br>
{<br>
public:<br>
SomeBFunction();<br>
AnotherBFunction();<br>
};<br>
<br>
class AFX_EXT_CLASS A : public B<br>
{<br>
public:<br>
SomeAFunction();<br>
AnotherAFunction();<br>
};<br>
在我的程序里,只有类A的函数被导出,则类B却没有,为什么?<br>
<br>
答:你应该为类B中的方法一个一个的导出如:<br>
class B<br>
{<br>
public:<br>
AFX_EXT_CLASS SomeBFunction();<br>
AFX_EXT_CLASS AnotherBFunction();<br>
};<br>
现在类B的方法已经被导出,接下来就可以从类B中继承出类A了<br>
class AFX_EXT_CLASS A : public B<br>
{<br>
public:<br>
SomeAFunction();<br>
AnotherAFunction();<br>
};<br>
<br>
<br>
<br>
<strong>五.不能使用Invalidate</strong><br>
问：我有一个CEdit的继承类，我想当鼠标第一次移到上面时修改该编程控件的类型，<br>
但修改后并没有使屏幕更新，为什么？我使用的是下面代码：<br>
void CMyEdit::OnMouseMove(UINT nFlags, CPoint point)<br>
{<br>
int offset=8;<br>
RECT rect;<br>
this-&gt;GetClientRect(&amp;rect); // area of the edit box<br>
<br>
this-&gt;SetModify(FALSE);<br>
<br>
// if mouse is well inside the edit box then display the border else no<br>
border<br>
if(rect.left+offset &lt; point.x &amp;&amp;<br>
rect.right-offset &gt; point.x &amp;&amp;<br>
rect.bottom-offset &gt; point.y &amp;&amp;<br>
rect.top+offset &lt; point.y)<br>
{<br>
TRACE1(&quot;%d&quot;, this-&gt;ModifyStyle(WS_BORDER,0));<br>
}<br>
else<br>
TRACE1(&quot;%d&quot;, this-&gt;ModifyStyle(0,WS_BORDER));<br>
<br>
this-&gt;SetModify(TRUE);<br>
this-&gt;Invalidate(TRUE);<br>
<br>
CEdit::OnMouseMove(nFlags, point);<br>
}<br>
<br>
答：<br>
1)试一下：<br>
this-&gt;ModifyStyle(WS_BORDER, 0, SWP_DRAWFRAME);<br>
this-&gt;ModifyStyle(0, WS_BORDER, SWP_DRAWFRAME);<br>
2)这里面有四件事情你应该了解，第一，Invalidate只能使客户区及非客户区的边框<br>
无效，你应该在这里自己加入重画代码，使用RedrawWindow。第二，不要太相信<br>
TRACE调用的结果，因为他们将在发行版本(release)中被移去，在发行版本中，Modifystyle<br>
将得不到调用。第三，你不需要用'this'指针来处理成员函数及成员变量，你只需要<br>
简单地使用Invalidate(TRUE)就可以了。第四，你建立的平面编辑控件总是不能工作是<br>
因为当你从窗体中加入/移去控件进将控件中的文本移动了几个像素，你可以在资源编辑<br>
器中得到验证。<br>
<br>
<br>
<br>
<strong>六.用GetDlgItem()取得的指针DYNAMIC_DOWNCAST出错</strong><br>
我用资源编辑器建立了一个图象CheckBox，我想让它在一个属性页里面有三个状态，<br>
得到对话框控件，并试一下DYNAMIC_DOWNCAST，代码如下<br>
CWnd* pWnd = GetDlgItem(nControlID);<br>
CButton* pButton = DYNAMIC_DOWNCAST(CButton, pWnd)<br>
问题是DYNAMIC_DOWNCAST总是返回NULL。<br>
答：<br>
1)MFC不对你用GetDlgItem取得的类型类型作任何的检查，只是看上去你得到了一个<br>
CWnd继承类的映射。如果你想处理一个CButton，试一下：<br>
CButton btn;<br>
HWND hwnd ::GetDlgItem(GetsafeHwnd(), nControlID);<br>
if (hwnd != NULL)<br>
{<br>
btn.Attach(hwnd);<br>
btn.SetButtonStyle(BS_AUTO3STATE, FALSE);<br>
btn.Detach();<br>
}<br>
2)是否只有这种方法才可以工作？当你调用<br>
CWnd* pWnd = GetDlgItem(nControlID);<br>
你生成了一个临时CWnd对象，并加到MFC的临时映象中，而它的运行时的类型是CTmpWnd<br>
而函数GetDlgItem中是简单的包装了一下SDK函数，它返回的值是HWND。没有方法得到<br>
窗口的类，或者是返回窗口的类型。<br>
<br>
<br>
<strong>七.CDatabase会建立13个线程?</strong><br>
问:谁能告诉我当运行CDatabase.Open时为什么会产生13个线程?<br>
<br>
答:<br>
1)那是因为Sybase设备驱动程序建立的.<br>
2)CDatabase不会建立任何线程,它经过ODBC联接打开一个数据库,这里需要调用ODBC<br>
设备驱动程序,而这些驱动程序可能也会建立一些线程,如果你有一个设备驱动建立了<br>
这么多的线程的话,我建议你应该从你的设备产品服务商取得支持<br>
<br>
<br>
<strong>八.怎样使工具条上的按钮显示为按下的状态?</strong><br>
问:我有一个工具条,上面有几个按钮.我使用标准的CToolBar类来处理这些,当我点击<br>
其中的一个按钮时,我希望它呈按下的状态,直到我再次点击这个按钮.<br>
<br>
答:<br>
1)有好几个方法可以实现,其中一个容易的方法是为该按钮使用CommandUI消息句柄,<br>
调用CCmdUI的SetCheck成员函数来设置该按钮的状态.你可以使用一个布尔变量来指<br>
出该按钮的状态以借命令句柄中使用.<br>
2)我猜想你使用了ClassWizard来为工具条按钮写一个命令句柄,那么在该命令处理中使用:<br>
pCmdUI-&gt;SetCheck (bShowButtonPushed);<br>
许多MFC介绍书籍中都包含了这个技巧,虽然通常它都包含在菜单命令中,只需要很少的<br>
注意,就可以应用到工具条按钮上了.<br>
</p>
</body>
</html>
