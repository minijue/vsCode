<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title></title>
</head>

<body>

<table border="0" cellspacing="2" cellpadding="0" width="100%" style="font-size: 9pt">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是： <b><a href="Vc_idx.htm">Visual 
    C++/C++</a> &gt;</b> </span><font color="#000000">MFC邮递表的中文翻译-第三十期</font></td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%" bgcolor="#E8E8E8">
      <tr>
        <td width="100%">　</td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><p align="center"><font color="#000000"><strong>MFC邮递表的中文翻译-第三十期</strong></font></td>
  </tr>
  <tr>
    <td width="100%">　</td>
  </tr>
  <tr>
    <td width="100%">　<p><font color="#FF0000">第三十期目录</font> <font size="2">杨晓东 
    1999.3.21</font><ol>
      <li><a href="#volq1">改变工具提示框的宽度</a> </li>
      <li><a href="#volq2">背景标记</a> </li>
      <li><a href="#volq3">关于CString::GetLength()</a> </li>
      <li><a href="#volq4">MRU(最近使用的)文件</a> </li>
      <li><a href="#volq5">静态成员</a> </li>
      <li><a href="#volq6">虚拟(virtual)列表控件</a> </li>
      <li><a href="#volq7">关于检查列表框(CCheckListBox)</a> </li>
      <li><a href="#volq8">向导生成器的上下文敏感帮助</a> </li>
    </ol>
    <p><a name="volq1"></a></p>
    <font color="Red"><h3>改变工具提示框的宽度</h3>
    </font><p>问:我的工具提示内容很长,当工具提示框显示时并不能完全显示出来,我知道可以通过 
    SetTipMaxWidth函数来设置工具提示的宽度,但是</p>
    <p>要使用该函数需要取得指向工具条的 指针,怎样才能得到它?<br>
    </p>
    <p>答:试一下设置TOOLINFO结构中的uFlags为TTF_TRANSPARENT,然后根据你所要显示的 
    文本的长度来设置显示的位置就可以了,具体如下: </p>
    <pre>    TOOLINFO ti;
    ... // Other ti info
    ti.uFlags = TTF_TRANSPARENT;
    ... // rest of the structure field</pre>
    <p>接着发送下列消息: </p>
    <pre>
    m_wndToolTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM)&amp;ti);
    m_wndToolTip.SendMessage(TTM_TRACKPOSITION, 0, (LPARAM) (DWORD)MAKELONG(point.x, point.y));
    m_wndToolTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM)&amp;ti);
</pre>
    <p>其中point是CPoint类型,用来指出显示工具提示的具体位置.提示文本将会从该点位置 
    起显示,实际值是根据文本的长度来计算.希望这些</p>
    <p>能有用.<br>
    </p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;2)另外一个方法 </p>
    <pre>BOOL CXXX::OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
 TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pNMHDR;
// UINT nID =pNMHDR-&gt;idFrom;
 CPoint pt= GetCurrentMessage()-&gt;pt; // screen coords
 pTTT-&gt;hinst= 0;
 bool bForThisWindow= ToolTipContents(pt);
 // fills in m_szToolTip, returns if for this window
 if (bForThisWindow)
 {
  HWND hTool= pTTT-&gt;hdr.hwndFrom;
  if (hTool)
  {
   ::SendMessage(hTool, TTM_SETMAXTIPWIDTH, 0, SHRT_MAX); //line breaker
   ::SetWindowLong(hTool, GWL_STYLE,
    ::GetWindowLong(hTool, GWL_STYLE)|TTS_NOPREFIX);
  }
 }
 pTTT-&gt;lpszText= m_szToolTip;
 return(bForThisWindow);
}</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq2"></a> </p>
    <font color="Red"><h3>背景标记</h3>
    </font><p>问:如何在背景中显示一个图标.</p>
    <p><br>
    答:你可能已经发现改写OnEraseBkgn()(对应消息WM_ERASEBKGND)可以满足你的要求. 
    通过使用该方法可以实现由CView继承类的自定义背</p>
    <p>景显示.我通常是用它改变颜色, 但我相信你也可以实现位图的显示.至于改变背景颜色,只需设置一个静态标志用下面 
    的代码就可以实现. </p>
    <pre>BOOL CMyView::OnEraseBkgnd(CDC* pDC)
{
    CRect   cClientRect;

    // Get client area.

    GetClientRect( cClientRect );

    if( m_bFlag )
    {
	// Set background to dark green.
	pDC-&gt;FillSolidRect( cClientRect, RGB( 0, 128, 0 ) );
    }
    else
    {
	// Set background to dark red.
	pDC-&gt;FillSolidRect( cClientRect, RGB( 128, 0, 0 ) );
    }

    // Prevent Windows from drawing over our background.
    return( TRUE );
//  return CScrollView::OnEraseBkgnd(pDC);

} /* end CMyView::OnEraseBkgnd */</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq3"></a> </p>
    <font color="Red"><h3>关于CString::GetLength()</h3>
    </font><p>问:VC5.0版本帮助文件中指出CString::GetLength()将返回字符串所占字节的数目 
    对于ASCII,这个描述是正确的,但如果是Unicode则实际</p>
    <p>上返回的是字符数而不是字 节数,我现在想知道怎样才能知道一个字符串的字节长度,不管是ASCII还是Unicode.<br>
    </p>
    <p>答:我发现CSting的说明确实如你所说的有些小问题.CSting中的GetData()方法是保护 
    的,所以如果你继承CString类时碰上问题时,你必须</p>
    <p>自己处理nDataLength,虽然我不太 清楚nDatalength是不是你想要的.从MFC例子中我们能看到下列代码. 
    </p>
    <pre>Void CString::AllocBuffer(int nLen)
{
    if (nLen == 0)
	Init();
    else {
	CStringData* pData = (CStringData*) new
BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
	pData-&gt;nRefs=1;
	pData-&gt;data() [nLen] = '\0';
	pData-&gt;nDataLength = nLen;  //nLen is assigned to
nDataLength
	pData-&gt;nAllocLength = nLen;
	m_pchData = pData-&gt;data();
    }
}</pre>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;对我来说,好象nDatalength仍然是字符数,而不是字节,如果sizeof(TCHAR)返回的值 
    是可用的话,可能你要自己计算.<br>
    &nbsp;&nbsp;&nbsp;&nbsp;加入代码的中,m_pchData是保护,而不是私有的.也许你能找出字符串结束符然后自己 
    计算字符串的字节数.<br>
    &nbsp;&nbsp;&nbsp;&nbsp;2)我通常使用下面代码来取得字符串的字节数 </p>
    <pre>int nBytes = (csSomeCString.GetLength() + 1) * sizeof(TCHAR);</pre>
    <p>注意:这字节数的长度还包括文件结束符.<br>
    </p>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq4"></a> </p>
    <font color="Red"><h3>MRU(最近使用的)文件</h3>
    </font><p>问:我想将最近使用过的几个文件名(以及路径)显示出来,该怎么办?<br>
    </p>
    <p>答:一个由向导生成器生成的文档视图结图已经包含MRU列表操作.具体是放在注册表的 
    HKEY_CURRENT_USER/Software/Your Company Name/</p>
    <p>Your App Name/Recent File List/File1, File2, File3, etc.<br>
    &nbsp;&nbsp;&nbsp;&nbsp;你所要做的是用程序中的GetProfileString()读入第一个MRU文件的位置,剩下的由 
    CRecentFileList::ReadList()完成所有的工</p>
    <p>作.CRecentFileList类包含了所有操作 的代码象分析路径,管理MRU文件等,用不着为此费心.<br>
    </p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;2)在AFXWIN.H中定义了一个变量CRecentFileList* 
    m_pRecentFileList; 你可以通过使用CRecentFileList的成员变量m_arrNames[n]来</p>
    <p>取得某个MRU文件.比如: </p>
    <pre>#include <afxadv.h>                 // needed for access to MRU list

CFile mruFile;
if ( !mruFile.Open( m_pRecentFileList-&gt;m_arrNames[index],
                         CFile::modeRead )
....</pre>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;3)你不需要建立一个CRecentFileList类,它已经由CWinApp基类完成了.你只要保证你在 
    initinstance中调用LoadStdProfileSettings()</p>
    <p>函数就可以了. CRecentFileList类中有一个CWinApp保护成员变量(如m_pRecentFileList) 
    所以你应该在你的继承类中处理它.下面的代码</p>
    <p>在我这儿工作很正常 </p>
    <pre>void CMdiApp::OnFileMruFile1()
{
    // TODO: Add your command handler code here
    CString vl_name ;
            ASSERT( m_pRecentFileList-&gt;GetSize() &gt; 0);
    vl_name = (*m_pRecentFileList)[0];
    CWinApp::OnOpenRecentFile(ID_FILE_MRU_FILE1);
}</pre>
    <p>OnOpenRecentFile()函数必须要调用缺省处理,其它的就随便了<br>
    </p>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq5"></a> </p>
    <font color="Red"><h3>静态成员</h3>
    </font><p>问:我有个类中有一个静态CBitmap成员变量 </p>
    <pre>CMyClass {...static CBitmap m_MyLogo;...}</pre>
    <p>在CPP文件中我定义了一个全局变量 </p>
    <pre>CBitmap CMyClass::m_MyLogo;</pre>
    <p>怎样我才能在其生命周期中调用函数CBitmap::LoadBitmap(nID)就象是一个位图对象一样<br>
    </p>
    <p>答：这里有一个小小的例子来说明 </p>
    <pre>    //@ MyClass.h
    CMyClass
    {
    protected:
        static CBitmap&amp; GetMyStaticBitmap();
    };

    //@ MyClass.cpp
    CBitmap&amp;
    CMyClass::GetMyStaticBitmap()
        throw(CResourceException)
    {
        static CBitmap ts_rBitmap;
        if(NULL == ts_rBitmap.operator HBITMAP())
        {
            if(!rBitmap.LoadBitmap(IDB_MYBMP))
                AfxThrowResourceException();
        }

        return ts_rBitmap;
    }</pre>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;2)我认为你坚持保持变量m_MyLogo保护属性没有任何机会。唯一的方法就是（我认为）： 
    增加一个静态成员函数，由它返回一个指向位</p>
    <p>图对象的指针，就象这样： </p>
    <pre>CMyClass
{
    CMyClass();
protected:
    static CBitmap m_MyLogo;
public:
    static CBitmap *GetMyLogo() {return m_MyLogo;};
}</pre>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;如果决定将m_MyLogo公用，那么就不需要该函数，先前的一行就应变成 
    </p>
    <pre>CMyClass::m_MyLogo.LoadBitmap(nID);</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq6"></a> </p>
    <font color="Red"><h3>虚拟(virtual)列表控件</h3>
    </font><p>问:我想从一个虚拟列表控件中取得一个项目,我不能在V5或V6中实现,但列表控件若是可见的, 
    则程序一切正常.<br>
    </p>
    <p>答:在带有LVS_OWNERDATA类型列表控件中我也碰上过同样的问题,下面是我对继承的类的 
    SetItemState函数的修改. </p>
    <pre>BOOL CListCtrlEx::SetItemState(int nItem, UINT nState, UINT nStateMask)
{
 LV_ITEM tmpItem;
 tmpItem.mask = LVIF_STATE;
 tmpItem.iItem = nItem;
 tmpItem.iSubItem = 0;
 tmpItem.stateMask = nStateMask;
 tmpItem.state = nState;
 tmpItem.pszText = NULL;
 tmpItem.iImage = 0;
 tmpItem.lParam = 0;
 return (BOOL)(SendMessage(LVM_SETITEMSTATE, nItem, (LPARAM)(&amp;tmpItem)));
}</pre>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;问题的原因似乎是消息LVM_SETITEM不能被带有LVS_OWNERDATA类型列表控件所 
    处理,(在MFC中CListCtrl::SetItemState是使用LVM_SETI</p>
    <p>TEM消息的)<br>
    </p>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq7"></a> </p>
    <font color="Red"><h3>关于检查列表框(CCheckListBox)</h3>
    </font><p>问:使用CCheckListBox时是不是不能调用DeleteString()?<br>
    </p>
    <p>答:我记得是这样的,我从继承类中修改了它,现在它工作很正常.<br>
    CPP 文件: </p>
    <pre>void CMyCheckListBox::PreDrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    if((int)lpDIS-&gt;itemID <0 || (long)lpDIS->itemData <0) return; CCheckListBox::PreDrawItem(lpDIS); } BOOL CMyCheckListBox::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult) { switch (message) { case WM_DRAWITEM: ASSERT(pResult="=" NULL); // no return value expected PreDrawItem((LPDRAWITEMSTRUCT)lParam); break; default: return CCheckListBox::OnChildNotify(message, wParam, lParam, pResult); } return TRUE; }</pre>

头文件
</pre>
    <pre>protected:
    void PreDrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
                                LRESULT* pResult);</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq8"></a> </p>
    <font color="Red"><h3>向导生成器的上下文敏感帮助</h3>
    </font><pre>问:如何在向导生成器中加入上下文帮助以及关闭按钮,这好象不是缺省值.
</pre>
    <p>答:你需要处理WS_SYSMENU类型 </p>
    <pre>BOOL CYourPropertySheet::OnInitDialog()
{
    if (CPropertySheet::OnInitDialog())
    {
        ModifyStyle(0, WS_SYSMENU, 0);
        ModifyStyleEx(0, WS_EX_CONTEXTHELP, 0);

        // The default system menu has several menu items that don't make
        // sense for a wizard. Remove them.
        CMenu* pSystemMenu = GetSystemMenu(FALSE);
        if (pSystemMenu != NULL)
        {
            // Remove some items
            pSystemMenu-&gt;DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
            pSystemMenu-&gt;DeleteMenu(SC_SIZE, MF_BYCOMMAND);
            pSystemMenu-&gt;DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
            pSystemMenu-&gt;DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);

            // Do not remove/hide SC_CLOSE, or the '?' icon won't be
            // drawn properly
        }
        // ... other initialization, like maybe Q143210
        return TRUE;
    }
    else
        return FALSE;
}</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <hr>
    <a href="cmfcv31.htm"><div align="center"><center><pre>前一期</a>|<a href="cmfcv29.htm">后一期</a>

<a
href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供!</pre>
    </center></div></td>
  </tr>
</table>

<p><a name="PageBegin"></a><br>
<br>
</p>
</body>
</html>
