<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://person.zj.cninfo.net/~yao/document/vc/vc006.htm -->
<HTML><HEAD><TITLE>用DirectDraw编写动画程序</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<STYLE>P {
	FONT-FAMILY: 宋体; FONT-SIZE: 10.5pt
}
</STYLE>

<META content="Microsoft FrontPage 4.0" name=GENERATOR></HEAD>
<BODY>
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../../progidx.htm">编程技巧</a> --&gt; 
      <a href="../Vcidx098.htm">Visual C++</a></b></span></td>    
  </tr>    
</table>    
</center></div><div align="center"><center>    
    
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"    
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">    
  <tr>    
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"    
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"    
    bordercolordark="#FFFFFF">    
      <tr>    
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font    
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"    
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>    
      </tr>    
    </table>    
      <P align=center><STRONG>用DirectDraw编写动画程序 <BR><BR>(成都　张巍)</STRONG></P>
      <P>　　一.理论篇<BR>　　说起DirectDraw也许大多数人还不知其为何物，但一提到DirectX恐怕每一个<BR>Computer Fan  
      和Game Fan都再耳熟不过了。(什么！你没听说过DirectX!?Oh,My  
      god!<BR>来人哪，拉下去重责五十大板!)DirectX又叫Game  
      SDK，它最大的特点是直接对硬<BR>件的抽象层(HAL)进行操作，利用这个特点可以制作出高性能的Windows游戏。具<BR>体信息请见http://www.  
      microsoft.com/directx/default.asp。<BR>　　DirectDraw就是DirectX5的6个组件之一。DirectX5的其它5个组件分别是：<BR>　　Direct3D：提供了3D硬件接口。<BR>　　DirectSound：立体声和3D声音效果，同时管理声卡的内存。<BR>　　DirectPlay：支持开发多人网络游戏，并能处理游戏中网络之间的通信问题。<BR>　　DirectInput：为大量的设备提供输入支持。<BR>　　DirectSetup：自动安装DirectX驱动程序。<BR>　　而DirectDraw则是DirectX的基石，DirectX的其它组件都是建立在它的基础<BR>之上的。DirectDraw使用页面切换的方法实现动画，它不仅可以访问系统内存，<BR>还可以访问显示内存，这是以往的Windows程序员所不能的。另外，我们利用<BR>DirectDraw还可以生成、移动、剪切、转换、合成图像数据，从而编写出各种<BR>“炫丽多彩”图形的应用程序。<BR>　　介绍了这么一大堆DirectX的理论，你的头是不是已经有些大了呢？心中一<BR>定在嘀咕：“哼，原来是个江湖骗子，光说不练。”各位看官不要着急，不把这<BR>些基础理论搞懂就去看下面的程序，你肯定是“洋鬼子看戏――目瞪口呆”。<BR>　　首先，让我们先了解一下DirectDraw的三个重要概念。<BR>　　1.表面<BR>　　在用DirectDraw编写程序时,我们先要创建若干个图形数据缓冲区，并把这些<BR>图形数据装入其中，再进行转换、拉伸、挎贝等操作，并且还可以显示这些缓冲<BR>区中的图形数据，这些缓冲区就称为表面。<BR>　　表面可以分为几类。<BR>　　主表面(primary  
      surface)是用户在屏幕上可以看到的，它是显示内存的一部<BR>分。所有DirectDraw程序都有主表面，而且只有一个。它在DirectDraw表面对象<BR>之前就已经存在了，因此不能改变它的尺寸、格式和位置。主表面有一个很重要<BR>的特性――翻转。页面翻转用于程序中，可以产生相当平滑、不闪烁的动画。一<BR>个可以翻转的主表面实际上是两个表面，一个是可见的，一个是不可见的。不可<BR>见的表面称为后备缓冲区。当发生表面翻转时，后备缓冲区就成为可见的，而以<BR>前的可见表面则成为后备缓冲区。<BR>　　还有一种表面叫离屏表面(off_screen  
      surface)，它是不能直接见到的。离<BR>屏表面作为存储缓冲区，有助于表面之间的互相切换，它的大小是可以改变的。<BR>　　主表面和离屏表面都分为有调色板的和无调色板的这两类。像素深度为8位<BR>(256色)的表面称为有调色板的表面；而像素深度为16位(64K色)、24位(16M色)的<BR>像素表面称为无调色板的表面，它们存储实际的色彩值(RGB值)。在本文下面的程<BR>序中，我们使用24位表面即无调色板的表面。<BR>　　2.  
      Bltting<BR>　　Bltting是用于复制图形的语言，可以将图像从一处拷贝到另一处。例如大家<BR>所熟悉的CDC类(设备描述表类)的BitBlt()就是具有这样功能的函数。在DirectDraw<BR>中，典型的blt操作是将离屏表面的内容拷贝到一个后备缓冲区，而一般的blt操<BR>作调用一个源表面和一个目标表面，把源表面的内容拷贝到目标表面中，不仅可<BR>以整体拷贝源表面，而且还可以拷贝源表面内的任何矩形区域到目标表面的任何<BR>位置。blt还支持透明拷贝，就是指表面中的某一像素在blt过程中可以不予以拷<BR>贝，而这个像素值是由色彩键码(DDCOLOR  
      KEY  
      )决定的。<BR>　　DirectDraw中有三个支持blt的函数，它们是Blt()、BltBatch()、BltFast()。<BR>Blt(  
      )用得最多，BltFast()的速度比Blt()要快，但功能却很有限，例如不支持<BR>拉伸、剪切等操作。<BR>　　还有一个函数BltSurface()，它是DirectWin类的一个成员函数，Blt()、<BR>BltFast()更具有适应性，并且使用起来更加简单。例如，当我们把源表面拷贝到<BR>目标表面外时需要裁剪，而BltFast()不支持裁剪。这时我们使用BltSurface()函<BR>数，它在内部使用Blt()和  
      BltSurface()函数，并根据情况自动执行裁剪。<BR>　　3.色彩键码<BR>　　DirectDraw  
      可以把某种颜色或某个范围的颜色指定为一个颜色值，这个颜色<BR>值是由DDCOLORKEY结构即色彩键码说明的，DDCORLORKEY结构说明如下：<BR>　　typedef  
      struct _DDCOLORKEY{ <BR>　　DWORD dwColorSpaceLowValue; //颜色范围的低端<BR>　　DWORD  
      dwColorSpaceHighValue; //颜色范围的高端<BR>　　}  
      DDCOLORKEY;<BR>　　当我们对表面进行拷贝操作时,表面中哪些像素不被拷贝是由色彩键码决定的。<BR>例如当DDCOLORKEY结构的两个分量都为零时，表面内所有置为零的像素都不能被<BR>拷贝。又例如，当表面是24位RGB模式时，若想指定RGB=(120，120，120)像素不<BR>被拷贝，则应该:<BR>　　DDCOLORKEY  
      ddck;<BR>　　ddck.dwColorSpaceLowValue=RGB(120,120,120);<BR>　　ddck.dwColorSpaceHighValue=RGB(120,120,120);<BR>　　surf→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　其中SetColorKey()函数是把色彩键码赋给表面surf。这样，在对表面surf的<BR>blt操作期间RGB值为(120,120,120)的像素不能被拷贝。<BR>　　二．实践篇<BR>　　古语云：“君欲善其事，必先利其器”，在编写DirectDraw应用程序之前，<BR>我们先要准备好以下工具：<BR>　　Windows95、Windows98或WindowsNT4.0<BR>　　DirectX  
      驱动程序(最好是DirectX3.0以上版本)<BR>　　DirectX SDK<BR>　　Visual C＋＋ 5.0<BR>　　Direct  
      SDK包括开发基于DirectX应用程序所需的全部文件，全部安装需要80<BR>几兆的硬盘空间。其实你只需安装必需的头文文件（.h文件）和库文件（.lib文件）<BR>就行了。<BR>　　安装完DirectX  
      SDK，需要通知Visual C＋＋ DirectX  
      SDK的路径。具体做法是：<BR>在VC的编译环境中，依次把Tools－Options－Directories中的Show Directories  
      for<BR>一栏中的include files和library  
      files中分别填入SDK的inc和lib目录。<BR>　　再准备两幅bmp格式的位图，要求24位（16M色），其中background.bmp作背景，<BR>另一幅bird.bmp作为子画面，如图3。bird.bmp是由4幅小画面组成的，从左到右，<BR>从上到下，分别为动画的1至4帧。这样做的目的是避免过多位图文件带来的不必要<BR>的麻烦。还要注意一点的是子画面的背景要为黑色(RGB=(0,0,0))，因为在下面的<BR>程序中，色彩键码把黑色设为透明色。<BR>　　好，一切准备就绪，让我们开始吧!<BR>　　进入VC5的编程环境，File－New－Project,选择DirectDraw  
      AppWizard,输入<BR>项目名Fly,按下Ok,以后每一步都按其缺省值即可，这样AppWizard就会自动创建<BR>一个项目Fly，属性如下：<BR>　　APPLICATION  
      STYLE<BR>　　 Full－Screen<BR>　　SETTINGS<BR>　　 640x480<BR>　　  
      16－bit<BR>　　CLASS NAMES<BR>　　 FlyApp<BR>　　 FlyWin<BR>　　CONTENT<BR>　　  
      Bitmap<BR>　　这时，按“Ctrl＋F5”编译运行，你就会看到一个“三角形”在屏幕上撞来撞去。<BR>　　在FlyWin.h中添加代码，如下所示：<BR>　　＃ifndef  
      FLYWIN_H<BR>　　＃define FLYWIN_H<BR>　　＃include  
      “DirectDrawWin.h”<BR>　　<BR>　　class FlyWin : public  
      DirectDrawWin<BR>　　{<BR>　　public:<BR>　　 FlyWin();<BR>　　protected:<BR>　　  
      //{{AFX_MSG(FlyWin)<BR>　　 afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt,  
      UINT nFlags);<BR>　　 afx_msg int OnCreate(LPCREATESTRUCT  
      lpCreateStruct);<BR>　　 afx_msg void OnTimer(UINT nIDEvent);<BR>　　 afx_msg  
      void OnDestroy();<BR>　　 //}}AFX_MSG<BR>　　  
      DECLARE_MESSAGE_MAP()<BR>　　private:<BR>　　 int SelectDriver();<BR>　　 int  
      SelectInitialDisplayMode();<BR>　　 BOOL CreateCustomSurfaces();<BR>　　 void  
      DrawScene();<BR>　　 void RestoreSurfaces();<BR>　　private: <BR>　　 void  
      CopySurface(LPDIRECTDRAWSURFACE ts,<BR>　　 LPDIRECTDRAWSURFACE ss,<BR>　　int  
      x,int y);<BR>　　 void SplitSurface(LPDIRECTDRAWSURFACE ts,<BR>　　  
      LPDIRECTDRAWSURFACE ss,<BR>　　 CRect＆ srcc,<BR>　　 int x,int  
      y);<BR>　　private:<BR>　　 LPDIRECTDRAWSURFACE bksurf,  
      //定义指向背景画面表面的指针<BR>　　flysurf,  
      //指向总子画面表面的指针<BR>　　storesurf,//指向存储背景区域表面的指针<BR>　　flysurf1,  
      //指向第一帧子画面表面的指针<BR>　　flysurf2, //指向第二帧子画面表面的指针<BR>　　flysurf3,  
      //指向第三帧子画面表面的指针<BR>　　flysurf4, //指向第四帧子画面表面的指针<BR>　　cursurf;  
      //指向当前移动的子画面表面的指针<BR>　　//背景画面指background.bmp;总子画面指bird.bmp<BR>　　<BR>　　int  
      x,y,nPreX,nPreY;//定义子画面移动的坐标<BR>　　int nIncX,nIncY;// 定义子画面移动的像素数<BR>　　 int  
      nCount; //定义计数器<BR>　　 DWORD fw,fh;  
      //定义总子画面的宽和高<BR>　　};<BR>　　＃endif<BR>　　其中，CopySurface()函数起保存被子画面覆盖掉的背景区域的作用。参数ts<BR>是指向目标表面的指针，ss是指向源表面的指针，x、y是源表面上需要拷贝的矩<BR>形区域左上角的坐标。<BR>　　SplitSurface()函数用于分离一个大的总子画面表面为4帧小子画面表面。参<BR>数ts是指向目标表面的指针，ss是指向源表面的指针，srcc是源表面上需要选取<BR>的矩形区域，x、y要拷贝到目标表面上的左上角坐标。<BR>　　其实当我们看了下面FlyWin.cpp中这两个函数的原型后，细心的朋友也许会<BR>发现，两个函数完全可以写成一个函数。而本文特意写成两个函数，为的是程序<BR>的清楚易读，不易引起混淆。<BR>　　下一步在FlyWin.cpp中添加代码，如下所示：<BR>　　＃include  
      “Headers.h”<BR>　　＃include “resource.h”<BR>　　＃include  
      “DriverDialog.h”<BR>　　＃include “FlyWin.h”<BR>　　＃pragma comment  
      (lib,“ddraw.lib”)<BR>　　＃pragma comment (lib,“dxguid.lib”)<BR>　　<BR>　　const  
      DWORD desiredwidth=640;<BR>　　const DWORD desiredheight=480;<BR>　　const  
      DWORD desireddepth=16;<BR>　　<BR>　　const int nMoveSpeed=100;  
      //设置动画速度为100毫秒／帧<BR>　　const int nMoveIncX=8; //设置子画面沿X轴移动8个像素<BR>　　const  
      int nMoveIncY=8; //设置子画面沿y轴移动8个像素<BR>　　<BR>　　BEGIN_MESSAGE_MAP(FlyWin,  
      DirectDrawWin)<BR>　　 //{{AFX_MSG_MAP(FlyWin)<BR>　　 ON_WM_KEYDOWN()<BR>　　  
      ON_WM_CREATE()<BR>　　 ON_WM_TIMER()<BR>　　 ON_WM_DESTROY()<BR>　　  
      //}}AFX_MSG_MAP<BR>　　END_MESSAGE_MAP()<BR>　　<BR>　　FlyWin::FlyWin()<BR>　　{<BR>　　  
      x=nPreX=300; //子画面初始位置为(300,150)<BR>　　 y=nPreY=150;<BR>　　  
      nIncX=nMoveIncX;<BR>　　 nIncY=nMoveIncY;<BR>　　 nCount=1;<BR>　　//设置计数器 
      <BR>　　}<BR>　　BOOL FlyWin::CreateCustomSurfaces()<BR>　　{<BR>　　 // create  
      your surfaces here...<BR>　　 //创建背景表面，并由指针bksurf指向这个表面<BR>　　  
      bksurf=CreateSurface(“background.bmp”);<BR>　　  
      //创建一个总子画面(由4帧子画面组成)的表面<BR>　　 //由指针flysurf指向这个表面.<BR>　　  
      flysurf=CreateSurface(“bird.bmp”);<BR>　　<BR>　　  
      //得到总子画面表面的宽(fw),高(fh)<BR>　　GetSurfaceDimensions(flysurf,fw,fh);<BR>　　<BR>　　  
      //创建4帧宽为fw/2,高为fh/2的子画面的表面，分别由<BR>　　  
      //指针flysurf1,flysurf2,flysurf3,flysurf4指向它们。<BR>　　 //现在这4个子表面还是空的。<BR>　　  
      flysurf1=CreateSurface(fw/2,fh/2);<BR>　　  
      flysurf2=CreateSurface(fw/2,fh/2);<BR>　　  
      flysurf3=CreateSurface(fw/2,fh/2);<BR>　　  
      flysurf4=CreateSurface(fw/2,fh/2);<BR>　　<BR>　　  
      //清除4帧子画面表面的内容，使表面内所有像素为0，<BR>　　 //即表面是透明的。<BR>　　  
      ClearSurface(flysurf1,0);<BR>　　 ClearSurface(flysurf2,0);<BR>　　  
      ClearSurface(flysurf3,0);<BR>　　  
      ClearSurface(flysurf4,0);<BR>　　<BR>　　//定义色彩键码，指明黑色(RGB=(0,0,0))为透明色<BR>　　//即在blt操作期间不拷贝黑色像素。<BR>　　DDCOLORKEY  
      ddck;<BR>　　ddck.dwColorSpaceLowValue=0;<BR>　　ddck.dwColorSpaceHighValue=0;<BR>　　//将色彩键码赋给背景表面,总子画面表面和4个子画面表面<BR>　　bksurf→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　flysurf→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　flysurf1→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　flysurf2→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　flysurf3→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　flysurf4→SetColorKey(DDCKEY_SRCBLT,＆ddck);<BR>　　<BR>　　//定义总子画面表面上的4个矩形区域，即为4个子画面表面区域<BR>　　CRect  
      r1(0,0,fw/2－1,fh/2－1);<BR>　　<BR>　　CRect r2(fw/2,0,fw－1,fh/2－1);<BR>　　CRect  
      r3(0,fh/2,fw/2－1,fh－1);<BR>　　CRect  
      r4(fw/2,fh/2,fw－1,fh－1);<BR>　　//把总子画面表面上的4个矩形区域分别拷贝到4个子画面表面<BR>　　//即实现分离总子画面表面<BR>　　SplitSurface(flysurf1,flysurf,r1,0,0);<BR>　　SplitSurface(flysurf2,flysurf,r2,0,0);<BR>　　SplitSurface(flysurf3,flysurf,r3,0,0);<BR>　　SplitSurface(flysurf4,flysurf,r4,0,0);<BR>　　//创建一个存储表面,由指针storesurf指向它<BR>　　//用以存储子画面移动时所覆盖的背景区域<BR>　　storesurf=CreateSurface(fw/2,fh/2);<BR>　　CopySurface(storesurf,bksurf,x,y);<BR>　　<BR>　　//初始化当前子画面表面<BR>　　cursurf=flysurf1;<BR>　　return  
      TRUE;<BR>　　}<BR>　　void FlyWin::DrawScene()<BR>　　{<BR>　　  
      //绘制背景表面和第一帧子画面表面<BR>　　 //把背景表面拷贝到后备缓冲区<BR>　　  
      BltSurface(backsurf,bksurf,0,0,TRUE);<BR>　　 //把当前的子画面表面拷到后备缓冲区<BR>　　  
      BltSurface(backsurf,cursurf,x,y,TRUE); <BR>　　 //页面翻转,使后备缓冲区的内容可见<BR>　　  
      primsurf→Flip(0,DDFLIP_WAIT);<BR>　　<BR>　　 //再次把背景表面拷贝到后备缓冲区<BR>　　  
      BltSurface(backsurf,bksurf,0,0,TRUE);<BR>　　}<BR>　　<BR>　　void  
      FlyWin::RestoreSurfaces()<BR>　　{<BR>　　// reclain lost surfaces with the  
      DirectDrawSurface Restore() function<BR>　　// depending on the surface's  
      function, it may be necessary to restore<BR>　　// surface content as  
      well<BR>　　 if(bksurf→IsLost()) //如果bksurf<BR>　　丢失<BR>　　 {<BR>　　  
      bksurf→Restore(); //恢复内存<BR>　　 LoadSurface(bksurf,“background.bmp”);  
      //恢复表面内容<BR>　　 }<BR>　　 if(flysurf→IsLost())//如果flysurf丢失<BR>　　 {<BR>　　  
      flysurf→Restore(); //恢复内存<BR>　　 LoadSurface(flysurf,“bird.bmp”);  
      //恢复表面内容<BR>　　 }<BR>　　}<BR>　　<BR>　　int FlyWin::SelectDriver()<BR>　　{<BR>　　  
      int numdrivers=GetNumDrivers();<BR>　　 if (numdrivers==1)<BR>　　 return  
      0;<BR>　　<BR>　　 CArray drivers;<BR>　　 for (int i=0;i 　　 {<BR>　　 LPSTR desc,  
      name;<BR>　　 GetDriverInfo( i, 0, ＆desc, ＆name );<BR>　　  
      drivers.Add(desc);<BR>　　 }<BR>　　 DriverDialog dialog;<BR>　　  
      dialog.SetContents( ＆drivers );<BR>　　 if (dialog.DoModal()!=IDOK)<BR>　　  
      return －1;<BR>　　 return dialog.GetSelection();<BR>　　}<BR>　　int  
      FlyWin::SelectInitialDisplayMode()<BR>　　{<BR>　　 DWORD  
      curdepth=GetDisplayDepth();<BR>　　 int i,  
      nummodes=GetNumDisplayModes();<BR>　　 DWORD w,h,d;<BR>　　 if  
      (curdepth!=desireddepth)<BR>　　 ddraw2→SetDisplayMode( 640, 480, curdepth,  
      0, 0 );<BR>　　 for (i=0;i 　　 {<BR>　　 GetDisplayModeDimensions( i, w, h, d  
      );<BR>　　 if (w==desiredwidth ＆＆ h==desiredheight ＆＆ d==desireddepth)<BR>　　  
      return i;<BR>　　 }<BR>　　 for (i=0;i 　　 {<BR>　　 GetDisplayModeDimensions( i,  
      w, h, d );<BR>　　 if (d==desireddepth)<BR>　　 return i;<BR>　　 }<BR>　　 return  
      0;<BR>　　}<BR>　　void FlyWin::OnKeyDown(UINT nChar, UINT nRepCnt, UINT  
      nFlags) <BR>　　{<BR>　　 if (nChar==VK_ESCAPE) //按ESC退出<BR>　　 PostMessage(  
      WM_CLOSE );<BR>　　 DirectDrawWin::OnKeyDown(nChar, nRepCnt,  
      nFlags);<BR>　　}<BR>　　<BR>　　int FlyWin::OnCreate(LPCREATESTRUCT  
      lpCreateStruct)<BR>　　{<BR>　　 if (DirectDrawWin::OnCreate(lpCreateStruct)  
      == －1)<BR>　　 return －1;<BR>　　 // TODO: Add your specialized creation code  
      here<BR>　　 SetTimer(1,nMoveSpeed,NULL); //设置定时器<BR>　　 return  
      0;<BR>　　}<BR>　　<BR>　　void FlyWin::OnTimer(UINT nIDEvent)<BR>　　{<BR>　　 //  
      TODO: Add your message handler code here and/or call default<BR>　　 int  
      nWhich=nCount％4＋1;<BR>　　 nCount＋＋;<BR>　　 //判断当前表面为4个子表面中的哪一个<BR>　　  
      switch(nWhich)<BR>　　 {<BR>　　 case 1:<BR>　　 cursurf=flysurf1;<BR>　　  
      break;<BR>　　 case 2:<BR>　　 cursurf=flysurf2;<BR>　　 break;<BR>　　 case  
      3:<BR>　　 cursurf=flysurf3;<BR>　　 break;<BR>　　 case 4:<BR>　　  
      cursurf=flysurf4;<BR>　　 break;<BR>　　 default:<BR>　　 break;<BR>　　 }<BR>　　  
      //处理移动的子画面<BR>　　 x＋=nIncX;<BR>　　 y＋=nIncY;<BR>　　  
      //如子画面移动到屏幕下方或上方,应碰撞返回<BR>　　 if(y&gt;=(int)(480－fh/2)||y&lt;=0)<BR>　　  
      {<BR>　　 nIncY=－nIncY;<BR>　　 y＋=nIncY;<BR>　　 }<BR>　　  
      //如子画面移动到屏幕右方或左方,应碰撞返回<BR>　　 if(x&gt;=(int)(640－fw/2)||x&lt;=0)<BR>　　  
      {<BR>　　 nIncX=－nIncX;<BR>　　 x＋=nIncX;<BR>　　 }<BR>　　 //把当前表面拷贝到后备缓冲区<BR>　　  
      BltSurface(backsurf,cursurf,x,y,TRUE);<BR>　　 //执行页面翻转,使后备缓冲区的内容可见<BR>　　  
      primsurf→Flip( 0, DDFLIP_WAIT );<BR>　　<BR>　　  
      //把备份的背景区域拷贝到后备缓冲区,以便恢复曾被<BR>　　 //覆盖的背景<BR>　　  
      BltSurface(backsurf,storesurf,nPreX,nPreY);<BR>　　  
      //存储下一帧的子画面移动时所覆盖的背景区域于storesurf<BR>　　  
      CopySurface(storesurf,bksurf,x,y);<BR>　　 nPrex=x;<BR>　　 nPrey=y;<BR>　　  
      DirectDrawWin::OnTimer(nIDEvent);<BR>　　}<BR>　　void  
      FlyWin::OnDestroy()<BR>　　{<BR>　　 DirectDrawWin::OnDestroy();<BR>　　 //  
      TODO: Add your message handler code here<BR>　　 KillTimer(1);  
      //取消定时器<BR>　　}<BR>　　void FlyWin::CopySurface(LPDIRECTDRAWSURFACE ts,<BR>　　  
      LPDIRECTDRAWSURFACE ss,<BR>　　 int x,int y)<BR>　　{<BR>　　 if(!ts || !ss )  
      return;<BR>　　 DDSURFACEDESC tdesc,sdesc;<BR>　　 //初始化sdesc,tdesc为零<BR>　　  
      ZeroMemory(＆sdesc,sizeof(sdesc));<BR>　　  
      ZeroMemory(＆tdesc,sizeof(tdesc));<BR>　　 sdesc.dwSize=sizeof(sdesc);<BR>　　  
      tdesc.dwSize=sizeof(tdesc);<BR>　　 //得到源表面ss,目标表面ts的描述信息<BR>　　 HRESULT  
      r=ss→GetSurfaceDesc(＆sdesc);<BR>　　 if(r!=DD_OK) return;<BR>　　  
      r=ts→GetSurfaceDesc(＆tdesc);<BR>　　 if(r!=DD_OK) return;<BR>　　  
      //定义源表面上的矩形区域,大小大等于目标表面的面积<BR>　　 CRect  
      rc(x,y,x＋tdesc.dwWidth,y＋tdesc.dwHeight);<BR>　　 //超界处理<BR>　　  
      if(x＋tdesc.dwWidth&gt;(int)sdesc.dwWidth) return;<BR>　　  
      if(y＋tdesc.dwHeight&gt;(int)sdesc.dwHeight) return;<BR>　　  
      //拷贝源表面ss到目标表面ts<BR>　　 r=ts→BltFast(0,0,ss,＆rc,  
      DDBLTFAST_SRCCOLORKEY|DDBLTFAST_WAIT);<BR>　　 if(r!=DD_OK)  
      return;<BR>　　}<BR>　　void FlyWin::SplitSurface(LPDIRECTDRAWSURFACE  
      ts,<BR>　　 LPDIRECTDRAWSURFACE ss,<BR>　　 CRect＆ srcc,<BR>　　 int x,<BR>　　  
      int y)<BR>　　{<BR>　　 if(!ts||!ss) return;<BR>　　 DDSURFACEDESC  
      tdesc,sdesc;<BR>　　 ZeroMemory(＆sdesc,sizeof(sdesc));<BR>　　  
      ZeroMemory(＆tdesc,sizeof(tdesc));<BR>　　 sdesc.dwSize=sizeof(sdesc);<BR>　　  
      tdesc.dwSize=sizeof(tdesc);<BR>　　 HRESULT  
      r=ts→GetSurfaceDesc(＆tdesc);<BR>　　 if(r!=DD_OK) return;<BR>　　  
      r=ss→GetSurfaceDesc(＆sdesc);<BR>　　 if(r!=DD_OK) return;<BR>　　 //超界处理<BR>　　  
      if(x＋srcc.Width()&gt;(int)tdesc.dwWidth) return;<BR>　　  
      if(y＋srcc.Height()&gt;(int)tdesc.dwHeight) return;<BR>　　  
      //把源表面srcc的矩形区域拷贝到目标表面左上角坐标为(x,y)处<BR>　　 r=ts→BltFast(x,y,ss,＆srcc,<BR>　　  
      DDBLTFAST_SRCCOLORKEY|DDBLTFAST_WAIT); <BR>　　 if(r!=DD_OK)  
      return;<BR>　　}<BR>　　DDSURFACEDESC为表面描述结构，用以保存表面的所有信息，它的成员变量<BR>dwSize为结构的大小而且必须要被初始化；dwHeight为表面的高度；dwWidth为<BR>表面的宽度。用函数GetSurfaceDesc()可以获取上述描述信息。 
      <BR>　　DirectDraw首先调用CreateCustomSurface()函数，我们将在这个函数中创<BR>建和准备程序所用到的表面。DrawSence()函数负责更新屏幕，因此我们用它来<BR>显示背景画面。我们主要的工作都在OnTimer()函数里，首先判断当前子画面为<BR>4帧子画面中的哪一帧，然后进行页面翻转、显示子画面和复制背景区域等操作。<BR>　　BltFast()函数用于表面之间的拷贝，它的前两个参数指出blt的目标表面位<BR>置，第三个参数是指向源表面的指针，第四个参数是源表面上被拷贝的矩形区域，<BR>最后的参数是DDBLTFAST_SRCCOLORKEY和DDBLTFAST_WAIT，第一个标志用来激活<BR>源表面的色彩键码；第二个标志表示只有结束blt操作，BltFast()函数才返回。<BR>　　Flip()函数用于页面翻转操作，使backsurf表面的内容可见。它有两个参数。<BR>第一个参数是个表面指针，它在用来翻转有多个后备缓冲区的表面时才有用；第<BR>二个参数是DDFLIP_WA<BR>　　IT标志，用来指示函数只有在表面完成之后才能返回。<BR>　　当程序运行时，一个表面所在的内存可能会被另一个应用程序所占用，这形<BR>成了“表面丢失”。这时DirectDraw会调用RestoreSurface()函数来恢复丢失的<BR>表面。但是，如果你的显卡不是老掉牙了，这种情况一般是不会发生的。所以这<BR>里我只对两个主要表面bksurf、flysurf进行了恢复处理，而不再管其它的表面。<BR>　　另外，函数SelectDriver()和SelectInitialDisplayMode()是AppWizard自动<BR>创建的。SelectDriver()选择一个显示驱动程序，SelectInitialDisplayMode()<BR>选择一个初始显示模式。<BR>　　三、结束语<BR>　　话已至此，你对DirectDraw编程应有一个大致的了解了吧！用DirectDraw编<BR>程其实很简单，说白了其实就是一句话：“几个表面之间拷来拷去”。只不过这<BR>其间可是大有文章可作的哟！ 
      </P>    
      <p>　    
    </td>    
  </tr>    
</table>    
</center></div>    
<p>　</p>
</BODY></HTML>
