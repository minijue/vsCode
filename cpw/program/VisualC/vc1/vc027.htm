<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>您现在的位置是</title>
</head>

<body>

<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../../progidx.htm">编程技巧</a> --&gt; 
      <a href="../Vcidx098.htm">VC</a></b></span></td>      
  </tr>      
</table>      
</center></div><div align="center"><center>      
      
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"      
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">      
  <tr>      
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"      
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"      
    bordercolordark="#FFFFFF">      
      <tr>      
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font      
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"      
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>      
      </tr>      
    </table>      
      <p align="center">在Windows中使用精确计时器&nbsp;<br>
      <br>
         江西省东乡县人民银行 黎旭昌 (邮政编码 331800)</p> 
      <p><br> 
      1.前言。<br> 
      <br> 
      &nbsp; 我们知道，在Windows中，可以通过调用SetTimer函数为应用程序分配一个计时器。当指定了一个时间间隔以后，Windows系统将每隔指定的时间向应用发送一条WM_TIMER消息，从而使应用程序能够实现许多与时间相关的动作。<br>
      &nbsp; 然而需要指出的是，由系统发给应用程序的WM_TIMER消息并不是异步的，这条消息被放在常规的消息队列中，并与其它消息一起排序。因此，即使我们在调用SetTimer()时设定了1000毫秒的时间间隔，应用程序却不一定保证每隔一秒钟接受到一条WM_TIMER消息，如果另一个程序的忙碌时间超过一秒钟，那么我们的应用程序在那段时间内就不能接收到任何WM_TIMER消息。<br>
      &nbsp; 显然，这种情况的存在对那些需要精确时间间隔的应用(如某些监控程序)来说是致命的。所幸的是，在Windows中隐藏着某些机制，使得我们能够获得精确计时器服务。<br>
      <br>
      2.系统计时器.<br>
      <br>
      &nbsp; 在Windows的SYSTEM.DRV驱动程序中提供了几个鲜为人知的系统计时器函数(这几个函数未写入Windows.h中，但却被SYSTEM.DRV输出了)，这几个函数可以帮助我们获得精确计时器服务，即系统计时器。这其中最重要的是CreateSystemTimer()和KillSystemTimer()，这两个函数允许我们安装异步计时器的回调函数(Callback)，有些类似于在DOS环境中截取INT 8中断处理程序。这个回调是真正异步的，完全避开了Windows的消息工具，因而具有重要意义。事实上，Microsoft Excel和Windows COMM驱动程序都用到了系统计时器，而由SetTimer()安装的一般计时器也是由系统计时器来实现的。<br> 
      <br> 
      这两个函数的原型如下：<br> 
      WORD CreateSystemTimer(wMsecInterval,lpfnTimerProc)；<br> 
      WORD wMsecInterval; /*以毫秒为单位的时间间隔，系统将每隔此时间调用一 次回调函数*/<br> 
      FARPROC lpfn TimerProc；/*指向回调函数的指针*/<br> 
      WORD KillSystemTimer(hTimer);<br> 
      WORD hTimer;/*欲释放的系统计时器句柄*/<br> 
      <br> 
      其中，CreateSystemTimer()用于安装一个系统计时器回调函数，SYSTEM INT8处理程序将按wMsecInterval指定的时时间间隔调用此回调函数。当然，这个指定的回调频率也是有限的，同SetTimer()一样，每秒钟调用回调函数次数不能超过18.2次，即wMsecInterval>55。该函数返回一个系统计时器句柄。若安装失败，则返回NULL。KillSystemTimer()则用于撤销一个已安装的系统计时器hTimer。若成功，则返回；出错则返回传给它的参数hTimer。<br> 
      <br> 
      3.使用系统计时器应注意的问题。<br> 
      <br> 
      系统计时器回调函数虽然不是中断处理程序，但由于它直接被中断处理程序调用，因此也必将它看作中断代码。这也就决定了在使用过程中必须注意以下几个问题：<br> 
      (1).在回函数中应包括尽量少的代码，以使得频繁回调的该函数不至于占用太多的CPU时间。一般情况下，系统计时器总是用来监视或设置某些变量的值。<br> 
      (2).由于该回调函数属于中断代码，因此大多数Windows API函数调用都不适用了，只有几个简单的函数仍然可以使用，如PostMessage(),GetCurrentTask()和MessageBeep()等。<br> 
      (3).由于该回调函数由中断处理程序直接调用，因此该函数必须放在一个固定的代码段中，并且调用前必须装载DS寄存器，这可由形实替换函数MakeProcInstance()来做到。チ硗猓由于这两个函数在Windows.h中没有给出(即Windows缺省输入库不含此两函数)，因此在调用之前必须进行链接。这可采用运行时动态链接，即通过GetModuleHandle()和GetProcAddress()来链接；也可在程序模块定义文件中用IMPORTS语句来引入，此时则必须在程序源文件中说明CreateSystemTimer()和KillSystemTimer()为外部函数。本文给出的例子采用第二种方案。<br> 
      <br> 
      4.一个例子。<br> 
      <br> 
      本文最后给出一个简单的例子，以说明系统计时器是如何工作的。在本例中，我们安装了一个每秒钟调用一次的回调函数，该回调函数发出一声蜂鸣。为了测试该系统计时器，我们特意编写了一段较长时间的循环语句。在这段循环中，由SetTimer()安装的通常计时器是不能工作的(因为Windows是一个非抢先的系统)，而我们安装的系统计时器仍然能每隔一秒钟发出一声蜂鸣。ジ美子在MSVC++1.5中调试通过，运行良好。<br> 
      //SystemT.c<br> 
      #include&lt;windows.h><br> 
      extern WORD WINAPI CreateSystemTimer(WORD wTimeOut,FARPROC lpfnTimerProc);<br> 
      extern WORD WINAPI KillSystemTimer(WORD hTimer);<br> 
      void FAR PASCAL_export MyTimerProc(void);<br> 
      WORD SetUpSystemTimer(WORD wTimeOut);<br> 
      BOOL ClearSystem Timer(WORD hTm);<br> 
      FARPROC fpTimerProc=NULL;<br> 
      WORD hTimer=NULL;<br> 
      char szAppName[]="SystemTimer";<br> 
      int PASCAL WinMain(HANDLE hInstance,HANDLE hPrevInstance,<br> 
      LPSTR lpszCmdParam,int nCmdShow)<br> 
      {<br> 
      WNDCLASS wc;<br> 
      HWND hWndMain;<br> 
      int i,j;<br> 
      HCURSOR hcurSave;<br> 
      if(hPrevInstance=NULL){<br> 
      wc.lpszMenuName =NULL;&nbsp;<br>
      wc.lpszClassName =szAppName;<br> 
      wc.hInstance =hInstance;&nbsp;<br>
      wc.hIcon =LoadIcon(NULL,IDI_APPLICATION);<br> 
      wc.hCursor =LoadCursor(NULL,IDC_ARROW);<br> 
      wc.hbrBackground =(HBRUSH)COLOR_WINDOW+1;<br> 
      wc.style =0;&nbsp;<br>
      wc.lpfnWndproc =DefWindowProc;<br> 
      wc.cbClsExtra =0;&nbsp;<br>
      wc.cbWndExtra =0;<br> 
      if(!RegisterClass(&amp;wc))<br> 
      return(0);<br> 
      }<br> 
      if(hWndMain=CreateWindow(szAppName,<br> 
      szAppName,WS_OVERLAPPEDWINDOW,<br> 
      CW_USEDEFAULT,CW_USEDEFAULT,<br> 
      CW_USEDEFAULT,CW_USEDEFAULT,<br> 
      NULL,NULL,hInstance,NULL))=NULL)<br> 
      return(0);<br> 
      ShowWindow(hWndmain,nCmdShow);<br> 
      Update Window(hWndMain);<br> 
      fpTimerProc=MakeProcInstance((FARPROC)MyTimerProc,hInstance);<br> 
      if(hTimer=SetUpSystemTimer(1000))=NULL{<br> 
      MessageBox(hwndMain,"Set System Timer Error",<br> 
      szAppName,MB_ICONEXCLAMATION:MB_OK);<br> 
      return 0;<br> 
      }<br> 
      hcurSave=SetCursor(LoadCursor(NULL,IDC_WAIT));<br> 
      for(i=0;i&lt;10000;i++)<br> 
      for(j=0;j&lt;10000;j++)<br> 
      SetCursor(hcurSave);<br> 
      ClearSystemTime(hTimer);<br> 
      }<br> 
      WORD SetUpSystemTime(WORD wTimeOut)<br> 
      {<br> 
      WORD hTm;<br> 
      if((hTm=CreateSystemTimer(wTimeOut,fpTimerProc))=NULL){<br> 
      fpTimerProc=NULL:<br> 
      return NULL<br> 
      }else return hTm;<br> 
      }<br> 
      BOOL ClearSystemTimer(WORD hTm)<br> 
      {<br> 
      if(hTm){<br> 
      if(KillSystemTimer(hTm)!=0)<br> 
      return FALSE;<br> 
      hTm=NULL;<br> 
      }<br> 
      return TRUE<br> 
      voidFAR PASCAL_export MyTimerProc(void)<br> 
      {<br> 
      MessageBeep(0);<br> 
      }<br> 
      ////////////////////////////////////<br> 
      //SystemT.def<br> 
      NAME SystemTimer<br> 
      DESCRIPTION`System Timer`<br> 
      EXETYPE WINDOWS<br> 
      STUB `WINSTUB`<br> 
      CODE PRELOAD<br> 
      DATA PRELOAD MOVABLE MULTIPLE<br> 
      HEAPSIZE 1024<br> 
      STACKSIZE 8192<br> 
      EXPORTS MyTimerProc<br> 
      IMPORTS CreateSystemTimer=SYSTEM.CREATESYSTEMTIMER<br> 
      KillSystemTimer=SYSTEM.KILLSYSTEMTIMER      
    </td>      
  </tr>      
</table>      
</center></div>      
 
</body> 
 
</html> 
