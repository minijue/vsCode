<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://person.zj.cninfo.net/~yao/document/vc/vc007.htm -->
<!-- Copyright 1999 网页制作人：姚征   http://yaozheng.yeah.net  --><HTML><HEAD><TITLE>用MFC实现在字段中存储变长数组</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<STYLE>TD {
	FONT-FAMILY: 宋体; FONT-SIZE: 10.5pt
}
PRE {
	FONT-FAMILY: Times New Roman; FONT-SIZE: 10.5pt
}
</STYLE>

<META content="Microsoft FrontPage 4.0" name=GENERATOR></HEAD>
<BODY>
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../../progidx.htm">编程技巧</a> --&gt; 
      <a href="../Vcidx098.htm">Visual C++</a></b></span></td>    
  </tr>    
</table>    
</center></div><div align="center"><center>    
    
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"    
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">    
  <tr>    
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"    
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"    
    bordercolordark="#FFFFFF">    
      <tr>    
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font    
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"    
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>    
      </tr>    
    </table>    
      <P align=center><STRONG>用MFC实现在字段中存储变长数组<BR><BR>黄晓润</STRONG></P>
      <P>---- 在 数 据 库 应 用 时， 有 时 会 遇 到 这 样 的 情 况： 记 录 的 某 项 信 息 由 变 长 数 组 构 成。 这  
      时 传 统 方 法 是 建 立 一 个 新 表， 并 通 过 表 间 的 关 系 来 记 录 将 相 应 数 据 关 联 起 来； 但 是 这 样  
      实 现 相 对 比 较 复 杂， 而 且 也 不 符 合 思 维 逻 辑。 由 于 该 数 组 整 个 构 成 记 录 的 一 个 具 体 项， 因  
      此 如 果 能 够 将 它 作 为 一 个 字 段 则 更 加 直 观 些， 同 时 在 一 些 情 况 下 也 比 较 容 易 处 理。 那 么，  
      下 面 将 向 您 提 供 一 种 这 样 的 方 法。 为 了 说 明 上 的 方 便， 我 首 先 假 定 了 下 面 的 需 求：  
      <BR><BR>---- 在 个 人 简 历 数 据 表 中， 需 要 将 工 作 经 历 分 为 起、 止 时 间、 单 位、 职 位 等 信  
      息。 <BR><BR>---- 在 这 种 情 况， 可 以 分 别 建 立 个 人 简 历 和 工 作 经 历 两 个 表 并 将 之 通 过 关  
      键 字 进 行 关 联， 从 而 达 到 要 求。 但 也 可 以 采 用 只 建 立 一 个 表 的 方 式 来 完 成 数 据 的 管 理  
      <BR><BR>---- 那 么 如 何 完 成 呢 ？ 下 面 将 给 出 具 体 的 实 现。 <BR><BR>---- 首 先 建 立 一 个  
      表Person， 记 录 包 含 个 人 简 历 需 要 的 各 个 字 段， 将 工 作 经 历 作 为 一 个 字 段， 其 类 型  
      为Image( 在Access 数 据 库 中 为"OLE 对 象")。 下 面 新 建 类CPersonRs。 将 它 与 表Person 对 应  
      起 来， 并 将 m_dResume 对 应 到 字 段 工 作 经 历 中，m_dResume 的 类 型 为CByteArray 。 下 面 我  
      们 来 定 义 工 作 定 义 的 基 本 结 构: <BR><BR>class  
      CResumeItem<BR>{<BR>public:<BR>COleDateTime m_timeBegin;<BR>COleDateTime  
      m_timeEnd;<BR>COleDateTime m_strCompany;<BR>COleDateTime  
      m_strTitle;<BR><BR>Void Serialize( CArchive&amp; ar )<BR>};<BR>typedef  
      CArray&lt; CResumeItem, CResumeItem&amp; &gt; CResume;<BR><BR>----  
      在CPersonRs 中 定 义 下 面 的 函 数 <BR><BR>CPersonRs<BR>{<BR>……<BR>CByteArray  
      m_dResume;<BR>……<BR>void SetResume( CString strName, CResume&amp; resume  
      );<BR>void GetResume( CString strName, CResume&amp; resume  
      );<BR>};<BR><BR>并在相应的文件给出相应的函数的实现;<BR>void CResumeItem::Serialize(  
      CArchive&amp; ar )<BR>{<BR>if ( ar.IsLoading() )<BR>{<BR>ar &gt; &gt;  
      m_timeBegin<BR>&gt; &gt; m_timeEnd<BR>&gt; &gt; m_strCompany<BR>&gt; &gt;  
      m_strTitle;<BR>}<BR>else<BR>{<BR>ar &lt; &lt; m_timeBegin<BR>&lt; &lt;  
      m_timeEnd<BR>&lt; &lt; m_strCompany<BR>&lt; &lt; m_strTitle;<BR>}<BR>}</P> 
      <P>函数SetResume和GetResume实现如下：<BR>void CPersonRs::SetResume<BR>( CString  
      strName, CResume&amp; resume  
      )<BR>{<BR>…………//根据strName定位到相应的记录<BR>Edit();<BR>CMemFile  
      memFile;<BR>CArchive ar( &amp;memFile, CArchive::store  
      );<BR>Resume.Serialize( ar );<BR>ar.Close();<BR>DWORD dwSize =  
      memFile.GetLength();<BR>LPBYTE lpInfo = memFile.Detach(  
      );<BR>m_dResume.SetSize( dwSize );<BR>memcpy(  
      m_dResume.GetData(),lpInfo,dwSize);<BR>SetFieldNull( &amp;m_dResume, FALSE  
      );<BR>SetFieldDirty( &amp;m_dResume );<BR>ASSERT( CanUpdate()  
      );<BR>Update( );<BR>free( lpInfo ); <BR>}<BR><BR>void  
      CPersonRs::GetResume<BR>( CString strName, CResume&amp; resume  
      )<BR>{<BR>…………//根据strName定位到相应的记录<BR>LPBYTE lpInfo;<BR>DWORD  
      dwSize;<BR>dwSize = m_dResume.GetSize();<BR>lpInfo =  
      m_dResume.GetData();<BR>memFile.Attach( lpInfo, dwSize );<BR>CArchive ar(  
      &amp;memFile,CArchive::load );<BR>resume.Serialize( ar  
      );<BR>ar.Close();<BR>memFile.Detach( ); <BR>}<BR><BR>---- 通 过SetResume  
      和GetResume 可 以 方 便 地 将Resume 的 内 容 读 出 或 写 入 到 记 录 的 工 作 经 历 字 段 中， 而 且 更  
      新 也 相 当 方 便。 这 样 是 就 可 以 在 工 作 经 历 字 段 任 意 个 工 作 经 历 项， 而 且 由 于 是 在 一 个 表，  
      也 省 去 了 多 表 造 成 的 麻 烦。 <BR><BR>---- 不 过， 最 后 需 要 声 明 的 是， 上 述 例 子 的 情 况 根  
      据 实 际 需 要 可 能 用 多 表， 但 这 里 只 是 借 它 说 明 这 样 一 种 实 现 方 法， 也 许 你 会 在 某 些情 况 下  
      这 些 会 相 当 简 单 些。 本 文 也 只 给 出 实 现 的 关 键 代 码， 对 于 如 何 使 用MFC 访 问 数 据 库、 序 列  
      化 机 制 可 以 参 见VC 的 相 应 文  
档。</P>     
      <p>　     
    </td>     
  </tr>     
</table>     
</center></div>     
<p>　</p> 
</BODY></HTML> 
