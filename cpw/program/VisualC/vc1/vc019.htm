<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>您现在的位置是</title>
</head>

<body>

<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../../progidx.htm">编程技巧</a> --&gt; 
      <a href="../Vcidx098.htm">Visual C++</a></b></span></td>    
  </tr>    
</table>    
</center></div><div align="center"><center>    
    
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"    
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">    
  <tr>    
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"    
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"    
    bordercolordark="#FFFFFF">    
      <tr>    
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font    
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"    
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>    
      </tr>    
    </table>    
      <p align="center"><b>C++Builder如何响应消息及自定义消息&nbsp;</b>    
      <p>    Inprise(Borland) C++Builder中，可以象在Delphi中一样响应消息，只是看起来要稍复杂一点。&nbsp;<br>
      <br>
      对于系统已定义的消息，可以直接响应：&nbsp;<br>
      <br>
      #define WM_MY_OPEN_CMDLINE_FILE (WM_USER+1) //进程间通讯的自定义消息&nbsp;<br>
      #define WM_MY_SEARCH_NODE (WM_USER+2) //查找命令的自定义消息&nbsp;<br>
      <br>
      class TSomeForm : public TForm&nbsp;<br>
      {&nbsp;<br>
      //...类中的其它代码&nbsp;<br>
      protected:&nbsp;<br>
      //消息的响应过程&nbsp;<br>
      void __fastcall OpenCmdLineFile(TMessage Message);&nbsp;<br>
      void __fastcall SearchDocumentNode(TMessage Message);&nbsp;<br>
      void __fastcall GetWindowMinMaxInfo(TWMGetMinMaxInfo Message);&nbsp;<br>
      <br>
      //以下通过宏定义实现消息的正确响应&nbsp;<br>
      BEGIN_MESSAGE_MAP&nbsp;<br>
      MESSAGE_HANDLER(WM_MY_OPEN_CMDLINE_FILE, TMessage, OpenCmdLineFile)&nbsp;<br>
      MESSAGE_HANDLER(WM_MY_SEARCH_NODE, TMessage, SearchDocumentNode)&nbsp;<br>
      MESSAGE_HANDLER(WM_GETMINMAXINFO , TWMGetMinMaxInfo, GetWindowMinMaxIn&nbsp;<br>
      fo)&nbsp;<br>
      END_MESSAGE_MAP(TForm)&nbsp;<br>
      <br>
      };//end class&nbsp;<br>
      <br>
      //以下为实现代码&nbsp;<br>
      void __fastcall TSomeForm::OpenCmdLineFile(TMessage Message)&nbsp;<br>
      {//直接通过消息结构传递参数&nbsp;<br>
      LPSTR lpCmdLine=(LPSTR)Message.LParam;//从Message中取得参数&nbsp;<br>
      this->HandleCmdLineFile(lpCmdLine);//处理命令行的参数&nbsp;<br>
      return;&nbsp;<br>
      }&nbsp;<br>
      <br>
      void __fastcall TSomeForm::SearchDocumentNode(TMessage Message)&nbsp;<br>
      {//响应查找消息&nbsp;<br>
      //Message中的参数在此处不需要。&nbsp;<br>
      this->SearchNode();&nbsp;<br>
      return;&nbsp;<br>
      }&nbsp;<br>
      <br>
      void __fastcall TSomeForm::GetWindowMinMaxInfo(TWMGetMinMaxInfo Messag&nbsp;<br>
      e)&nbsp;<br>
      {//设置主窗口的最小尺寸&nbsp;<br>
      MINMAXINFO *MinMaxInfo=Message.MinMaxInfo;&nbsp;<br>
      MinMaxInfo->ptMinTrackSize.x=400;&nbsp;<br>
      MinMaxInfo->ptMinTrackSize.y=300;&nbsp;<br>
      return;&nbsp;<br>
      }&nbsp;<br>
      <br>
      其中：TMessage和TWMGetMinMaxInfo类型的定义可参见：&nbsp;<br>
      <br>
      C:Program FilesBorlandCBuilderinlucdevclMessages.hpp；其它的消息 响应方法与此相同。&nbsp;<br>
      <br>
  另外，可以为自定义的消息也定义一个对应的消息结构(如：TSearchNode_Mes 
      sage)，至于如何定义消息结构, 可以参考：<br> 
      C:Program FilesBorlandCBuilderinlucdevclMessages.hpp     
    </td>    
  </tr>    
</table>    
</center></div>    

</body>

</html>
