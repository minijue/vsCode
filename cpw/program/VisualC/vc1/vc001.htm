<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>您现在的位置是</title>
</head>

<body stylesrc="../../../index1.htm" background="../../../res/back.gif">

<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="95%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../../progidx.htm">编程技巧</a> --&gt; 
      Visual C --&gt; </b> </span>用VC++6.0编写Proxy服务器</td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="1" width="95%" style="font-size: 9pt" bgcolor="#FFFFFF"
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">
  <tr>
    <td width="15%" align="center" valign="top"><!--webbot bot="Include"
      U-Include="../../progmenu.htm" TAG="BODY" startspan -->

<table border="1" width="13%" bordercolor="#000000" cellspacing="3" cellpadding="3" style="font-size: 9pt; border-style: solid; border-color: #FFFFFF">
  <tr>
    <td width="100%" align="center"><a href="../Vcidx098.htm" target="_self"><strong>Visual 
      C</strong></a></td> 
  </tr> 
  <tr> 
    <td width="100%" align="center"><a href="../../Vb/Vbidx099.htm" target="_self"><strong>VBasic</strong></a></td>
  </tr>
  <tr>
    <td width="100%" align="center"><strong><a href="../../Vfp/Vfp_idx.htm" target="_self">VFoxpro</a></strong></td>
  </tr>
  <tr>
    <td width="100%" align="center"><strong><a href="../../Delphi/Del_idx.htm" target="_self">Delphi</a></strong></td>
  </tr>
  <tr>
    <td width="100%" align="center"><a href="../../powerbuild/pow_idx.htm" target="_self"><b>PowerBuilder</b></a></td>
  </tr>
  <tr>
    <td width="100%" align="center"><a href="../../linux/linuxidx.htm" target="_self"><b>Linux</b></a></td>
  </tr>
  <tr>
    <td width="100%" align="center"><strong><a href="../../other/oth_idx.htm" target="_self">其它</a></strong></td>
  </tr>
</table>
<!--webbot bot="Include" endspan i-checksum="4316" -->

    </td>
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"
    bordercolordark="#FFFFFF">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>
      </tr>
    </table>
      <p align="center"><b>用VC++6.0编写Proxy服务器</b>
      <p><br>
      &nbsp;&nbsp;&nbsp; 我们一般常用的Internet代理服务器是用微软的Proxy 
      Server 2.0 。但我们可以自己动手编写一个简单、小型的Proxy 
      Server 。下面介绍具体的实现方法。 <br>
      <br>
      一． 原理 <br>
      <br>
      本程序的结构原理如下： <br>
      <br>
      对于每一个用户的请求（Internet 
      请求，由浏览器发出），本程序将启动两个线程，一个把本地用户的请求数据发送到远程的Internet主机，另一个线程把远程主机的回应数据发送到本地请求用户。 
      <br>
      <br>
      二． 主要函数 <br>
      <br>
      UserToProxyThread ( void * pParam ) 
      ：它是用来把本地用户请求数据发送到远程主机的，起服务器线程角色。当接到本地（局域网）用户的请求，它就启动另一个自身线程，以侦听别的用户的请求，并读出已接收到的请求数据，接着启动第二个线程ProxyToServer()（这个线程用来连接远程主机），当远程主机连接成功后，它把已读出的本地用户请求数据发送到远程主机。 
      <br>
      <br>
      ProxyToServer ( void * pParam) 
      ，可以被当作是客户端服务，它把远程主机发送来的数据分发给本地请求用户。 
      <br>
      三． 开发运行环境 <br>
      <br>
      本程序是在VC++6.0环境下开发的，在Win95 和 WinNT4.0下运行正常。 
      <br>
      <br>
      四． 详细代码<br>
      #include &quot;stdafx.h&quot;<br>
      #include &quot;Proxy.h&quot;<br>
      #include &lt; winsock2.h &gt; //WINSOCKET API 2。0<br>
      #include &lt; stdlib.h &gt;<br>
      #include &lt; stdio.h &gt;<br>
      #include &lt; string.h &gt;<br>
      <br>
      #ifdef _DEBUG<br>
      #define new DEBUG_NEW<br>
      #undef THIS_FILE<br>
      static char THIS_FILE[] = __FILE__;<br>
      #endif<br>
      <br>
      ////////////////////////////////////////////////////////////////<br>
      <br>
      <br>
      #define HTTP &quot;http://&quot;<br>
      #define FTP &quot;ftp://&quot;<br>
      #define PROXYPORT 5001 //Proxy 端口<br>
      #define BUFSIZE 10240 //缓冲区大小<br>
      <br>
      <br>
      CWinApp theApp;<br>
      <br>
      using namespace std;<br>
      <br>
      UINT ProxyToServer(LPVOID pParam);<br>
      UINT UserToProxyThread(void *pParam);<br>
      <br>
      struct SocketPair{<br>
      SOCKET user_proxy; //socket : 本地机器到PROXY 服务机<br>
      SOCKET proxy_server; //socket : PROXY 服务机到远程主机<br>
      BOOL IsUser_ProxyClosed; // 本地机器到PROXY 服务机状态<br>
      BOOL IsProxy_ServerClosed; // PROXY 服务机到远程主机状态<br>
      };<br>
      <br>
      <br>
      struct ProxyParam{<br>
      char Address[256]; // 远程主机地址<br>
      HANDLE User_SvrOK; // PROXY 服务机到远程主机的联结状态<br>
      SocketPair *pPair; // 维护一组SOCKET的指针<br>
      int Port; // 用来联结远程主机的端口<br>
      }; //这个结构用来PROXY SERVER与远程主机的信息交换.<br>
      <br>
      SOCKET gListen_Socket; //用来侦听的SOCKET。<br>
      <br>
      int StartServer() //启动服务<br>
      {<br>
      WSADATA wsaData;<br>
      sockaddr_in local;<br>
      SOCKET listen_socket;<br>
      <br>
      if(::WSAStartup(0x202,&amp;wsaData)!=0)<br>
      {printf(&quot;\nError in Startup session.\n&quot;);WSACleanup();return 
      -1;};<br>
      <br>
      local.sin_family=AF_INET;<br>
      local.sin_addr.s_addr=INADDR_ANY;<br>
      local.sin_port=htons(PROXYPORT);<br>
      <br>
      listen_socket=socket(AF_INET,SOCK_STREAM,0);<br>
      if(listen_socket==INVALID_SOCKET)<br>
      {printf(&quot;\nError in New a Socket.&quot;);WSACleanup();return -2;}<br>
      <br>
      if(::bind(listen_socket,(sockaddr *)&amp;local,sizeof(local))!=0)<br>
      {printf(&quot;\n Error in Binding socket.&quot;); WSACleanup();return -3; 
      };<br>
      <br>
      if(::listen(listen_socket,5)!=0)<br>
      {printf(&quot;\n Error in Listen.&quot;); WSACleanup(); return -4;}<br>
      gListen_Socket=listen_socket; <br>
      AfxBeginThread(UserToProxyThread,NULL); //启动侦听<br>
      return 1;<br>
      }<br>
      <br>
      int CloseServer() //关闭服务<br>
      {<br>
      closesocket(gListen_Socket);<br>
      WSACleanup();<br>
      return 1;<br>
      }<br>
      <br>
      //分析接收到的字符，得到远程主机地址<br>
      int GetAddressAndPort( char * str, char *address, int * port)<br>
      {<br>
      char buf[BUFSIZE], command[512], proto[128], *p;<br>
      int j;<br>
      sscanf(str,&quot;%s%s%s&quot;,command,buf,proto);<br>
      p=strstr(buf,HTTP);<br>
      //HTTP<br>
      if(p)<br>
      {<br>
      p+=strlen(HTTP);<br>
      for(int i=0;i&lt; strlen(p);i++)<br>
      if( *(p+i)==`/`) break;<br>
      *(p+i)=0;<br>
      strcpy(address,p);<br>
      p=strstr(str,HTTP);<br>
      for(int j=0;j&lt; i+strlen(HTTP);j++)<br>
      *(p+j)=` `; //去掉远程主机名: GET http://www.njust.edu.cn/ <br>
      HTTP1.1 == &gt; GET / HTTP1.1<br>
      *port=80; //缺省的 http 端口 <br>
      }<br>
      else<br>
      {//FTP, 不支持, 下面的代码可以省略.<br>
      p=strstr(buf,FTP);<br>
      if(!p) return 0;<br>
      p+=strlen(FTP);<br>
      for(int i=0;i&lt; strlen(p);i++)<br>
      if( *(p+i)==`/`) break; //Get The Remote Host<br>
      *(p+i)=0;<br>
      for(j=0;j&lt; strlen(p);j++)<br>
      if(*(p+j)==`:`) <br>
      {*port=atoi(p+j+1); //Get The Port<br>
      *(p+j)=0;<br>
      }<br>
      else *port=21; <br>
      <br>
      strcpy(address,p);<br>
      p=strstr(str,FTP);<br>
      for(j=0;j&lt; i+strlen(FTP);j++)<br>
      *(p+j)=` `; <br>
      }<br>
      return 1; <br>
      }<br>
      <br>
      // 取到本地的数据，发往远程主机<br>
      UINT UserToProxyThread(void *pParam)<br>
      {<br>
      char Buffer[BUFSIZE];<br>
      int Len;<br>
      sockaddr_in from;<br>
      SOCKET msg_socket;<br>
      int fromlen,retval;<br>
      SocketPair SPair;<br>
      ProxyParam ProxyP;<br>
      CWinThread *pChildThread;<br>
      fromlen=sizeof(from);<br>
      msg_socket=accept(gListen_Socket,(struct 
      sockaddr*)&amp;from,&amp;fromlen);<br>
      AfxBeginThread(UserToProxyThread,pParam); //启动另一侦听.<br>
      if( msg_socket==INVALID_SOCKET)<br>
      { printf( &quot;\nError in accept &quot;); return -5;}<br>
      <br>
      //读客户的第一行数据<br>
      <br>
      SPair.IsUser_ProxyClosed=FALSE;<br>
      SPair.IsProxy_ServerClosed=TRUE;<br>
      SPair.user_proxy=msg_socket;<br>
      <br>
      retval=recv(SPair.user_proxy,Buffer,sizeof(Buffer),0);<br>
      <br>
      if(retval==SOCKET_ERROR)<br>
      { printf(&quot;\nError Recv&quot;); <br>
      if(SPair.IsUser_ProxyClosed==FALSE)<br>
      {closesocket(SPair.user_proxy);<br>
      SPair.IsUser_ProxyClosed=TRUE;<br>
      }<br>
      }<br>
      if(retval==0)<br>
      {printf(&quot;Client Close connection\n&quot;);<br>
      if(SPair.IsUser_ProxyClosed==FALSE)<br>
      {closesocket(SPair.user_proxy);<br>
      SPair.IsUser_ProxyClosed=TRUE;<br>
      }<br>
      }<br>
      Len=retval;<br>
      #ifdef _DEBUG<br>
      <br>
      Buffer[Len]=0;<br>
      printf(&quot;\n Received %d bytes,data[%s]from 
      client\n&quot;,retval,Buffer);<br>
      #endif<br>
      //<br>
      SPair.IsUser_ProxyClosed=FALSE;<br>
      SPair.IsProxy_ServerClosed=TRUE;<br>
      SPair.user_proxy=msg_socket;<br>
      <br>
      ProxyP.pPair=&amp;SPair;<br>
      ProxyP.User_SvrOK=CreateEvent(NULL,TRUE,FALSE,NULL);<br>
      <br>
      GetAddressAndPort( Buffer,ProxyP.Address,&amp;ProxyP.Port);<br>
      <br>
      pChildThread=AfxBeginThread(ProxyToServer,(LPVOID)&amp;ProxyP);<br>
      ::WaitForSingleObject(ProxyP.User_SvrOK,60000); //等待联结<br>
      ::CloseHandle(ProxyP.User_SvrOK);<br>
      <br>
      while(SPair.IsProxy_ServerClosed ==FALSE &amp;&amp; 
      SPair.IsUser_ProxyClosed==FALSE)<br>
      { <br>
      retval=send(SPair.proxy_server,Buffer,Len,0);<br>
      if(retval==SOCKET_ERROR)<br>
      { printf(&quot;\n send() failed:error%d\n&quot;,WSAGetLastError());<br>
      if(SPair.IsProxy_ServerClosed==FALSE)<br>
      {<br>
      closesocket(SPair.proxy_server);<br>
      SPair.IsProxy_ServerClosed=TRUE;<br>
      }<br>
      continue;<br>
      }<br>
      retval=recv(SPair.user_proxy,Buffer,sizeof(Buffer),0);<br>
      <br>
      if(retval==SOCKET_ERROR)<br>
      { printf(&quot;\nError Recv&quot;); <br>
      if(SPair.IsUser_ProxyClosed==FALSE)<br>
      {closesocket(SPair.user_proxy);<br>
      SPair.IsUser_ProxyClosed=TRUE;<br>
      }<br>
      continue;<br>
      }<br>
      if(retval==0)<br>
      {printf(&quot;Client Close connection\n&quot;);<br>
      if(SPair.IsUser_ProxyClosed==FALSE)<br>
      {closesocket(SPair.user_proxy);<br>
      SPair.IsUser_ProxyClosed=TRUE;<br>
      }<br>
      break;<br>
      }<br>
      Len=retval;<br>
      #ifdef _DEBUG<br>
      Buffer[Len]=0;<br>
      printf(&quot;\n Received %d bytes,data[%s]from 
      client\n&quot;,retval,Buffer);<br>
      #endif<br>
      <br>
      } //End While<br>
      <br>
      if(SPair.IsProxy_ServerClosed==FALSE)<br>
      {<br>
      closesocket(SPair.proxy_server);<br>
      SPair.IsProxy_ServerClosed=TRUE;<br>
      }<br>
      if(SPair.IsUser_ProxyClosed==FALSE)<br>
      {closesocket(SPair.user_proxy);<br>
      SPair.IsUser_ProxyClosed=TRUE;<br>
      }<br>
      ::WaitForSingleObject(pChildThread- &gt;m_hThread,20000); //Should check 
      the <br>
      return value<br>
      return 0;<br>
      }<br>
      <br>
      // 读取远程主机数据，并发往本地客户机<br>
      UINT ProxyToServer(LPVOID pParam){<br>
      ProxyParam * pPar=(ProxyParam*)pParam;<br>
      char Buffer[BUFSIZE];<br>
      char *server_name= &quot;localhost&quot;;<br>
      unsigned short port ;<br>
      int retval,Len;<br>
      unsigned int addr;<br>
      int socket_type ;<br>
      struct sockaddr_in server;<br>
      struct hostent *hp;<br>
      SOCKET conn_socket;<br>
      <br>
      socket_type = SOCK_STREAM;<br>
      server_name = pPar- &gt;Address;<br>
      port = pPar- &gt;Port;<br>
      <br>
      if (isalpha(server_name[0])) { /* server address is a name */<br>
      hp = gethostbyname(server_name);<br>
      }<br>
      else { /* Convert nnn.nnn address to a usable one */<br>
      addr = inet_addr(server_name);<br>
      hp = gethostbyaddr((char *)&amp;addr,4,AF_INET);<br>
      }<br>
      if (hp == NULL ) {<br>
      fprintf(stderr,&quot;Client: Cannot resolve address [%s]: Error 
      %d\n&quot;,<br>
      server_name,WSAGetLastError());<br>
      ::SetEvent(pPar- &gt;User_SvrOK); <br>
      return 0;<br>
      }<br>
      <br>
      //<br>
      // Copy the resolved information into the sockaddr_in structure<br>
      //<br>
      memset(&amp;server,0,sizeof(server));<br>
      memcpy(&amp;(server.sin_addr),hp- &gt;h_addr,hp- &gt;h_length);<br>
      server.sin_family = hp- &gt;h_addrtype;<br>
      server.sin_port = htons(port);<br>
      <br>
      conn_socket = socket(AF_INET,socket_type,0); /* 打开一个 socket */<br>
      if (conn_socket &lt; 0 ) {<br>
      fprintf(stderr,&quot;Client: Error Opening socket: Error %d\n&quot;,<br>
      WSAGetLastError());<br>
      pPar- &gt;pPair- &gt;IsProxy_ServerClosed=TRUE;<br>
      ::SetEvent(pPar- &gt;User_SvrOK); <br>
      return -1;<br>
      }<br>
      <br>
      <br>
      #ifdef _DEBUG<br>
      printf(&quot;Client connecting to: %s\n&quot;,hp- &gt;h_name);<br>
      #endif<br>
      if (connect(conn_socket,(struct sockaddr*)&amp;server,sizeof(server))<br>
      == SOCKET_ERROR) {<br>
      fprintf(stderr,&quot;connect() failed: %d\n&quot;,WSAGetLastError());<br>
      pPar- &gt;pPair- &gt;IsProxy_ServerClosed=TRUE; <br>
      ::SetEvent(pPar- &gt;User_SvrOK); <br>
      return -1;<br>
      }<br>
      pPar- &gt;pPair- &gt;proxy_server=conn_socket;<br>
      pPar- &gt;pPair- &gt;IsProxy_ServerClosed=FALSE;<br>
      ::SetEvent(pPar- &gt;User_SvrOK);<br>
      // cook up a string to send<br>
      while(!pPar- &gt;pPair- &gt;IsProxy_ServerClosed &amp;&amp;!pPar- 
      &gt;pPair-&gt;IsUser_ProxyClosed)<br>
      {<br>
      retval = recv(conn_socket,Buffer,sizeof (Buffer),0 );<br>
      if (retval == SOCKET_ERROR ) {<br>
      fprintf(stderr,&quot;recv() failed: error %d\n&quot;,WSAGetLastError());<br>
      closesocket(conn_socket);<br>
      pPar- &gt;pPair- &gt;IsProxy_ServerClosed=TRUE;<br>
      break;<br>
      }<br>
      Len=retval;<br>
      if (retval == 0) {<br>
      printf(&quot;Server closed connection\n&quot;);<br>
      closesocket(conn_socket);<br>
      pPar- &gt;pPair- &gt;IsProxy_ServerClosed=TRUE;<br>
      break;<br>
      }<br>
      <br>
      retval = send(pPar- &gt;pPair- &gt;user_proxy,Buffer,Len,0);<br>
      if (retval == SOCKET_ERROR) {<br>
      fprintf(stderr,&quot;send() failed: error %d\n&quot;,WSAGetLastError());<br>
      closesocket(pPar- &gt;pPair- &gt;user_proxy);<br>
      pPar- &gt;pPair- &gt;IsUser_ProxyClosed=TRUE;<br>
      break; <br>
      }<br>
      #ifdef _DEBUG <br>
      Buffer[Len]=0; <br>
      printf(&quot;Received %d bytes, data [%s] from 
      server\n&quot;,retval,Buffer);<br>
      #endif<br>
      }<br>
      if(pPar- &gt;pPair- &gt;IsProxy_ServerClosed==FALSE)<br>
      {<br>
      closesocket(pPar- &gt;pPair- &gt;proxy_server);<br>
      pPar- &gt;pPair- &gt;IsProxy_ServerClosed=TRUE;<br>
      }<br>
      if(pPar- &gt;pPair- &gt;IsUser_ProxyClosed==FALSE)<br>
      {closesocket(pPar- &gt;pPair- &gt;user_proxy);<br>
      pPar- &gt;pPair- &gt;IsUser_ProxyClosed=TRUE;<br>
      }<br>
      return 1;<br>
      }<br>
      <br>
      <br>
      <br>
      int _tmain(int argc, TCHAR* argv[], TCHAR* envp[])<br>
      {<br>
      int nRetCode = 0;<br>
      <br>
      // 初始化SOCKET<br>
      if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))<br>
      {<br>
      // 错误处理<br>
      cerr &lt; &lt; _T(&quot;Fatal Error: MFC initialization failed&quot;) &lt; 
      &lt; endl;<br>
      nRetCode = 1;<br>
      }<br>
      else<br>
      {<br>
      // 主程序开始.<br>
      StartServer(); <br>
      while(1) <br>
      if(getchar()==`q`) break;<br>
      CloseServer();<br>
      }<br>
      <br>
      return nRetCode;<br>
      }
    </td>
  </tr>
  <tr>
    <td width="100%" colspan="2" align="center" valign="top">　</td>
  </tr>
</table>
</center></div>

</body>

</html>
