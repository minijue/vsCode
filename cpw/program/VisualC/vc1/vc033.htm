<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>您现在的位置是</title>
</head>

<body>

<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../../progidx.htm">编程技巧 
      </a> --&gt; <a href="../Vcidx098.htm">VC</a></b></span></td>      
  </tr>      
</table>      
</center></div><div align="center"><center>      
      
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"      
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">      
  <tr>      
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"      
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"      
    bordercolordark="#FFFFFF">      
      <tr>      
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font      
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"      
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>      
      </tr>      
    </table>      
      <p align="center">如何制作Windows自定义边框的对话框&nbsp;<br>
      <br>
               哈尔滨工程大学计算机系研(150001) 贾巍&nbsp;      
      <p><br>
      &nbsp;&nbsp;&nbsp; 在Windows应用程序中,对话框是应用最广泛也是比较难控制其风格(外表)的一类窗口。Windows 3.x所提供的传统的对话框一般都有一个单调的蓝色的边框和白色窗口背景,即使采用Borland C++所提供的BorDlg风格的对话框,用自定义控制(BWCC)来美化对话框的背景及内容,呆板的边框还是一成不变的。相信用过Windows 95的朋友在享受其强大功能的同时,一定也为它所提供的具有立体感的界面而感叹吧。事实上,在Windows 3.x中,我们也是可以作出更美观的窗口来的,中文之星2.0就是一个很好的例子。&nbsp;<br>
      <br>
      &nbsp;&nbsp;&nbsp; 要想按自己的意愿来绘制一个普通窗口或对话框的边界,一般来说有两种方法:一种是在系统绘制边框之后再在其上重新绘制一遍;另一种是彻底接管对边框的绘制权,禁止系统的干涉。前一种方法对于含有菜单的窗口较为适应,能够保证窗口始终以自定义方式出现,但是在<br>
      窗口更新时,这种方式会产生闪烁现象;第二种方式比较适应于没有菜单的窗口,更新时不会发生闪烁现象,但是如果处理不好有时系统会暂时重新获得绘制权,使得窗口以另外一种形象出现。下面作者要介绍的方法将结合使用这两种方法,以求取得较好的效果。&nbsp;<br>
      <br>
      &nbsp;&nbsp;&nbsp; 在一个窗口的边界(非用户区)需要重画时,窗口将接到消息WM_NCPAINT,通常该消息将被传送给窗口的DefWndProc函数进行缺省的处理,我们只要使应用程序处理这个消息而不是交给Windows就可以实现第二种方法。由于对话框有许多普通窗口不具有的特性,因此如果希望比较完善地控制对话框的风格,还要适当用第一种方式做辅助。作者采取的做法为每当对话框被激活时都重画一遍。&nbsp;<br>
      <br>
      &nbsp;&nbsp;&nbsp; 下面就是笔者基于以上思想而编制的一个边界有立体效果的对话框类。将该类做成通用的动态连接库就可以供其他程序使用。&nbsp;<br>
      <br>
      //以下为头文件说明&nbsp;<br>
      <br>
      #if !defined(_NEW_STYLE_DIALOG_)&nbsp;<br>
      <br>
      #define _NEW_STYLE_DIALOG_&nbsp;<br>
      <br>
      #include ＜owl.h＞&nbsp;<br>
      <br>
      extern PTModule TheModule;&nbsp;<br>
      <br>
      _CLASSDEF(TNewDialog)&nbsp;<br>
      <br>
      class TNewDialog : public TDialog {&nbsp;<br>
      <br>
      HPEN DarkGrayPen,LightGrayPen;&nbsp;<br>
      <br>
      HPEN WhitePen,BlackPen;&nbsp;<br>
      <br>
      HBRUSH LightGrayBrush,BlueBrush;&nbsp;<br>
      <br>
      HBRUSH NullBrush;&nbsp;<br>
      <br>
      void CreateDrawObject(void);&nbsp;<br>
      <br>
      public:&nbsp;<br>
      <br>
      TNewDialog(PTWindowsObject AParent, LPSTR AName, PTModule AModule = NULL)&nbsp;<br>
      <br>
      :TDialog(AParent,AName,AModule)&nbsp;<br>
      <br>
      { CreateDrawObject(); }&nbsp;<br>
      <br>
      TNewDialog(PTWindowsObject AParent, int&nbsp;<br>
      <br>
      ResourceId, PTModule AModule = NULL)&nbsp;<br>
      <br>
      :TDialog(AParent,ResourceId,AMod-ule)&nbsp;<br>
      <br>
      { CreateDrawObject(); }&nbsp;<br>
      <br>
      ～TNewDialog();&nbsp;<br>
      <br>
      virtual void WMNCPaint(RTMessage Msg)&nbsp;<br>
      <br>
      =[WM_FIRST+WM_NCPAINT];&nbsp;<br>
      <br>
      virtual void WMActivate(RTMessage Msg)&nbsp;<br>
      <br>
      =[WM_FIRST+WM_ACTIVATE];&nbsp;<br>
      <br>
      void DrawFrame(); };&nbsp;<br>
      <br>
      #endif&nbsp;<br>
      <br>
      //以下为动态连接库和类成员函数体&nbsp;<br>
      <br>
      #include "newdlg.h"&nbsp;<br>
      <br>
      PTModule TheModule;&nbsp;<br>
      <br>
      int FAR PASCAL LibMain(HINSTANCE hIn-stance, WORD , WORD , LPSTR lpCmd -Line)&nbsp;<br>
      <br>
      {&nbsp;<br>
      <br>
      int TheStatus;&nbsp;<br>
      <br>
      TheModule = new TModule("NEWDL-GDLL",hInstance, lpCmdLine);&nbsp;<br>
      <br>
      TheStatus = TheModule-＞Status;&nbsp;<br>
      <br>
      if ( TheStatus != 0 ) {&nbsp;<br>
      <br>
      delete TheModule;&nbsp;<br>
      <br>
      TheModule = NULL; }&nbsp;<br>
      <br>
      return (TheStatus == 0);&nbsp;<br>
      <br>
      }&nbsp;<br>
      <br>
      int FAR PASCAL WEP ( int /*bSystemExit*/ )&nbsp;<br>
      <br>
      {return 1;}&nbsp;<br>
      <br>
      TNewDialog::～TNewDialog()&nbsp;<br>
      <br>
      {&nbsp;<br>
      <br>
      DeleteObject(DarkGrayPen);&nbsp;<br>
      <br>
      DeleteObject(LightGrayPen);&nbsp;<br>
      <br>
      DeleteObject(WhitePen);&nbsp;<br>
      <br>
      DeleteObject(BlackPen);&nbsp;<br>
      <br>
      DeleteObject(LightGrayBrush);&nbsp;<br>
      <br>
      DeleteObject(BlueBrush);&nbsp;<br>
      <br>
      DeleteObject(NullBrush);&nbsp;<br>
      <br>
      }&nbsp;<br>
      <br>
      void TNewDialog::CreateDrawObject(void)&nbsp;<br>
      <br>
      {&nbsp;<br>
      <br>
      DarkGrayPen = (HPEN)CreatePen(&nbsp;<br>
      <br>
      PS_SOLID,1,RGB(128,128,128));&nbsp;<br>
      <br>
      LightGrayPen= (HPEN)CreatePen(&nbsp;<br>
      <br>
      PS_SOLID,1,RGB(192,192,192));&nbsp;<br>
      <br>
      WhitePen = (HPEN)GetStockObject(WHITE_PEN);&nbsp;<br>
      <br>
      BlackPen = (HPEN)GetStockObject(BLACK_PEN);&nbsp;<br>
      <br>
      LightGrayBrush = (HBRUSH)GetStockObject( LTGRAY_BRUSH);&nbsp;<br>
      <br>
      NullBrush = (HBRUSH)GetStockObject(&nbsp;<br>
      <br>
      NULL_BRUSH);&nbsp;<br>
      <br>
      LOGBRUSH lb;&nbsp;<br>
      <br>
      lb.lbStyle = BS_SOLID;&nbsp;<br>
      <br>
      lb.lbColor = RGB( 0, 0, 128);&nbsp;<br>
      <br>
      lb.lbHatch = NULL;&nbsp;<br>
      <br>
      BlueBrush = CreateBrushIndirect(&amp;lb);&nbsp;<br>
      <br>
      }&nbsp;<br>
      <br>
      void TNewDialog::WMActivate(RTMessage Msg)&nbsp;<br>
      <br>
      {&nbsp;<br>
      <br>
      if(Msg.WParam==WA_ACTIVE ||&nbsp;<br>
      <br>
      Msg.WParam==WA_CLICKACTIVE)&nbsp;<br>
      <br>
      DrawFrame();&nbsp;<br>
      <br>
      }&nbsp;<br>
      <br>
      void TNewDialog::WMNCPaint(RTMessage )&nbsp;<br>
      <br>
      { DrawFrame(); }&nbsp;<br>
      <br>
      void TNewDialog::DrawFrame()&nbsp;<br>
      <br>
      {&nbsp;<br>
      <br>
      RECT rWinRect;&nbsp;<br>
      <br>
      HDC hWinDC;&nbsp;<br>
      <br>
      LONG DLGStyle;&nbsp;<br>
      <br>
      HPEN oldPen;&nbsp;<br>
      <br>
      HBRUSH oldBrush;&nbsp;<br>
      <br>
      int r,b;&nbsp;<br>
      <br>
      hWinDC = GetWindowDC(HWindow);&nbsp;<br>
      <br>
      G etWindowRect(HWindow,&amp;rWinRect);&nbsp;<br>
      <br>
      r = rWinRect.right-rWinRect.left-1;&nbsp;<br>
      <br>
      b = rWinRect.bottom-rWinRect.top-1;&nbsp;<br>
      <br>
      oldPen = (HPEN)SelectObject(&nbsp;<br>
      <br>
      hWinDC,DarkGrayPen);&nbsp;<br>
      <br>
      oldBrush=(HBRUSH)SelectObject(&nbsp;<br>
      <br>
      hWinDC,NullBrush);&nbsp;<br>
      <br>
      Rectangle(hWinDC,0,0,r,b);&nbsp;<br>
      <br>
      SelectObject(hWinDC,BlueBrush);&nbsp;<br>
      <br>
      Rectangle(hWinDC,5,4,r-4,24);&nbsp;<br>
      <br>
      SelectObject(hWinDC,BlackPen);&nbsp;<br>
      <br>
      MoveTo(hWinDC,0,b);&nbsp;<br>
      <br>
      LineTo(hWinDC,r,b);&nbsp;<br>
      <br>
      LineTo(hWinDC,r,-1);&nbsp;<br>
      <br>
      SelectObject(hWinDC,WhitePen);&nbsp;<br>
      <br>
      MoveTo(hWinDC,1,b-2);&nbsp;<br>
      <br>
      LineTo(hWinDC,1,1);&nbsp;<br>
      <br>
      LineTo(hWinDC,r-1,1);&nbsp;<br>
      <br>
      MoveTo(hWinDC,r-5,5);&nbsp;<br>
      <br>
      LineTo(hWinDC,r-5,23);&nbsp;<br>
      <br>
      LineTo(hWinDC,4,23);&nbsp;<br>
      <br>
      SelectObject(hWinDC,LightGrayPen);&nbsp;<br>
      <br>
      SelectObject(hWinDC,NullBrush);&nbsp;<br>
      <br>
      Rectangle(hWinDC,2,2,r-1,b-1);&nbsp;<br>
      <br>
      Rectangle(hWinDC,3,3,r-2,b-2);&nbsp;<br>
      <br>
      Rectangle(hWinDC,4,4,r-3,b-3);&nbsp;<br>
      <br>
      SelectObject(hWinDC,DarkGrayPen);&nbsp;<br>
      <br>
      MoveTo(hWinDC,5,4);&nbsp;<br>
      <br>
      LineTo(hWinDC,r-4,4);&nbsp;<br>
      <br>
      DLGStyle = GetWindowLong(HWindow,&nbsp;<br>
      <br>
      GWL_STYLE);&nbsp;<br>
      <br>
      if(DLGStyle &amp; WS_SYSMENU) {&nbsp;<br>
      <br>
      SelectObject(hWinDC,LightGrayPen);&nbsp;<br>
      <br>
      SelectObject(hWinDC,LightGrayBrush);&nbsp;<br>
      <br>
      Rectangle(hWinDC,6,5,24,23);&nbsp;<br>
      <br>
      SelectObject(hWinDC,BlackPen);&nbsp;<br>
      <br>
      SelectObject(hWinDC,NullBrush);&nbsp;<br>
      <br>
      Rectangle(hWinDC,8,12,21,15);&nbsp;<br>
      <br>
      SelectObject(hWinDC,WhitePen);&nbsp;<br>
      <br>
      MoveTo(hWinDC,9,13);&nbsp;<br>
      <br>
      LineTo(hWinDC,20,13);&nbsp;<br>
      <br>
      SelectObject(hWinDC,DarkGrayPen);&nbsp;<br>
      <br>
      MoveTo(hWinDC,9,15);&nbsp;<br>
      <br>
      LineTo(hWinDC,21,15);&nbsp;<br>
      <br>
      LineTo(hWinDC,21,12);&nbsp;<br>
      <br>
      }&nbsp;<br>
      <br>
      SelectObject(hWinDC,oldPen);&nbsp;<br>
      <br>
      SelectObject(hWinDC,oldBrush);&nbsp;<br>
      <br>
      ReleaseDC(HWindow,hWinDC);&nbsp;<br>
      <br>
      }      
    </td>     
  </tr>     
</table>     
</center></div>     
<p>　</p>

</body>

</html>
