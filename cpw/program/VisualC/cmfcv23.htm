<html>

<head>
<title></title>
</head>

<body>

<table border="0" cellspacing="2" cellpadding="0" width="100%" style="font-size: 9pt">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是： <b><a href="Vc_idx.htm">Visual 
    C++/C++</a> &gt;</b> </span><font color="#000000">MFC邮递表的中文翻译-第二十三期</font></td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%" bgcolor="#E8E8E8">
      <tr>
        <td width="100%">　</td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><p align="center"><font color="#000000"><strong>MFC邮递表的中文翻译-第二十三期</strong></font></td>
  </tr>
  <tr>
    <td width="100%">　</td>
  </tr>
  <tr>
    <td width="100%">　<p><font COLOR="#FF0000">第二十三期目录</font> <font SIZE="-1">杨晓东 
    1999.1.18</font><ol>
      <li><a href="#vol23q1">怎样才能DISABLE属性工作表中的一个属性页。</a> </li>
      <li><a href="#vol23q2">建立没有一个任务按钮的程序。</a> </li>
      <li><a href="#vol23q3">DlgDirListComboBox在调试时失败，但正式版中却正常</a> </li>
      <li><a href="#vol23q5">奇怪的字符串。</a> </li>
      <li><a href="#vol23q6">字符串类中+=操作为何不能工作？</a> </li>
      <li><a href="#vol23q7">关于非模态对话框的问题。</a> </li>
      <li><a href="#vol23q8">激活属性页会挂起程序？</a> </li>
    </ol>
    <p><a name="vol23q1"></a></p>
    <font color="Red"><h3>怎样才能DISABLE属性工作表中的一个属性页。</h3>
    </font><p>问：怎样才能DISABLE属性工作表中的一个属性页。<br>
    </p>
    <p>答：DISABLE属性工作表中的一个属性页是不是一个容易的问题，你可以在http://www.microsoft.com/msj 
    中以前发表的文章中找到一篇解决的此问题的文章，你也可以从此网站上下载源代码，用来 
    作为自己的基类开发自己的类。<br>
    </p>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <p><a name="vol23q2"></a> </p>
    <font color="Red"><h3>建立没有一个任务按钮的程序。</h3>
    </font><p>问：怎样建立没有一个任务按钮的程序？<br>
    </p>
    <p>答：打开你的资源文件，删除EXSTYLE WS_EX_APPWINDOW然后重新编译。<br>
    </p>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <p><a name="vol23q3"></a> </p>
    <font color="Red"><h3>DlgDirListComboBox在调试时失败，但正式版中却正常</h3>
    </font><p>问：程序在4.1版本中编译，一切都正常，将它转换到VC6用了近5个月时间，如果我用Release 
    编译程序一切正常，但在Debug时建立DlgDirListComboBox函数出错，比如返回的值是零。<br>
    </p>
    <p>答：如果你使用一个未经初始化的指针，你代码中的指针可能会有些问题。如： 
    </p>
    <pre>void foo()
{
   char *pFoo ;
    if( !pFoo )
    {
        pFoo = new char[256] ;
    }

    *pFoo = '\0' ;
}</pre>
    <p>&nbsp;&nbsp;其中每次作为debug编译时pFoo有可能并不是空的，但在Release版本中肯定是空的，当然 
    在debug中也有可能为空，VC后来的debug版本中在堆栈中做了些工作，使得分配变量时会 
    加一些无用的值。<br>
    </p>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <p><a name="vol23q4"></a> <a name="vol23q5"></a> </p>
    <font color="Red"><h3>奇怪的字符串。</h3>
    </font><p>问：问题出在一个函数内的下面两行代码 </p>
    <pre> CString Query;
 m_BodyList.DeleteAllItems();</pre>
    <p>在变量监视窗口中发现许多CXX0069的错误消息：Error: variable needs 
    stack frame.<br>
    </p>
    <p>答：&gt;我找过内存漏洞，但没有发现。<br>
    &nbsp;&nbsp;我相信，我认为你所要访问的对象已经被删除了，所以并没有内存漏洞，但已经有了 
    非法指针，这是很难发现的。<br>
    &gt;错误提示使我想起我曾经使用过一个内联函数，直到发现根本没有必要使用就删除了<br>
    &nbsp;&nbsp;这又让我确信自己是可能是正确的<br>
    &gt;能否用一块简短的代码来重现错误。<br>
    &nbsp;&nbsp;下面的代码并不能产生CXX0069,但能说明我的想法。 </p>
    <pre>class CTest
{
public:
 CTest() {};
 UINT m_someStuffThatOccupiesSpace[1024];
 // put some data behind that that will not be overwriten
 //   by the stack that fast...
 UINT m_somethingThatSurvives;
 CString m_somethingThatCrashes;
 UINT Get();
 void Set(UINT x);
 void SetStr(CString x);
};

UINT CTest::Get()
{
 return m_somethingThatSurvives;
}
void CTest::Set(UINT x)
{
 m_somethingThatSurvives = x;
}
void CTest::SetStr(CString x)
{
 m_somethingThatCrashes.Format(x);
 // it crashes here when the CTest object is deleted
 //  because the dtor of CTest automatically deletes the
 //  CString m_somethingThatCrashes.
}

// #define __OUT_OF_SCOPE
// define the __OUT_OF_SCOPE above in for testing the &quot;out of scope&quot;
// version, comment it out for checking the access to deleted
objects

void CTestDlg::OnOK()
{
//      if (CanExit())
//              CDialog::OnOK();

 UINT test;

 CTest *pZombie;

#ifdef __OUT_OF_SCOPE
 { // the brackets are importent here!
  CTest zombie;
  zombie.Set(42);
  zombie.SetStr(&quot;works!&quot;);
  pZombie = &amp;zombie;
 // normally you must not assign the pointer to the
 // temporary zombie, but I'll do it for demonstration
 // purpose!
 } // the brackets are importent here!
 // from now on we are accessing zombie across the pointer -
 // which is ILLEGAL from here, because the original object
 // was deleted with the closing bracked of the previous block!

#else
 pZombie = new CTest;
 pZombie-&gt;Set(42);
 pZombie-&gt;SetStr(&quot;works!&quot;);
 delete pZombie;
 // further access via the pointer is illegal here
 // normally you shoud put  pZombie=NULL; after the
 // delete pZombie; but here I don't do it for demonstration
 // purpose!

#endif

 test = pZombie-&gt;Get();
 // test becomes 42 here, but zombie is DEAD here!!

 pZombie-&gt;Set(0); // that works too see here:
 test = pZombie-&gt;Get();

 // this crashes !!
 pZombie-&gt;SetStr(&quot;Access Violation!&quot;);
}</pre>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <p><a name="vol23q6"></a> </p>
    <font color="Red"><h3>字符串类中+=操作为何不能工作？</h3>
    </font><p>问：由于一些我所不了解的原因，字符串类的+=会提示出错！<br>
    </p>
    <p>答：pStream-&gt;Read()并不能在缓冲区未尾加字符串结束符'\0'，几乎所有情况下，缓冲区并 
    不是一个字符串（因为它没有字符串结束符），试一下TCHAR 
    buff[CB_READ_BLOCK+1];<br>
    </p>
    <pre>while (SUCCEEDED(pStream-&gt;Read(buff, CB_READ_BLOCK, &amp;cbRead)) &amp;&amp; cbRead &gt;0)
{
        // if the actual read was less than the read block
        // we must add a null terminator to prevent garbage
        // at the end of the string

        //**** if (cbRead <CB_READ_BLOCK) **** buff[cbRead]="\0" ; // add the buffer to the tag buffer tagbuff +="buff;" } </pre>
</pre>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <p><a name="vol23q7"></a> </p>
    <font color="Red"><h3>关于非模态对话框的问题。</h3>
    </font><pre>问：我有一个动态联接库文件，是建立使用ATL向导的。里面有一个对话框，在资源文件中，我测试
焦点以及快 键都很正常，在用它建立一个模态对话框时，一切正常，但我用它建立一个非模态
对话框时焦点切换以及热键拒绝工作。
</pre>
    <p>答：问题在于没有谁为你的非模态对话框调用IsDialogMessage()函数。在普通的MFC程序中 
    是CDialog::PreTranslateMessage()被调用。在C语言设计的WINDOWS程序中，你可以建立 
    许多全局变量包含在非模态对话框的句柄中，主消息会检查其中的每一条。解决这个问题 
    需要很长的时间，可以查一下帮助中的“非模态对话框”以及相关的文章。<br>
    </p>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <p><a name="vol23q8"></a> </p>
    <h3><font color="Red">激活属性页会挂起程序？</font></h3>
    <pre>问：我在视中建立了非模态属性工作表，里面有三个属性页分别为A，B，C。其中第三个属性页
（假设为C）又建立了一个属性工作表包含四个工作页（W，X，Y，Z）。问题是这样的：先
激活四个工作页中的一个，然后再激活B属性页，则系统会挂起！
</pre>
    <p>答：1）为子属性工作表继承OnInitDialog()并加入下面一句： </p>
    <pre>WS_EX_CONTROLPARENT style using ModifyStyleEx function.</pre>
    <pre>或在m_oCPageCSheet.Create(this,WS_CHILD | WS_BORDER |WS_VISIBLE)加入
WS_EX_CONTROLPARENT属性

&nbsp;&nbsp;2）你的数据确认程序是错误的，应该象下面的代码所做的：
</pre>
    <pre>BOOL KSatSegThreshold::OnKillActive()
{
   // DONE: Add your specialized code here and/or call the base class
   BOOL bRet = TRUE;

   if ((KSatEditor::IsSatEditorInitializing() == false) &amp;&amp;
       (SaveDlg() == false))
   {
         BOOL bRet = FALSE;
   }

   return bRet;
}

BOOL KSatSegThreshold::OnSetActive()
{
   // DONE: Add your specialized code here and/or call the base class
   BOOL bRet = TRUE;
   if ((KSatEditor::IsSatEditorInitializing() == false) &amp;&amp;
       (UpdateDlg() == false))
   {
      bRet = FALSE;
   }

   return bRet;
}</pre>
    <a href="#PageBegin"><p align="right">返回页首</a> <br>
    </p>
    <hr>
    <a href="cmfcv24.htm"><div align="center"><center><pre>前一期</a>|<a href="cmfcv22.htm">后一期</a>

<a
href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供!</pre>
    </center></div></td>
  </tr>
</table>

<p>　</p>
</body>
</html>
