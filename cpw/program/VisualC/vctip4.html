<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<meta NAME="doccomm" CONTENT="sss">
<meta NAME="Template" CONTENT="C:\MSOffice\Template\Sl_BOOK.dot">
<meta NAME="Author" CONTENT="Cheng Jinxing">
<title>Visual C++编程技巧之四</title>
</head>

<body TEXT="#000000" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"
background="../../res/back.JPG" style="font-size: 9pt">

<p align="center"><strong><font face="Arial" size="4">Visual C++</font><font size="4">编程技巧之四 
</font><font face="Arial" size="4">&nbsp; </font></strong></p>

<p align="center">转载于&quot;<a href="http://kahn.xj.cninfo.net/wwchina/"
target="_blank">程序员集中营</a>&quot;</p>

<p><a HREF="#tip25"><font SIZE="+0" FACE="Times New Roman">25</font><font SIZE="+0">、如何获取有关窗口正在处理的当前消息的信息</font></a> 
</p>

<p><a HREF="#tip26"><font SIZE="+0" FACE="Times New Roman">26</font><font SIZE="+0">、如何创建一个不规则形状的窗口</font></a> 
</p>

<p><a HREF="#tip27"><font SIZE="+0" FACE="Times New Roman">27</font><font SIZE="+0">、如何在代码中获取工具条和状态条的指针</font></a> 
</p>

<p><a HREF="#tip28"><font SIZE="+0" FACE="Times New Roman">28</font><font SIZE="+0">、如何使能和禁止工具条的工具提示</font></a> 
</p>

<p><a HREF="#tip29"><font SIZE="+0" FACE="Times New Roman">29</font><font SIZE="+0">、如何设置工具条标题</font></a> 
</p>

<p><a HREF="#tip30"><font SIZE="+0" FACE="Times New Roman">30</font><font SIZE="+0">、如何创建和使用无模式对话框</font></a> 
</p>

<p><a HREF="#tip31"><font SIZE="+0" FACE="Times New Roman">31</font><font SIZE="+0">、如何在对话框中显示一个位图</font></a> 
</p>

<p><a HREF="#tip32"><font SIZE="+0" FACE="Times New Roman">32</font><font SIZE="+0">、如何改变对话或窗体视窗的背景颜色</font></a> 
</p>

<p><font SIZE="+2"><b>　</b></font> </p>

<p><a NAME="tip25"></a><b><font SIZE="+2"><font FACE="Times New Roman">25</font><font
FACE="黑体">、如何获取有关窗口正在处理的当前消息的信息</font></font></b> 
</p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">CWnd: : GetCurrentMessage</font>可以获取一个<font
FACE="Times New Roman">MSG</font>指针。例如，可以使用</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">ClassWizard</font>将几个菜单项处理程序映射到一个函数中，然后调用<font
FACE="Times New Roman">GetCurrentMessage</font></font> </p>

<p><font SIZE="+0">来确定所选中的菜单项。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">viod CMainFrame : : OnCommmonMenuHandler ( )</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Display selected menu item in debug window .</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">TRACE (&quot;Menu item %u was selected . 
\n&quot; ,</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">GetCruuentMessage ( ) </font>―<font
FACE="Times New Roman">&gt; wParam );</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip26"></a><b><font SIZE="+2"><font FACE="Times New Roman">26</font><font
FACE="黑体">、如何创建一个不规则形状的窗口</font></font></b> </p>

<p><font SIZE="+0">可以使用新的<font FACE="Times New Roman">SDK</font>函数<font
FACE="Times New Roman">SetWindowRgn</font>。该函数将绘画和鼠标消息限定在窗口的一</font> 
</p>

<p><font SIZE="+0">个指定的区域，实际上使窗口成为指定的不规则形状。</font> 
</p>

<p><font SIZE="+0">使用<font FACE="Times New Roman">AppWizard</font>创建一个基于对的应用程序并使用资源编辑器从主对话资源中删</font> 
</p>

<p><font SIZE="+0">除所在的缺省控件、标题以及边界。</font> </p>

<p><font SIZE="+0">给对话类增加一个<font FACE="Times New Roman">CRgn</font>数据成员，以后要使用该数据成员建立窗口区域。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">Class CRoundDlg : public CDialog</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">private :</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">Crgn m_rgn : // window region</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">} ;</font> </p>

<p><font SIZE="+0">修改<font FACE="Times New Roman">OnInitDialog</font>函数建立一个椭圆区域并调用<font
FACE="Times New Roman">SetWindowRgn</font>将该区域分配给</font> </p>

<p><font SIZE="+0">窗口：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BOOL CRoundDlg : : OnInitDialog ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CDialog : : OnInitDialog ( ) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Get size of dialog .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect rcDialog ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetClientRect (rcDialog );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// Create region and assign to window .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_rgn . CreateEllipticRgn (0 , 0 , 
rcDialog.Width ( ) , rcDialog .Height ( ) );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">SetWindowRgn (GetSafeHwnd ( ) , (HRGN) m_ rgn , 
TRUE );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return TRUE ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">通过建立区域和调用<font FACE="Times New Roman">SetWindowRgn</font>，已经建立一个不规则形状的窗口，下面的例</font> 
</p>

<p><font SIZE="+0">子程序是修改<font FACE="Times New Roman">OnPaint</font>函数使窗口形状看起来象一个球形体。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">voik CRoundDlg : : OnPaint ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CPaintDC de (this) ; // device context for 
painting .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//draw ellipse with out any border</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">dc. SelecStockObject (NULL_PEN);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//get the RGB colour components of the sphere 
color</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">COLORREF color= RGB( 0 , 0 , 255);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BYTE byRed =GetRValue (color);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BYTE byGreen = GetGValue (color);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BYTE byBlue = GetBValue (color);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// get the size of the view window</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">Crect rect ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetClientRect (rect);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// get minimun number of units</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">int nUnits =min (rect.right , rect.bottom );</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//calculate he horiaontal and vertical step size</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">float fltStepHorz = (float) rect.right /nUnits ;</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">float fltStepVert = (float) rect.bottom /nUnits 
;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">int nEllipse = nUnits/3; // calculate how many 
to draw</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">int nIndex ; // current ellipse that is being 
draw</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush brush ; // bursh used for ellipse fill 
color</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush *pBrushOld; // previous brush that was 
selected into dc</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//draw ellipse , gradually moving towards 
upper-right corner</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">for (nIndex = 0 ; nIndes &lt; + nEllipse ; 
nIndes ++)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//creat solid brush</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">brush . CreatSolidBrush (RGB ( ( (nIndex *byRed 
) /nEllipse ).</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">( ( nIndex * byGreen ) /nEllipse ), ( (nIndex * 
byBlue) /nEllipse ) ) );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//select brush into dc</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pBrushOld= dc .SelectObject (&amp;brhsh);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//draw ellipse</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">dc .Ellipse ( (int) fltStepHorz * 2, (int) 
fltStepVert * nIndex ,</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">rect. right -( (int) fltStepHorz * nIndex )+ 1,</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">rect . bottom -( (int) fltStepVert * (nIndex *2) 
) +1) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//delete the brush</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">brush.DelecteObject ( );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">最后，处理<font FACE="Times New Roman">WM_NCHITTEST</font>消息，使当击打窗口的任何位置时能移动窗口。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">UINT CRoundDlg : : OnNchitTest (Cpoint point )</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Let user move window by clickign anywhere on 
the window .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">UINT nHitTest = CDialog : : OnNcHitTest (point) 
;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">rerurn (nHitTest = = HTCLIENT)? HTCAPTION: 
nHitTest ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip27"></a><b><font SIZE="+2"><font FACE="Times New Roman">27</font><font
FACE="黑体">、如何在代码中获取工具条和状态条的指针</font></font></b> </p>

<p><font SIZE="+0">缺省时， 
工作框创建状态条和工具条时将它们作为主框窗口的子窗口，状态条</font> 
</p>

<p><font SIZE="+0">有一个<font FACE="Times New Roman">AFX_IDW_STATUS_BAR</font>标识符，工具条有一个<font
FACE="Times New Roman">AFX_IDW_TOOLBAR</font>标识符，下例说</font> </p>

<p><font SIZE="+0">明了如何通过一起调用<font FACE="Times New Roman">CWnd: : 
GetDescendantWindow</font>和<font FACE="Times New Roman">AfxGetMainWnd</font>来获取这些</font> 
</p>

<p><font SIZE="+0">子窗口的指针：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Get pointer to status bar .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CStatusBar * pStatusBar =</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">(CStatusBar *) AfxGetMainWnd ( ) </font>―<font
FACE="Times New Roman">&gt; GetDescendantWindow</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">(AFX_IDW_STUTUS_BAR);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Get pointer to toolbar .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CToolBar * pToolBar =</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">(CToolBar * ) AfxGetMainWnd ( ) </font>―<font
FACE="Times New Roman">&gt; GetDescendantWindow (AFX_IDW_TOOLBAR);</font></font> </p>

<p><a NAME="tip28"></a><b><font SIZE="+2"><font FACE="Times New Roman">28</font><font
FACE="黑体">、如何使能和禁止工具条的工具提示</font></font></b> </p>

<p><font SIZE="+0">如果设置了<font FACE="Times New Roman">CBRS_TOOLTIPS</font>风格位，工具条将显示工具提示，要使能或者禁止</font> 
</p>

<p><font SIZE="+0">工具提示，需要设置或者清除该风格位。下例通过调用<font
FACE="Times New Roman">CControlBar : : GetBarStyle</font></font> </p>

<p><font SIZE="+0">和<font FACE="Times New Roman">CControlBar : : SetBarStyle</font>建立一个完成此功能的成员函数：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CMainFrame : : EnableToolTips ( BOOL 
bDisplayTips )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (m_wndToolBar);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">DWORD dwStyle = m _wndToolBar.GetBarStyle ( ) ;</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">if (bDisplayTips)</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">dwStyle </font>｜<font
FACE="Times New Roman">=CBRS_TOOLTIPS ;</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">else</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">dwStyle &amp; = ~ CBRS_TOOLTIPS ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_wndToolBar.SetBarStyle (dwStyle );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip29"></a><b><font SIZE="+2"><font FACE="Times New Roman">29</font><font
FACE="黑体">、如何设置工具条标题</font></font></b> </p>

<p><font SIZE="+0">工具条是一个窗口，所以可以在调用<font
FACE="Times New Roman">CWnd : : SetWindowText</font>来设置标题，例子如下：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">int CMainFrame : : OnCreate (LPCREATESTRUCT 
lpCreateStruct )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// Set the caption of the toolbar .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_wndToolBar.SetWindowText (_T 
&quot;Standdard&quot;);</font> </p>

<p><a NAME="tip30"></a><b><font SIZE="+2"><font FACE="Times New Roman">30</font><font
FACE="黑体">、如何创建和使用无模式对话框</font></font></b> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">MFC</font>将模式和无模式对话封装在同一个类中，但是使用无模式对话需要几</font> 
</p>

<p><font SIZE="+0">个对话需要几个额处的步骤。首先，使用资源编辑器建立对话资源并使用</font> 
</p>

<p><font SIZE="+0"><font FACE="Times New Roman">ClassWizard</font>创建一个<font
FACE="Times New Roman">CDialog</font>的派生类。模式和无模式对话的中止是不一样的：</font> 
</p>

<p><font SIZE="+0">模式对话通过调用<font FACE="Times New Roman">CDialog : : 
EndDialog </font>来中止，无模式对话则是调用</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">CWnd: : DestroyWindow</font>来中止的，函数<font
FACE="Times New Roman">CDialog : : OnOK</font>和<font FACE="Times New Roman">CDialog : : 
OnCancel</font></font> </p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">EndDialog ,</font>所以需要调用<font
FACE="Times New Roman">DestroyWindow</font>并重置无模式对话的函数。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleDialog : : OnOK ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// Retrieve and validate dialog data .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">if (! UpdateData (TRUE) )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// the UpdateData rountine will set focus to 
correct item</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">TRACEO (&quot; UpdateData failed during dialog 
termination .\n&quot;) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Call DestroyWindow instead of EndDialog .</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">DestroyWindow ( ) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleDialog : : OnCancel ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Call DestroyWindow instead of EndDialog .</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">DestroyWindow ( ) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">其次，需要正确删除表示对话的<font FACE="Times New Roman">C++</font>对象。对于模式对来说，这很容易，需要创建函数返回后即可删除<font
FACE="Times New Roman">C++</font>对象；无模式对话不是同步的，创建函数调用后立即返回，因而用户不知道何时删除<font
FACE="Times New Roman">C++</font>对象。撤销窗口时工作框调用<font
FACE="Times New Roman">CWnd : : PostNcDestroy</font>，可以重置该函数并执行清除操作，诸如删除<font
FACE="Times New Roman">this</font>指针。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleDialog : : PostNcDestroy ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// Declete the C++ object that represents this 
dialog .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">delete this ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">最后，要创建无模式对话。可以调用<font
FACE="Times New Roman">CDialog : : DoModal</font>创建一个模式对放， 
要创建一个无模式对话则要调用<font FACE="Times New Roman">CDialog: : Create</font>。下面的例子说明了应用程序是如何创建无模式对话的：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CMainFrame : : OnSampleDialog ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Allocate a modeless dialog object .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CSampleDilog * pDialog =new CSampleDialog ;</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (pDialog) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Create the modeless dialog .</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">BOOL bResult = pDialog </font>―<font
FACE="Times New Roman">&gt; Creste (IDD_IDALOG) ;</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT (bResult ) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip31"></a><b><font SIZE="+2"><font FACE="Times New Roman">31</font><font
FACE="黑体">、如何在对话框中显示一个位图</font></font></b> </p>

<p><font SIZE="+0">这要归功于<font FACE="Times New Roman">Win 32</font>先进的静态控件和<font
FACE="Times New Roman">Microsoft</font>的资源编辑器， 
在对话框中显示位图是很容易的， 
只需将图形控件拖到对话中并选择适当属性即可，用户也可以显示图标、位图以及增强型元文件。</font> 
</p>

<p><a NAME="tip32"></a><b><font SIZE="+2"><font FACE="Times New Roman">32</font><font
FACE="黑体">、如何改变对话或窗体视窗的背景颜色</font></font></b> </p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">CWinApp : : SetDialogBkColor</font>可以改变所有应用程序的背景颜色。第一个参数指定了背景颜色，第二个参数指定了文本颜色。下例将应用程序对话设置为蓝色背景和黄色文本。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">BOOL CSampleApp : : InitInstance ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//use blue dialog with yellow text .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">SetDialogBkColor (RGB (0, 0, 255 ), RGB ( 255 , 
255 , 0 ) ) ;</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">需要重画对话（或对话的子控件）时，<font
FACE="Times New Roman">Windows</font>向对话发送消息<font FACE="Times New Roman">WM_CTLCOLOR</font>，通常用户可以让<font
FACE="Times New Roman">Windows</font>选择绘画背景的刷子，也可重置该消息指定刷子。下例说明了创建一个红色背景对话的步骤。</font> 
</p>

<p><font SIZE="+0">首先，给对话基类增加一人成员变量<font
FACE="Times New Roman">CBursh :</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">class CMyFormView : public CFormView</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">private :</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush m_ brush ; // background brush</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">} ;</font> </p>

<p><font SIZE="+0">其次， 
在类的构造函数中将刷子初始化为所需要的背景颜色。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CMyFormView : : CMyFormView ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// Initialize background brush .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_brush .CreateSolidBrush (RGB ( 0, 0, 255 ) )</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">最后，使用<font FACE="Times New Roman">ClassWizard</font>处理<font
FACE="Times New Roman">WM_CTLCOLOR</font>消息并返回一个用来绘画对话背景的刷子句柄。注意：由于当重画对话控件时也要调用该函数，所以要检测<font
FACE="Times New Roman">nCtlColor</font>参量。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">HBRUSH CMyFormView : : OnCtlColor (CDC* pDC , 
CWnd*pWnd , UINT nCtlColor )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">// Determine if drawing a dialog box . If we are 
, return +handle to</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//our own background brush . Otherwise let 
windows handle it .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">if (nCtlColor = = CTLCOLOR _ DLG )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return (HBRUSH) m_brush .GetSafeHandle ( ) ;</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">return CFormView : : OnCtlColor (pDC, pWnd , 
nCtlColor );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>
</body>
</html>
