<html>

<head>
<title></title>
</head>

<body>

<table border="0" cellspacing="2" cellpadding="0" width="100%" style="font-size: 9pt">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是： <b><a href="Vc_idx.htm">Visual 
    C++/C++</a> &gt;</b> </span><font color="#000000">MFC邮递表的中文翻译-第二十期</font></td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%" bgcolor="#E8E8E8">
      <tr>
        <td width="100%"></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><p align="center"><font color="#000000"><strong>MFC邮递表的中文翻译-第二十期</strong></font></td>
  </tr>
  <tr>
    <td width="100%"></td>
  </tr>
  <tr>
    <td width="100%">　<p><font color="Red">第二十期目录</font> <font size="-1">杨晓东 
    1998.12.27</font><ol>
      <li><a href="#vol20q1">为何MDI程序中有子窗口打开时主应用程序不能关.</a> </li>
      <li><a href="#vol20q2">滚动视中LPtoDP失败</a> </li>
      <li><a href="#vol20q3">ODBC许可问题</a> </li>
      <li><a href="#vol20q4">怪异的字体</a> </li>
      <li><a href="#vol20q5">自画列表框样例</a> </li>
      <li><a href="#vol20q6">CWnd::GetMenu()的问题</a> </li>
      <li><a href="#vol20q7">用MFC制作弹出窗口</a> </li>
      <li><a href="#vol20q8">怎样取消一个弹出式菜单</a> </li>
    </ol>
    <p><a name="vol20q1"></a></p>
    <font color="Red"><h3>为何MDI程序中有子窗口打开时主应用程序不能关.</h3>
    </font><p>问:我在MDI程序中增加了一个CRichEditView文档模板,在子窗口视中我增加了下面一些代码. 
    </p>
    <pre>
StartReport (void)
{
CReportFrame   *rpt;
CReportDoc   *rptDoc;

   // First get the right document template
POSITION   pPos = theApp.GetFirstDocTemplatePosition();
theApp.GetNextDocTemplate ( pPos );
theApp.GetNextDocTemplate ( pPos );
CDocTemplate *pTemplate = theApp.GetNextDocTemplate ( pPos );

   // Verify validity
ASSERT(pTemplate != NULL);
ASSERT_KINDOF(CDocTemplate, pTemplate);

   // Create the frame
rptDoc = new CReportDoc;
rpt = (CReportFrame*)pTemplate-&gt;CreateNewFrame ( rptDoc, NULL );
pTemplate-&gt;InitialUpdateFrame (rpt, rptDoc);

   // Get access to the display area
CReportView   *rptView = static_cast<CReportView*>(rpt-&gt;GetActiveView());
CRichEditCtrl   &amp;rptCtrl = rptView-&gt;GetRichEditCtrl();
}</pre>
    <p>CReportFrame继承于CMDIChildWnd<br>
    CReportDoc继承于CRichEditDoc<br>
    CReportView继承于from CRichEditView<br>
    &nbsp;&nbsp;如果我关闭程序前不关闭新建的视,调试器将认为程序依然在运行(程序管理器中依然存在) 
    我需要用调试菜单中的stop debugging来关闭程序;如果我手工关闭该视,程序将会正常 
    关闭.如果有什么不同的话,在手工关闭新的视之前程序会询问是否保存. 
    那么怎样我才能关闭程序呢?<br>
    </p>
    <p>答:1)我也碰上过对话框,窗口不能自动关闭的情况,这主要是因为继承的对象不正确所造成的。 
    通常应该在主程序中设置AfxGetMainWnd().<br>
    &nbsp;&nbsp;你的程序让我搞糊涂了,一连使用了多个GetNextDocTemplate(pPos),在这些文档指针是NULL时 
    通常会引起一些循环.在你的文档模板中是否已经精心算好了数目?这样可能会产生些bugs 
    我建议找出当前的文档模板用CDocTemplate::CreateNewDocument()来代替你的&quot;new 
    CReportDoc&quot;<br>
    &nbsp;&nbsp;2) 记住一个公共规则,关闭程序前要关闭所有的视.<br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q2"></a> <font color="Red"></p>
    <h3>滚动视中LPtoDP失败</h3>
    </font><p>问：在WINDOWS98/95中,当你给光标指针位置大于32767或者小于-21768函数CDC::LPtoDP 
    将失败,程序工作在NT上但在95/98中用滚动视工作时却出现了问题. 
    LPtoDP是在下面函数中被调用的： </p>
    <pre>      SetScrollSizes(MM_HIMETRIC, sizeTotal);</pre>
    <p>函数是在CScrollView中调用的．我使用的是HIMETRIC映射方式，在我想将A4扩大150%时 
    这个问题就会出现。怎样才能解决这个问题？<br>
    </p>
    <p>答：1)在95中确实存在这样的问题,95中的GDI不是32位的.当我们开发一个程序有编辑 
    矢量图象时手动而不是由LPtoDP()函数来完成转换.(在NT中也存在同样的问题)<br>
    &nbsp;&nbsp;2)简言之,CScrollView或CWnd之所以32位参数会失败是因为95/98并不是真正的32 
    位操作系统,里面仍然包含16位代码.比如Scrollbars还是只接受16位的值来调整范围. 
    NT是一个真正的32位操作系统,就没有这些困惑.<br>
    &nbsp;&nbsp;在95中不得不面对类似的滚动大文档的问题时,我们只能另外写些代码来实现滚动的 
    实际位置,当它超出-32K或+32K时,你也必须在你的应用中做些映射.<br>
    &nbsp;&nbsp;作为一个有关的注意点(可能你已经碰上过这个问题)如果在MFC处理滚动消息时,如: 
    void CSomeWnd::OnVScroll (UINT nSBCode,UINT nPos, CScrollBar *pscrollBar) 中的 nPos参数只有16位长.克服这个限制可以使用SCROOLINFO结构运行::GetScrollInfo.SCROLLINFO 
    结构中的nTrackPos是一个真正的32位。<br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q3"></a> <font color="Red"></p>
    <h3>ODBC许可问题</h3>
    </font><p>问:我有个程序想通过ODBC来使用一个MS Access数据库,但是却碰上了错误,系统显示 
    &quot;Records can't be read; no read permission on table SESSION&quot;.(记录不能读, 
    表单不允许读)<br>
    </p>
    <p>答:001)首先我假设access数据库有一个缺省的用户为&quot;admin&quot;,可以这样完成&quot;ODBC;UID=admin&quot;. 
    然后,当你继承CRecordset类时你就不必带参数打开,但下面的方法可能更好些: 
    </p>
    <pre>Open(CRecordset::dynaset,  NULL,CRecordset::useBookmarks | CRecordset::skipDeletedRecords)</pre>
    <p>&nbsp;&nbsp;当然你必须提供DSN表示连接名字的数据库在ODBC之下.<br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q4"></a> <font color="Red"></p>
    <h3>怪异的字体</h3>
    </font><p>问:我们有一个MFC应用程序,主窗口是在客户区域内画些文本和图形. 
    我们希望能在客户区域内显示文本,在不需要时则擦除.所以我们先得到一个DC(CClientDC), 
    然后设置字体和文本颜色就开始写文本,在擦除时,我们用同样的字体,同样的地方用背景色 
    重写文本.<br>
    &nbsp;&nbsp;这种方法绝大部分情况下都工作得很好,但偶尔文本并不能完全擦除,有些像素点依然可见. 
    好象在写文本时比通常略微胖了些,就象用粗体一样.字体是在写文本时使用的,以后也没有 
    进行过任何的调整. 下面是我们使用的写与擦除的函数. </p>
    <pre>void CSign::DrawSignName(CDC* pDC)
{
 int OldBkMode;

 // select the appropriate font
 CFont* pOldFont = (CFont*) pDC-&gt;SelectObject(pSignNameFont);

 OldBkMode = pDC-&gt;SetBkMode(TRANSPARENT);

 // determine the colour of the text
 if (IsSignNameVisible())
  pDC-&gt;SetTextColor(aColours[SIGN_NAME_COLOUR]);
 else
  pDC-&gt;SetTextColor(aColours[DEVICE_INVISIBLE_COLOUR]);

 // draw the text
 pDC-&gt;TextOut(m_pointNameCoords.x, m_pointNameCoords.y, m_strName);

 // restore the previously used font and background mode
 pDC-&gt;SelectObject(pOldFont);
 pDC-&gt;SetBkMode(OldBkMode);

} // DrawSignName</pre>
    <p>&nbsp;&nbsp;函数是在消息句柄中调用的,而参数中的DC是这样建立的: </p>
    <pre>CClientDC dc(AfxGetMainWnd()).</pre>
    <p>&nbsp;&nbsp;字体是在程序初始化时建立的: </p>
    <pre> pSignNameFont = new CFont;
 pSignNameFont-&gt;CreateFont(10,5,0,0,150,
       FALSE,FALSE,0,
       ANSI_CHARSET, OUT_DEFAULT_PRECIS,
       CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
       DEFAULT_PITCH | FF_SWISS, &quot;Helvetica&quot;);</pre>
    <p>&nbsp;&nbsp;是不是一次使用两个指向同一个客户窗口的DC有问题？程序中的DrawSignName()被多个消息句柄 
    调用。<br>
    </p>
    <p>答：1）加入以下代码： </p>
    <pre>{
m_strName.Empty();
Invalidate();
UpdateWindow();
more stuff;;;
}</pre>
    <p>&nbsp;&nbsp;上面代码会产生一个WM_ERASEBKGND消息，将会用背景色填满窗口，然后再调用OnDraw()， 
    这时只要将字符串置空即可。<br>
    &nbsp;&nbsp;2）我不清楚为什么程序不能正常工作，但我有个主意（它会更快些）可以在显示文本 
    的地方用一个背景色的矩形画一下即可。我也不清楚为什么你们为什么要用透明文本， 
    它将会给图形系统带来大量的工作。字体之所以有这种情况，是否你们安装了文本输出 
    的图形保真软件？它会给你们带来困惑的。<br>
    &nbsp;&nbsp;3）你只想简单的用一个指针来保存一个指向DC的GDI对象，并试图再次调用它时期望它能 
    指向正确的对象。恕我直言，这不是正确的方法（我不知道是否这是显示不正常的唯一原 
    因）将它转化为一个Windows句柄才是正确的： </p>
    <pre>//
// Creating:
//
pSignNameFont = new CFont;
pSignNameFont-&gt;CreateFont(10,5,0,0,150,
        FALSE,FALSE,0,
        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        DEFAULT_PITCH | FF_SWISS, &quot;Helvetica&quot;);
// Now converting into a windows handle
m_hSNFont = (HFONT) pSignNameFont-&gt;GetSafeHandle();</pre>
    <p>&nbsp;&nbsp;直接保存一个对象是不安全的。<br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q5"></a> <font color="Red"></p>
    <h3>自画列表框样例</h3>
    </font><p>问：很久以前，有人散发关于自画列表框控件代码，而自画列表框外观就象一个 
    标准列表框，在那时我就有个想法想把程序员开发的所有自画控件的代码惧收集起 
    来，这样程序员们就可以使用现存的代码了。<br>
    &nbsp;&nbsp;我想问一下在1996年关于MFC站点那儿有才能关于列表框或其它控件的代码？<br>
    </p>
    <p>答：1）自画列表框代码如下，看看是不是你所想要的。 </p>
    <pre>Header file

class CCustomListBox : public CListBox
{
public:
// Operations
    DECLARE_DYNCREATE(CCustomListBox)
    int AddLBItem(LPSTR);
    void HandleSelectionState(LPDRAWITEMSTRUCT lpdis);
    void HandleFocusState(LPDRAWITEMSTRUCT lpdis);
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
};

cpp file

IMPLEMENT_DYNCREATE(CCustomListBox, CListBox)

int CCustomListBox::AddLBItem(LPSTR itemStr)
{
    AddString((LPCSTR)itemStr);
    return 0;
}

void CCustomListBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    CDC* pDC = CDC::FromHandle(lpDIS-&gt;hDC);

    if ((lpDIS-&gt;itemState &amp; ODS_SELECTED) &amp;&amp;
        (lpDIS-&gt;itemAction &amp; (ODA_SELECT | ODA_DRAWENTIRE)))
    {
        pDC-&gt;InvertRect(&amp;lpDIS-&gt;rcItem);
        pDC-&gt;DrawFocusRect(&amp;lpDIS-&gt;rcItem);
    }

    if (!(lpDIS-&gt;itemState &amp; ODS_SELECTED) &amp;&amp;
        (lpDIS-&gt;itemAction &amp; ODA_SELECT))
    {
        pDC-&gt;InvertRect(&amp;lpDIS-&gt;rcItem);
        pDC-&gt;DrawFocusRect(&amp;lpDIS-&gt;rcItem);
    }
}

void CCustomListBox::HandleSelectionState(LPDRAWITEMSTRUCT lpdis)
{
// Ordinarily could check for &quot;if (lpdis-&gt;itemState &amp; ODS_SELECTED)&quot;
// and do drawing for selected state, &quot;else&quot; draw non-selected state.
// But second call to InvertRect restores rectangle to original
// state, so will just call function whether selected or unselected.

    ::InvertRect (lpdis-&gt;hDC, (LPRECT)&amp;lpdis-&gt;rcItem);
}

void CCustomListBox::HandleFocusState(LPDRAWITEMSTRUCT lpdis)
{
// Ordinarily would check for &quot;if (lpdis-&gt;itemState &amp; ODS_FOCUS)&quot;
// and do drawing for focus state, &quot;else&quot; draw non-focus state.
// But second call to DrawFocusRect restores rectangle to original
// state, so will just call function whether focus or non-focus.
// New to Windows 3.0, this function draws a black dashed-rect
// border on the border of the specified rectangle

    ::DrawFocusRect( lpdis-&gt;hDC, (LPRECT) &amp;lpdis-&gt;rcItem );
}</pre>
    <p>2）<a href="http://toronto.planeteer.com/~zalmoxe/">http://toronto.planeteer.com/~zalmoxe/</a><br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q6"></a> <font color="Red"></p>
    <h3>CWnd::GetMenu()的问题</h3>
    </font><p>问：我有个程序用下面代码：<br>
    </p>
    <pre>    CWnd *pWnd = CWnd::GeForegroundWindow();
    if (pWnd == NULL) return FALSE;
    CMenu *pMenu = pWnd-&gt;GetMenu();
    if (pMenu == NULL) return FALSE;
    for (int i = 0; i <pMenu->GetMenuItemCount; i++) {
      pMenu-&gt;GetMenuItemID(...);
      pMenu-&gt;GetMenuString(...);
    }</pre>
    <p>&nbsp;&nbsp;上述代码工作除了在IE窗口外，别的窗口工作都很正常，请问怎样才能在IE窗口中 
    正常使用，如果不是用这种方法，那又该用什么方法？<br>
    </p>
    <p>答：IE有一个定义菜单，是用自定义系列控件中的弹出菜单。所以你就不能再使用枚举这 
    种方法了，试一下处理WM_INITMENUPOPUP或WM_INITMENU。在VC的CD中有类似的例子（关于 
    剪切与复制）你得到消息句柄时就可以列出所有的菜单项。上面的代码之所不工作可能是 
    因为微软的自画菜单项的保存菜单项用了不同的格式，想要明白菜单和画标是否是自画的， 
    你可以用这种方法测试lpmii-&gt;fType &amp; MFT_OWNERDRAW.Ipmii是一个菜单结构，返回得到 
    的菜单项信息。lpmii-&gt;dwTypeData 返回（菜单）项目的类型，如果dwTypeData返回的值没有什么 
    用的话还有一个机会，lpmii-&gt;dwItemData将指向一个（程序）开始时的菜单项中的字符串 
    结构。以上方法比较好，因为现在好多程序都使用自定义菜单。<br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q7"></a> <font color="Red"></p>
    <h3>用MFC制作弹出窗口</h3>
    </font><p>问：我正在试着用MFC来制作弹出窗口，我看过一些关于建立弹出窗口的文章，它们是使用 
    CWnd对象的。但在文档，视窗结构中是怎样实现的？<br>
    </p>
    <p>答：你可以建立一个非模态对话框（使用Create函数），你可以在任何建立窗口，子窗口等。 
    如果你一定要在文档、视窗结构中实现，你也可以用CCreateContest类。 
    下面是建立MDI窗口的例子：<br>
    </p>
    <pre>{
    LPCTSTR lpszClassName = NULL;
    CCreateContext cContext;

    cContext.m_pNewViewClass =  RUNTIME_CLASS ( CMyView )

    DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW &amp;
~WS_THICKFRAME &amp; ~WS_MAXIMIZEBOX;

    // TODO: Add your specialized code here and/or call the base class

    if ( CMDIChildWnd::Create(lpszClassName, lpszWindowName, dwStyle,
pParentWnd-&gt;rectDefault, pParentWnd, &amp;cContext) )
    {
        InitialUpdateFrame ( NULL, TRUE );
        CScrollView *pView = ( CScrollView* ) GetActiveView();

        if ( pView )
            pView-&gt;ResizeParentToFit ( FALSE );

        return TRUE;
    }
    else
        return FALSE;
}</pre>
    <p>&nbsp;&nbsp;CCreateContext有一个成员为m_pCurrentDoc，你可以用它来将一个文档分配到相应的窗口上.<br>
    <a href="#v20home"></p>
    <p align="right">返回本期目录</a></p>
    <p><a name="vol20q8"></a> <font color="Red"></p>
    <h3>怎样取消一个弹出式菜单</h3>
    </font><p>问：我有一个应用程序不显示窗口（建立窗口时使用了SW_HIDE参数），它只在任务条显示 
    一个图标，我是这样做的： </p>
    <pre>        NOTIFYICONDATA tnid;

        tnid.cbSize = sizeof(NOTIFYICONDATA);
        tnid.hWnd = m_hWnd;
        tnid.uID = 1;
        tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
        tnid.uCallbackMessage = MYWM_NOTIFYICON;
        tnid.hIcon = AfxGetApp()-&gt;LoadIcon( IDI_ICON1 );
        lstrcpyn(tnid.szTip, &quot;Giroimag Image Mail Exchange&quot;, strlen(&quot;Giroimag Image Mail Exchange&quot;)+1);

        Shell_NotifyIcon(NIM_ADD, &amp;tnid);</pre>
    <p>&nbsp;&nbsp;当我点击任务条时，程序会显示一个弹出菜单： </p>
    <pre>        CMenu m_Menu;

        m_Menu.CreatePopupMenu();

        m_Menu.AppendMenu( MF_STRING, IDM_ABOUT, &quot;Op&amp;1&quot; );
        m_Menu.AppendMenu( MF_SEPARATOR, 0 );
        m_Menu.AppendMenu( MF_STRING, IDM_CONFIG, &quot;Op&amp;2&quot; );
        m_Menu.AppendMenu( MF_STRING, IDM_STATUS, &quot;&quot;Op&amp;3&quot; );
        m_Menu.AppendMenu( MF_SEPARATOR, 0 );
        m_Menu.AppendMenu( MF_STRING, IDM_SEND, &quot;Op&amp;4&quot; );
        m_Menu.AppendMenu( MF_STRING, IDM_RECEIVE, &quot;Op&amp;5&quot; );
        m_Menu.AppendMenu( MF_SEPARATOR, 0 );
        m_Menu.AppendMenu( MF_STRING, IDM_CLOSE, &quot;Op&amp;6&quot; );

        POINT p;
        GetCursorPos( &amp; p );

        m_Menu.TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, p.x, p.y, this );</pre>
    <p>&nbsp;&nbsp;到这为止，程序运行很正常，问题在于如果我不选择任何菜单该怎样取消它？我以为按ESC或者 
    在菜单外面点击就可以取消，但事实并不是这样。我也试过用WIN32API中的TrackPopupMenuEx函数 
    但没有用，到底我该怎么做？<br>
    </p>
    <p>答：1）最简单的方法在消息映象中加&quot;Cancel Menu&quot;命令即可。<br>
    &nbsp;&nbsp;2）尽管你的主窗口不可见，但在你可以在调用m_Menu.TrackPopupMenu();时将其置为最前。<br>
    &nbsp;&nbsp;3）在你弹出菜单之前，设置你的窗口为最前窗口，调用下面的代码，问题就会迎刃而解。 
    </p>
    <pre>POINT p;
GetCursorPos( &amp; p );

// Increase the thread priority by invoking SetForegroundWindow.
SetForegroundWindow();

m_Menu.TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, p.x, p.y, this );</pre>
    <p>&nbsp;&nbsp;4）调用TrackPopupMenu()之前，你必须先调用SetForegroundWindow( 
    m_hWnd )，然后 调用PostMessage( m_hWnd, WM_NULL, 0, 0 )：<br>
    </p>
    <pre>         POINT point;
         GetCursorPos( &amp;point );
         SetForegroundWindow( m_hWnd );
         TrackPopupMenu( hPopup,
            TPM_RIGHTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
            point.x,
            point.y,
            0,
            m_hWnd, 0 );
         PostMessage( m_hWnd, WM_NULL, 0, 0 );
</pre>
    <a href="#v20home"><p align="right">返回本期目录</a></p>
    <hr>
    <a href="cmfcv21.htm"><p align="center">前一期</a>|<a href="cmfcv19.htm">后一期</a><br>
    <a href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供! 
    </td>
  </tr>
</table>

<p><a name="V20HOME"></a></p>
</body>
</html>
