<html>

<head>
<title></title>
</head>

<body>

<table border="0" cellspacing="2" cellpadding="0" width="100%" style="font-size: 9pt">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是： <b><a href="Vc_idx.htm">Visual 
    C++/C++</a> &gt;</b> </span><font color="#000000">MFC邮递表的中文翻译-第十四期</font></td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%" bgcolor="#E8E8E8">
      <tr>
        <td width="100%"></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><p align="center"><font color="#000000"><strong>MFC邮递表的中文翻译-第十四期</strong></font></td>
  </tr>
  <tr>
    <td width="100%"></td>
  </tr>
  <tr>
    <td width="100%">　<h3><font COLOR="#FF0000">第十四期目录</font> <font SIZE="-1">Yu 
    Hail 1998.11.19</font></h3>
    <ol>
      <li><a HREF="#vol14q1">CDC中的竖排文本?</a> </li>
      <li><a HREF="#vol14q2">如何激活变灰的弹出菜单?</a> </li>
      <li><a HREF="#vol14q3">线程消息?</a> </li>
      <li><a HREF="#vol14q4">TreeCtrl控制的显示速度太慢?</a> </li>
    </ol>
    <p><a NAME="vol14q1"></a></p>
    <p><br>
    </p>
    <h3><font COLOR="#FF0000">Q:CDC中的竖排文本?</font></h3>
    <p><br>
    在OnDraw成员函数中我想让文本竖直对齐,但CDC类似乎不支持该处理<br>
    A:如果你的竖直对齐是指旋转文本的话,下面的代码会对你有帮助: 
    该代码检查一个Check box控制,查看文本是否需要旋转.<br>
    </p>
    <pre>
// m_pcfYTitle is a CFont* to the selected font.
// m_bTotateYTitle is a bool (==TRUE if  rotated)

void CPage1::OnRotateytitle()
{
LOGFONT lgf;
m_pcfYTitle-&gt;GetLogFont(&amp;lgf);
m_bRotateYTitle=
        ((CButton*)GetDlgItem(IDC_ROTATEYTITLE))-&gt;GetCheck()&gt;0;

// escapement is reckoned clockwise in 1/10ths of a degree:
lgf.lfEscapement=-(m_bRotateYTitle*900);
m_pcfYTitle-&gt;DeleteObject();

m_pcfYTitle-&gt;CreateFontIndirect(&amp;lgf);
DrawSampleChart();
}
注意如果你从CFontDialog中选择了不同的字体,你应该自己设定LOGFONT的

lfEscapement成员.将初始化后的lfEscapement值传到CFontDialog中.
</pre>
    <p>A2:还有一段代码可参考: </p>
    <pre>
LOGFONT  LocalLogFont;

strcpy(LocalLogFont.lfFaceName, TypeFace);

LocalLogFont.lfWeight = fWeight;
LocalLogFont.lfEscapement = Orient;
LocalLogFont.lfOrientation  = Orient;

if (MyFont.CreateFontIndirect(&amp;LocalLogFont))
   {
   cMyOldFont = cdc-&gt;SelectObject(&amp;MyFont);
   }
</pre>
    <p><a NAME="vol14q2"></a><br>
    </p>
    <h3><font COLOR="#FF0000">Q:如何激活变灰的弹出菜单?</font></h3>
    <p><br>
    在设计菜单时设定为GRAYED的菜单项,如何在运行时激活它?<br>
    A:请看下面的示例代码:<br>
    </p>
    <pre>
void CMyView::OnRButtonDown(UINT nFlags, CPoint point)
{
 CScrollView::OnRButtonDown(nFlags, point);

 CMenu *menu, *popup;
 menu = new CMenu();

 // load menu from resource file
 menu-&gt;LoadMenu( IDR_POPUPMENU );
 popup = menu-&gt;GetSubMenu(0);  // item 0 is DUMMY

 UINT nEnable;
 nEnable = MF_BYCOMMAND|MF_GRAYED;

 if( your test )
 {
  nEnable = MF_BYCOMMAND|MF_ENABLED;
 }

 popup-&gt;EnableMenuItem( ID_YOUR_ID, nEnable );

 //display menu
 ClientToScreen(&amp;point);
 popup-&gt;TrackPopupMenu(
   TPM_LEFTALIGN | TPM_RIGHTBUTTON,
   point.x, point.y, this );
 delete menu;
}
</pre>
    <p><a NAME="vol14q3"></a><br>
    </p>
    <h3><font COLOR="#FF0000">Q:线程消息?</font></h3>
    <p><br>
    如何正确地在线程之间传送消息?<br>
    A:下面的代码将会帮你的忙:<br>
    </p>
    <pre>
void CThread::OnUserOpen( WPARAM wParm, LPARAM lParm )
{
    UNUSED( wParm ) ;
    UNUSED( lParm ) ;
    AfxMessageBox(&quot;User Open&quot;, MB_OK|MB_ICONEXCLAMATION);
}

当然,也别忘了以下声明:

class CThread : public CWinThread
{
     DECLARE_DYNCREATE(CThread)
protected:
     CThread();           // protected constructor used by dynamic creation
     afx_msg void OnUserOpen( WPARAM wParm, LPARAM lParm );
</pre>
    <p><a NAME="vol14q4"></a></p>
    <p><br>
    </p>
    <h3><font COLOR="#FF0000">Q:TreeCtrl控制的显示速度太慢?</font></h3>
    <p><br>
    我从CTreeCtrl继承了一个TREE控制类,重载主要是为了改写每个节点的文本.我在 
    OnPaint函数中写了一些代码,但这严重地影响了TREE控制的滚动速度.<br>
    A:<em>OnPaint函数</em><br>
    1.可见节点,对于GetFirstVisibleItem和GetNextVisibleItem来讲,是:<br>
    &nbsp;&nbsp;a.根节点;b.父节点已展开的节点;<br>
    因此,&quot;可见&quot;意味着&quot;没有被未展开的父节点隐藏&quot;.当节点滚动到客户外时,它对上述两 
    个函数来讲仍是可见的.<br>
    2.当TREE的内容改变时,它默认只将变为可见的节点重绘.另外其它已经是可见的节点 
    没有必要重绘,TREE只是滚动DC的位图而已.<br>
    上面的意思是不要绘制你不需要看的节点,那会导致速度降低.建议,测试节点矩形是否 
    在客户区,使得只有需要绘制的节点才会被绘制. </p>
    <pre>
void CIndentTree::OnPaint()
{
   CPaintDC dc(this); // device context for painting

   HTREEITEM hItem = NULL;

   DRAWITEMSTRUCT dis;
   CRect rc;

   // redraw only visible items with indentation
   for(
      hItem = GetFirstVisibleItem();
      hItem; hItem = GetNextVisibleItem( hItem ) )
   {
      if( !GetItemRect( hItem, rc, FALSE ) )
         continue;

      if( rc.top <= dc.m_ps.rcPaint.bottom && rc.bottom> dc.m_ps.rcPaint.top &amp;&amp;=20
         rc.left <= dc.m_ps.rcPaint.right && rc.right> dc.m_ps.rcPaint.left )
      {
         dis.hwndItem = (HWND)hItem;
         dis.rcItem = rc;
         OnDrawItem(0, &amp;dis, &amp;dc);
      }
   }
}
</pre>
    <em><p>OnDrawItem函数</em><br>
    1.删掉如下代码:<br>
    </p>
    <pre>
      IMAGEINFO* pinfo = new IMAGEINFO;
      ...
      delete pinfo;
</pre>
    <p>没有必要使用动态的IMAGEINFO变量,你可以将其定义为堆栈变量.<br>
    2.GetItemState和GetItemText都是使用的GetItem,因此,你只需调用一次, 
    就可以从节点获得你要的所有信息. </p>
    <hr>
    <a href="cmfcv15.htm"><p align="center">前一期</a>|<a href="cmfcv13.htm">后一期</a><br>
    <a href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供! 
    </td>
  </tr>
</table>
</body>
</html>
