<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<meta NAME="doccomm" CONTENT="sss">
<meta NAME="Template" CONTENT="C:\MSOffice\Template\Sl_BOOK.dot">
<meta NAME="Author" CONTENT="Cheng Jinxing">
<title>Visual C++编程技巧之六</title>
</head>

<body TEXT="#000000" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000"
background="../../res/back.JPG" style="font-size: 9pt">

<p align="center"><strong><font face="Arial" size="4">Visual C++</font><font size="4">编程技巧之六 
</font><font face="Arial" size="4">&nbsp; </font></strong></p>

<p align="center">转载于&quot;<a href="http://kahn.xj.cninfo.net/wwchina/"
target="_blank">程序员集中营</a>&quot;</p>

<p><a HREF="#tip41"><font SIZE="+0" FACE="Times New Roman">41</font><font SIZE="+0">、如何一个创建三态下压按钮</font></a> 
</p>

<p><a HREF="#tip42"><font SIZE="+0" FACE="Times New Roman">42</font><font SIZE="+0">、如何动态创建控件</font></a> 
</p>

<p><a HREF="#tip43"><font SIZE="+0" FACE="Times New Roman">43</font><font SIZE="+0">、如何限制编辑框中的准许字符</font></a> 
</p>

<p><a HREF="#tip44"><font SIZE="+0" FACE="Times New Roman">44</font><font SIZE="+0">、如何改变控件的颜色</font></a> 
</p>

<p><a HREF="#tip45"><font SIZE="+0" FACE="Times New Roman">45</font><font SIZE="+0">、当向列表框中添加多个项时如何防止闪烁</font></a> 
</p>

<p><a HREF="#tip46"><font SIZE="+0" FACE="Times New Roman">46</font><font SIZE="+0">、如何向编辑控件中添加文本</font></a> 
</p>

<p><a HREF="#tip47"><font SIZE="+0" FACE="Times New Roman">47</font><font SIZE="+0">、如何访问预定义的</font><font
SIZE="+0" FACE="Times New Roman">GDI</font><font SIZE="+0">对象</font></a> </p>

<p><a HREF="#tip48"><font SIZE="+0" FACE="Times New Roman">48</font><font SIZE="+0">、如何获取</font><font
SIZE="+0" FACE="Times New Roman">GDI</font><font SIZE="+0">对象的属性信息</font></a> 
</p>

<p><font SIZE="+2"><b>　　</b></font> </p>

<p><a NAME="tip41"></a><b><font SIZE="+2"><font FACE="Times New Roman">41</font><font
FACE="黑体">、如何一个创建三态下压按钮</font></font></b> </p>

<p><font SIZE="+0">可以使用新的<font FACE="Times New Roman">BS_PUSHBUTTON </font>风格位和检测框以及按钮来创建一个三态下压按钮。这很容易，只需将检测框和按钮拖拉到对话中并指定属性<font
FACE="Times New Roman">Push</font>―<font FACE="Times New Roman">like</font>即可。不用任何附加程序就可以成为三态下压按钮。</font> 
</p>

<p><a NAME="tip42"></a><b><font SIZE="+2"><font FACE="Times New Roman">42</font><font
FACE="黑体">、如何动态创建控件</font></font></b> </p>

<p><font SIZE="+0">分配一个控件对象的实例并调用其<font
FACE="Times New Roman">Create</font>成员函数。开发者最容易忽略两件事：忘记指定<font
FACE="Times New Roman">WS_VISBLE</font>标签和在栈中分配控件对象。下例动态地创建一个下压按钮控件：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//In class declaration (.H file ).</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">private :</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CButton* m _pButton ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//In class implementation (.cpp file ) .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_pButton =new CButton ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ASSERT_VALID (m_pButton);</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">m_pButton </font>―<font
FACE="Times New Roman">&gt;Create (_T (&quot;Button Title &quot;) , WS_CHILD </font>｜<font
FACE="Times New Roman">WS_VISIBLE </font>｜<font FACE="Times New Roman">BS_PUSHBUTTON.</font></font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">Crect ( 0, 0, 100 , 24) , this , IDC _MYBUTTON )</font> 
</p>

<p><a NAME="tip43"></a><b><font SIZE="+2"><font FACE="Times New Roman">43</font><font
FACE="黑体">、如何限制编辑框中的准许字符</font></font></b> </p>

<p><font SIZE="+0">如果用户在编辑控件中只允许接收数字，可以使用一个标准的编辑控件并指定新的创建标志<font
FACE="Times New Roman">ES_NUMBERS,</font>它是<font FACE="Times New Roman">Windows 95</font>新增加的标志，该标志限制 
编辑控件只按收数字字符。如果用户需要复杂的编辑控件，可以使用<font
FACE="Times New Roman">Microsoft </font>的屏蔽编辑控件，它是一个很有用的<font
FACE="Times New Roman">OLE</font>定制控件。</font> </p>

<p><font SIZE="+0">如果希望不使用<font FACE="Times New Roman">OLE </font>定制控件自己处理字符，可以派生一个<font
FACE="Times New Roman">CEdit </font>类并处理<font FACE="Times New Roman">WM_CHAR</font>消息，然后从编辑控件中过滤出特定的字符。首先，使用<font
FACE="Times New Roman">ClassWizard </font>建立一个 <font FACE="Times New Roman">CEdit</font>的派生类，其次，在对话类中指定一个成员变量将编辑控件分类在<font
FACE="Times New Roman">OnInitdialog </font>中调用<font FACE="Times New Roman">CWnd: : 
SubclassDlgItem .</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//In your dialog class declaration (.H file )</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">private :</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CMyEdit m_wndEdit ; // Instance of your new edit 
control .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//In you dialog class implementation (.CPP file 
)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BOOL CSampleDialog : : OnInitDialog ( )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Subclass the edit lontrod .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_wndEdit .SubclassDlgItem (IDC_EDIT,this );</font> 
</p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">使用<font FACE="Times New Roman">ClassWizard</font>处理<font
FACE="Times New Roman">WM_CHAR</font>消息，计算<font FACE="Times New Roman">nChar</font>参量并决定所执行的操作，用户可以确定是否修改、传送字符。下例说明了如何显示字母字符，如果字符是字母字符，则调用<font
FACE="Times New Roman">CWnd ; OnChar</font>，否则不调用<font FACE="Times New Roman">OnChar.</font></font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Only display alphabetic dharacters .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CMyEdit : : OnChar (UINT nChar , UINT 
nRepCnt , UITN nFlags )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Determine if nChar is an alphabetic character 
.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">if (: : IsCharAlpha ( ( TCHAR) nChar ) )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CEdit : : OnChar (nChar, nRepCnt , nFlags );</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">如果要修改字符，则不能仅仅简单地用修改过的<font
FACE="Times New Roman">nChar</font>调用<font FACE="Times New Roman">CEdit : : OnChar</font>，然后<font
FACE="Times New Roman">CEdit: : OnChar</font>调用<font FACE="Times New Roman">CWnd: : 
Default</font>获取原来的<font FACE="Times New Roman">wParam </font>和<font
FACE="Times New Roman">lParam </font>的值 
，这样是不行的。要修改一个字符，需要首先修改<font
FACE="Times New Roman">nChar</font>，然后用修改过的<font FACE="Times New Roman">nChar</font>调用<font
FACE="Times New Roman">CWnd: : DefWindowProc</font>。下例说明了如何将字符转变为大写：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Make all characters uppercase</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CMyEdit : : OnChar (UINT nChar , UINT 
nRepCnt , UINT nFlags )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Make sure character is uppercase .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">if (: : IsCharAlpha ( .( TCHAR) nChar)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">nChar=: : CharUpper (nChar ) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Bypass default OnChar processing and directly 
call</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//default window proc.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">DefWindProc (WM_CHAR, nChar , MAKELPARAM 
(nRepCnt , nFlags )) ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip44"></a><b><font SIZE="+2"><font FACE="Times New Roman">44</font><font
FACE="黑体">、如何改变控件的颜色</font></font></b> </p>

<p><font SIZE="+0">有两种方法。其一，可以在父类中指定控件的颜色，或者利用<font
FACE="Times New Roman">MFC4.0</font>新的消息反射在控件类中指定颜色。当控件需要重新着色时，工作框调用父窗口（通常是对话框）的<font
FACE="Times New Roman">CWnd: : OnCrtlColor,</font>可以在父窗口类中重置该函数并指定控件的新的绘画属性。例如，下述代码将对话中的所有编辑控件文本颜色改为红色：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">HBRUSH CAboutDig : : OnCtlColor (CDC * pDCM , 
CWnd * pWnd , UINT nCtlColor)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">HBRUSH hbr = CDialog : : OnCtlColor (pDC, pWnd , 
nCtlColor );</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw red text for all edit controls .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">if (nCtlColor= = CTLCOLOR_EDIT )</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">pDC </font>―<font FACE="Times New Roman">&gt; 
SetTextColor (RGB (255 , 0 , 0 , ) ) ;</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return hbr ;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">然而，由于每个父窗口必须处理通知消息并指定每个控件的绘画属性，所以，这种方法不是完全的面向对象的方法。控件处理该消息并指定绘画属性更合情合理。消息反射允许用户这样做。通知消息首先发送给父窗口，如果父窗口没有处理则发送给控件。创建一个定制彩色列表框控件必须遵循下述步骤。</font> 
</p>

<p><font SIZE="+0">首先，使用<font FACE="Times New Roman">ClassWizard </font>创建一个<font
FACE="Times New Roman">CListBox </font>的派生类并为该类添加下述数据成员。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">class CMyListBox ; publilc CListBox</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">private;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">COLORREF m_clrFor ; // foreground color</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">COLORREF m_clrBack ; //background color</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">Cbrush m_brush ; //background brush</font> </p>

<p><font SIZE="+0">…</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">} ;</font> </p>

<p><font SIZE="+0">其次，在类的构造函数中，初始化数据中。</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CMyListBox : : CMyListBox ()</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Initialize data members .</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">m_clrFore =RGB (255 , 255 , 0) ; // yellow text</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">m_clrBack=RGB (0 , 0 , 255) ; // blue background</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">m_brush . CreateSolidBrush (m _clrBack );</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">最后，使用<font FACE="Times New Roman">ClassWizard</font>处理反射的<font
FACE="Times New Roman">WM_CTLCOLOR(=WM_CTLCOLOR)</font>消息并指定新的绘画属性。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">HBRUSH CMyListBox : : CtlColor (CDC* pDC, UINT 
nCtlColor )</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">pDC</font>―<font FACE="Times New Roman">&gt;SetTextColor 
(m_clrFore);</font></font> </p>

<p><font SIZE="+0"><font FACE="Times New Roman">pDC</font>―<font FACE="Times New Roman">&gt;SetBkColor 
(m_clrBack);</font></font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return (HBRUSH) m_brush.GetSafeHandle ()</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">现在，控件可以自己决定如何绘画，与父窗口无关。</font> 
</p>

<p><a NAME="tip45"></a><b><font SIZE="+2"><font FACE="Times New Roman">45</font><font
FACE="黑体">、当向列表框中添加多个项时如何防止闪烁</font></font></b> </p>

<p><font SIZE="+0">调用<font FACE="Times New Roman">CWnd::SetRedraw </font>清除重画标志可以禁止<font
FACE="Times New Roman">CListBox</font>（或者窗口）重画。当向列表框添加几个项时，用户可以清除重画标志，然后添加项，最后恢复重画标志。为确保重画列表框的新项，调用<font
FACE="Times New Roman">SetRedraw (TRUE) </font>之后调用<font FACE="Times New Roman">CWnd::Invalidate</font>。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Disable redrawing.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pListBox-&gt;SetRedraw (FALSE);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Fill in the list box gere</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Enable drwing and make sure list box is 
redrawn.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pListBox-&gt;SetRedraw (TRUE);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pListBox-&gt;Invalidate ();</font> </p>

<p><a NAME="tip46"></a><b><font SIZE="+2"><font FACE="Times New Roman">46</font><font
FACE="黑体">、如何向编辑控件中添加文本</font></font></b> </p>

<p><font SIZE="+0">由于没有<font FACE="Times New Roman">CEdit:: AppendText</font>函数，用户只好自己做此项工作。调用<font
FACE="Times New Roman">CEdit:: SetSel</font>移动到编辑控件末尾，然后调用<font
FACE="Times New Roman">CEdit:: ReplaceSel</font>添加文本。下例是<font
FACE="Times New Roman">AppendText </font>的一种实现方法：</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CMyEdit:: AppendText (LPCSTR pText)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">int nLen=GetWindowTextLength ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">SetFocus ();</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">SetSel (nLen, nLen);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">ReplaceSel (pText);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip47"></a><b><font SIZE="+2"><font FACE="Times New Roman">47</font><font
FACE="黑体">、如何访问预定义的</font><font FACE="Times New Roman">GDI</font><font
FACE="黑体">对象</font></font></b> </p>

<p><font SIZE="+0">可以通过调用<font FACE="Times New Roman">CDC:: SlectStockObject</font>使用<font
FACE="Times New Roman">Windows</font>的几个预定义的对象，诸如刷子、笔以及字体。下例使用了<font
FACE="Times New Roman">Windows</font>预定义的笔和刷子<font FACE="Times New Roman">GDI</font>对象在视窗中画一个椭圆。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw ellipse using stock black pen and gray 
brush.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">void CSampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Determine size of view.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect rcView;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetClientRect (rcView);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Use stock black pen and stock gray brush to 
draw ellipse.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SelectStockObject (BLACK_PEN);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SelectStockObject (GRAY_BRUSH)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw the ellipse.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;Ellipse (reView);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0">也可以调用新的<font FACE="Times New Roman">SDK</font>函数<font
FACE="Times New Roman">GetSysColorBrush</font>获取一个系统颜色刷子，下例用背景色在视窗中画一个椭圆：</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">void CsampleView:: OnDraw (CDC* pDC)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Determine size of view.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CRect rcView;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">GetClientRect (rcView);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Use background color for tooltips brush.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush * pOrgBrush=pDC-&gt;SelectObject (</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">CBrush::FromHandle (::GetSysColorBrush 
(COLOR_INFOBK)));</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Draw the ellipse.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;Ellipse (rcView);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Restore original brush.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">pDC-&gt;SelectObject (pOrgBrush);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><a NAME="tip48"></a><b><font SIZE="+2"><font FACE="Times New Roman">48</font><font
FACE="黑体">、如何获取</font><font FACE="Times New Roman">GDI</font><font
FACE="黑体">对象的属性信息</font></font></b> </p>

<p><font SIZE="+0">可以调用<font FACE="Times New Roman">GDIObject:: GetObject</font>。这个函数将指定图表设备的消息写入到缓冲区。下例创建了几个有用的辅助函数。</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">//Determine if font is bold.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BOOL IsFontBold (const CFont&amp;font)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">LOGFONT stFont;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">font.GetObject (sizeof (LOGFONT), &amp;stFont);</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">return (stFont.lfBold)? TRUE: FALSE;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Return the size of a bitmap.</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">CSize GetBitmapSize (const CBitmap&amp;bitmap)</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">BITMAP stBitmap;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">bitmap.GetObject (sizeof (BITMAP), 
&amp;stBitmap);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return CSize (stBitmap.bmWidth, stBitmap. 
bmHeight);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">//Create a pen with the same color as a brush.</font> 
</p>

<p><font SIZE="+0" FACE="Times New Roman">BOOL CreatePenFromBrush (Cpen&amp;pen, cost 
Cbrush&amp;brush)</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">{</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">LOGBRUSH stBrush;</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">brush.Getobject (sizeof (LOGBRUSH), 
&amp;stBrush);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">return pen. Createpen (PS_SOLID, 0, 
stBrush.ibColor);</font> </p>

<p><font SIZE="+0" FACE="Times New Roman">}</font> </p>
</body>
</html>
