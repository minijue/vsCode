<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>Visual C</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body style="font-size: 9pt" background="../../res/back.JPG">

<p align="center"><big><strong>Visual C++编程技巧第十二期</strong></big></p>

<p align="center">转载于<font face="Arial">&quot;</font>玉海园<font face="Arial">&quot;</font>网站</p>

<p><strong>一.ListView</strong><br>
问:在我的应用程序里的一个对话框里有一个列表控件.我从MSDN中复制/粘贴了一个段<br>
代码来完成一个实际的列表.当我使用DoModal()语句时出现如下错误:<br>
&quot;Unhandled exception in VirtualList.exe (COMCTL32.DLL): 0xC0000005: Access<br>
Violation&quot;<br>
该错误是在CMyDialog::OnInitDialog()中发生的.通过使用调试器我发现最后两句引起<br>
的错误:<br>
ListView_DeleteAllItems(hwndListView);<br>
ListView_SetItemCount(hwndListView, 100);<br>
return TRUE;<br>
<br>
答:虚列表视是在CreateWindow或CreateWindowEx函数,在里面指定窗口类型LVS_OWNERDATA<br>
LVS_OWNERDATA类型可以各其他的窗口类型参数同时使用,但不能与LVS_SORTASCENDING<br>
LVS_SORTDESCENDING一起使用.<br>
所有虚列表视控件的缺省类型为LVS_AUTOARRANGE.<br>
注意LVS_OWNERDATA不支持动态切换.<br>
你的代码违背了最后一点:当OnInitDialog ()被调用时,列表视控件已经建立了,<br>
而你这时却想动态切换到LVS_OWNERDATA类型.<br>
在VC 6.0中你可以在资源编辑器中对列表控件选中&quot;Owner data&quot;类型来完成在<br>
OnInitDialog ()的设置,你也可以在编辑器中选中LVS_REPORT.<br>
<br>
<br>
<strong>二.为什么第二个对话框不是模态的?</strong><br>
问:当我在一个模态对话框中调用第二个模态对话框时,第二个对话框对于第一个对话框<br>
并不是模态的,虽然它们对于整个应用程序是模态的.<br>
<br>
答:<br>
1)检查一下第一个对话框是否是第二个对话框的父窗口.<br>
2)我猜想你打开第二个对话框时使用的是类似下面的代码.<br>
CMySecondDialog dlg;<br>
if(IDOK =3D=3D dlg.DoModal())<br>
{<br>
// use the results ...<br>
}<br>
问题在于这种建立方法你的第二个对话框是以应用程序主窗口为父窗口的,要想使第二个<br>
对话框也成为第一个对话框的模态对话框,你应该将第一个对话框作为第二个对话框的<br>
父窗口.只需改成下面这样就可以了.<br>
CMySecondDialog dlg(this);<br>
这时问题就不复存在了.<br>
<br>
<br>
<strong>三.等待文件操作结束</strong><br>
问:在我的应用程序中,我通过CreateProcess调用了一个DOS程序,这个程序建立一个输出<br>
文件,我想在这个DOS程序建立完成后读取文件里面的内容.那么我就必须要知道什么时候<br>
文件已经建立.<br>
<br>
答:<br>
1)你可以通过比较文件的时间/日期来得知是否已经改变,只有文件被关闭时时间/日期<br>
才会改变.<br>
2)你可以等待线程的返回(你已经从CreateProcess()中取得了它的句柄.<br>
3)我不太清楚你的编程环境以及你所解决的方法。但也可能过匿名传替来实现你的想法。<br>
注意：你的DOS程序必须使用STDIO或者通过参数来接受操作系统句柄建立文件。试一下<br>
下面的代码，也许是你所要的<br>
static BOOL Execute( LPCTSTR szComando, char *mszArgumentos[ MAX_ARGS ],<br>
CClientSocket *pSocket, DWORD &amp;dwRet )<br>
{<br>
enum PIPES { READ, WRITE };<br>
int hPipe[ 2 ];<br>
int hStdOut, hStdErr;<br>
int hProcesso;<br>
BOOL bSucesso = FALSE;<br>
<br>
dwRet = STILL_ACTIVE;<br>
<br>
bInicioRespostaComando = TRUE;<br>
<br>
::_flushall( );<br>
<br>
if( ::_pipe( ( int * )hPipe, 10240, _O_BINARY | _O_NOINHERIT ) != 0 ) {<br>
// gravar a falha detalhada no log<br>
return( FALSE );<br>
}<br>
<br>
// tirar uma cpia de 'back-up' das sadas-padro.<br>
hStdOut = _dup( fileno( stdout ) );<br>
hStdErr = _dup( fileno( stderr ) );<br>
<br>
// faz a sada-padro e da sada-padro de erros deste processo (que<br>
// sero as mesmas do processo-filho) ser a mesma do descritor<br>
// de grava玢o do pipeline.<br>
_dup2( ( int )hPipe[ WRITE ], fileno( stdout ) );<br>
_dup2( ( int )hPipe[ WRITE ], fileno( stderr ) );<br>
<br>
// o pipeline de grava玢o pode ser fechado. Quem vai gravar nele ?o<br>
processo-filho<br>
// atravs das sadas-padro.<br>
::close( hPipe[ WRITE ] );<br>
<br>
hProcesso = ::_spawnvp( _P_NOWAIT, szComando, mszArgumentos );<br>
<br>
::Sleep( 500 );<br>
<br>
// pr de volta os descritores das sadas-padro<br>
_dup2( hStdOut, fileno( stdout ) );<br>
_dup2( hStdErr, fileno( stderr ) );<br>
<br>
// e fechar a cpia da sada-padro<br>
close( hStdOut );<br>
close( hStdErr );<br>
<br>
if( hProcesso != -1 ) {<br>
static char szBuffer[ 1024 ];<br>
DWORD dwLidos;<br>
<br>
while( 1 ) {<br>
<br>
dwLidos = 0;<br>
if( ! ::PeekNamedPipe( ( HANDLE )::_get_osfhandle( hPipe[ READ ] ),<br>
szBuffer, sizeof( szBuffer ), &amp;dwLidos, NULL, NULL ) ) {<br>
<br>
// x? Problemas no pipe. Matar o processo-filho.<br>
dwRet = STILL_ACTIVE;<br>
<br>
if( ::GetExitCodeProcess( ( HANDLE )hProcesso, &amp;dwRet ) &amp;&amp;<br>
dwRet == STILL_ACTIVE )<br>
::TerminateProcess( ( HANDLE )hProcesso, 253 );<br>
break;<br>
}<br>
<br>
if( dwLidos &gt; 0 ) {<br>
dwLidos = 0;<br>
if( ( dwLidos = ( DWORD )::_read( hPipe[ READ ], szBuffer,<br>
sizeof( szBuffer ) ) ) &lt; 1 )<br>
break;<br>
<br>
EnviaRespostaComando( pSocket, szBuffer, dwLidos );<br>
}<br>
else {<br>
dwRet = STILL_ACTIVE;<br>
if( ! ::GetExitCodeProcess( ( HANDLE )hProcesso, &amp;dwRet ) ||<br>
dwRet != STILL_ACTIVE )<br>
break;<br>
}<br>
}<br>
<br>
bSucesso = TRUE;<br>
}<br>
<br>
close( hPipe[ READ ] );<br>
<br>
return( bSucesso );<br>
}<br>
<br>
static void EnviaRespostaComando( CClientSocket *pSocket, char *szBuffer,<br>
DWORD dwTamBuffer )<br>
{<br>
DWORD dwInicio, dwFim;<br>
<br>
if( bInicioRespostaComando == TRUE ) {<br>
bInicioRespostaComando = FALSE;<br>
pSocket-&gt;Send( &quot;200 &quot;, 4 );<br>
}<br>
<br>
for( dwInicio = dwFim = 0; dwFim &lt; dwTamBuffer; dwFim++ ) {<br>
if( szBuffer[ dwFim ] == '\n' ) {<br>
pSocket-&gt;Send( &amp;szBuffer[ dwInicio ], dwFim - dwInicio + 1 );<br>
pSocket-&gt;Send( &quot;200 &quot;, 4 );<br>
dwInicio = dwFim + 1;<br>
}<br>
}<br>
<br>
if( dwFim &gt; dwInicio )<br>
pSocket-&gt;Send( &amp;szBuffer[ dwInicio ], dwFim - dwInicio );<br>
}<br>
<br>
<strong>四.DAO的线程单元模式.</strong><br>
问：我有一个UNICODE的多线程应用程序,与数据库有互相交流.我使用的是DAO类,<br>
两个线程都是工作者线程(数据库使用是的DAO Jet引掣),在VC的帮助文件中明确指<br>
出它们要包含两个头文件#include &lt;afxole.h&gt; #include &lt;dbdao.h&gt;,但文件<br>
&quot;dbdao.h&quot;并不存在.<br>
<br>
答:我想这个头文件包含在DAO 3.5 SDK中<br>
<br>
<strong>五.MRU作为子菜单</strong><br>
问:我的MDI程序使用了MRU文件函数来保存新近打开的文件系列,已经能很好的工作了,<br>
但我想让MRU在VC6中以子菜单出现.<br>
<br>
答:在你的头文件里声明以下类<br>
<br>
class CMyApp : public CWinApp<br>
{<br>
// ...<br>
<br>
file://{{AFX_MSG(CMyApp)<br>
afx_msg void OnUpdateRecentFileMenu(CCmdUI* pCmdUI);<br>
file://}}AFX_MSG<br>
<br>
// ...<br>
};<br>
<br>
在你的源文件中实现声明的类.<br>
BEGIN_MESSAGE_MAP(CMyApp, CWinApp)<br>
file://{{AFX_MSG_MAP(CMyApp)<br>
ON_UPDATE_COMMAND_UI(ID_FILE_MRU_FILE1, OnUpdateRecentFileMenu)<br>
file://}}AFX_MSG_MAP<br>
END_MESSAGE_MAP()<br>
<br>
void CMyApp::OnUpdateRecentFileMenu(CCmdUI* pCmdUI)<br>
{<br>
if (pCmdUI-&gt;m_pMenu == NULL ||<br>
pCmdUI-&gt;m_pMenu-&gt;GetMenuItemID(pCmdUI-&gt;m_nIndex) != ID_FILE_MRU_FILE1)<br>
{<br>
return;<br>
}<br>
<br>
CWinApp::OnUpdateRecentFileMenu (pCmdUI);<br>
return;<br>
}<br>
在资源编程器中当你建立菜单时,&quot;新近打开的文件&quot;菜单项选中Pop-up属性，并且<br>
该项目的ID须与程序中相对应，这里为ID_FILE_MRU_FILE1.<br>
<br>
<br>
<strong>六.MFC的FTP类</strong><br>
问:我写一个FTP客户程序可以从远程计算机上以二进制模式拷贝几个文件.我使用是的<br>
MFC提供的Internet类.如果我不设置UNICODE的话，程序运行正常，但如果我设置了<br>
UNICODE，程序编译联接都正常，但运行时我得到以下消息：<br>
&quot;Internet exception with cause:This function is valid only in Windows NT mode.&quot;<br>
<br>
答:<br>
&gt;如果不能的话,MFC有没有提供其他方法来写一个用UNICODE模式的FTP客户程序.<br>
不幸的是MFC并不支持Wininet的UNICODE版本.只有在IE5中的Wininet有一个UNICODE<br>
的版本.<br>
&gt;可以提供的更多的消息是:我不能动态调用Wininet.dll.<br>
答:这是正常的,因为你用的是MFC来编写FTP,这样MFC会在后台为我们做准备工作.<br>
你可以试一下用SDK来包含IE5中的wininet.h，然后分配新的wininet.dll。<br>
<br>
<strong>七.我声明了一个列表:</strong><br>
typedef CList &lt;long, long&gt; JOBENTRYIDLIST;<br>
typedef struct JOBHANDLE{<br>
LONG m_JobHandle;<br>
JOBENTRYIDLIST m_JobEntryIDList;<br>
}JOBHANDLE;<br>
CList &lt;JOBHANDLE, JOBHANDLE&gt; m_JobHandleList;<br>
有人建议使用CTypedPtrList代替CList.有谁知道错那儿了?<br>
<br>
答:你的声明没有什么错误,但会带来一个问题,如果列表项非常多的时候(&gt;1000)时,会<br>
拖慢系统,并会耗费许多的内存.而CPtrList只需要四个字节(指向由new分配的内存),在<br>
插入项目时比起上面的方法快的多.<br>
<br>
你使用的方法没有错误,具体与你的开发环境有关,你可以两种方法全部使用或者找出最<br>
适合你的方法.</p>
</body>
</html>
