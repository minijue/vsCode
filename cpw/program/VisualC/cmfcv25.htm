<html>

<head>
<title></title>
</head>

<body>

<table border="0" cellspacing="2" cellpadding="0" width="100%" style="font-size: 9pt">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是： <b><a href="Vc_idx.htm">Visual 
    C++/C++</a> &gt;</b> </span><font color="#000000">MFC邮递表的中文翻译-第二十五期</font></td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%" bgcolor="#E8E8E8">
      <tr>
        <td width="100%">　</td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><p align="center"><font color="#000000"><strong>MFC邮递表的中文翻译-第二十五期</strong></font></td>
  </tr>
  <tr>
    <td width="100%">　</td>
  </tr>
  <tr>
    <td width="100%">　<p><font COLOR="#FF0000">第二十五期目录</font> <font SIZE="-1">Yu 
    Hail 1999.2.4</font><ol>
      <li><a href="#vol25q1">有ODBC的查找函数吗?</a> </li>
      <li><a href="#vol25q2">多个MRU菜单的问题</a> </li>
      <li><a href="#vol25q3">校验框类输入焦点的问题</a> </li>
    </ol>
    <p><a name="vol25q1"></a></p>
    <font color="Red"><h3>有ODBC的查找函数吗?</h3>
    </font><p>问：我将一个应用程序从DAO转换为ODBC,但发现没有与CDaoRecordse::Find()等价的ODBC函数.<br>
    答：我建议用折半查找算法.当然这只能在你的记录是按某一字段排序的情况下,而且也应该 
    取得记录的总条数.请看如下示例: </p>
    <pre>
BOOL CMyRecordset::FindFirst_Name(const CString&amp; value)
{
   if (IsEOF() &amp;&amp; IsBOF()) // recordset empty?
      return FALSE;
   ULONG ulTop = 1, ulBottom, ulMiddle;

   // try to determine record count - if it is possible, of course
   SetAbsolutePosition(-1);
   ulBottom = GetRecordCount();
   if(ulBottom == -1) // number of records can not be determined
      return FALSE;
   do
   {
      SetAbsolutePosition(ulMiddle = (ulTop + ulBottom) &gt;&gt; 1);
    switch(value.Compare(m_sName))
      {
      case 0: // found!
        return TRUE;
      case 1: // value is greater than m_sName
         ulTop = ulMiddle;
         break;
    case -1:// value is less than m_sName
         ulBottom = ulMiddle;
    }
   } while(ulTop != ulBottom); // not found
   return FALSE;
}
</pre>
    <p>注意:<br>
    <ul>
      <li>这个函数不能保证找到的是第一个(按顺序)符合条件的记录,但很显然,你可以定制 
        它来满足你的要求. </li>
      <li>取中值时你不一定非要除以2,例如你可以用Fibonacci数列(1,2,3,5,8,13,21...)来改变 
        切分的大小,这样或许会得到更好的性能. </li>
      <li>我没有测试这个函数,也许无法工作. </li>
    </ul>
    <a href="#PageBegin"><p align="right">返回页首</a> <a name="vol25q2"></a> </p>
    <font color="Red"><h3>多个MRU菜单的问题</h3>
    </font><p>问：我想象DevStudio97那样将不同文档类型的MRU子菜单分开,如分成最近的工作区和最近打开 
    的文件.我在CodeGuru上找了找,但没有什</p>
    <p>么收获.<br>
    答：这是可以解决的.我保留了CRecentFileList对象,让MFC框架去管理默认的文档类型,然后 
    加入了对第二种文档类型的处理,我准备一</p>
    <p>步一步说明这个问题:<br>
    </p>
    <blockquote>
      <ol>
        <li>使用自定义的菜单ID,如ID_FILE_MRU_MYFILE1,你也应该在字符串表中加入ID_FILE_MRU_MYFILE2, 
          ID_FILE_MRU_MYFILE3, ... ID_FILE_MRU_MYFILE## </li>
        <li>在应用程序类中加入新成员:CRecentFileList* m_pRecentListMyFiles; </li>
        <li>在初始化InitInstance()加入如下代码:<br>
          m_pRecentListMyFiles =new CRecentFileList( 5, &quot;My Recent File List&quot;, 
          &quot;MyFile%d&quot;, 5 );<br>
          m_pRecentListMyFiles-&gt;ReadList(); </li>
        <li>在ExitInstance()加入m_pRecentListMyFiles-&gt;WriteList(); </li>
        <li>增加对ID_FILE_MRU_MYFILE1的UI处理UPDATE_COMMAND_UI:m_pRecentListMyFiles-&gt;UpdateMenu(pCmdUI); 
        </li>
        <li>在应用程序消息映射中加入如下代码:ON_COMMAND_EX_RANGE(ID_FILE_MRU_MYFILE1, 
          ID_FILE_MRU_MYFILE##,OnOpenRecentMyFile) </li>
        <li>下面是上述消息的处理函数: <pre>
BOOL CMyApp::OnOpenRecentMyFile(UINT nID)
	{
 	int nIndex = nID - ID_FILE_MRU_MYFILE1;
 	if (OpenDocumentFile((*m_pRecentListMyFiles)[nIndex]) == NULL)
 	    m_pRecentListMyFiles-&gt;Remove(nIndex);
 	return TRUE;
    }
</pre>
        </li>
        <li>重载CWinApp::AddToRecentFileList() <pre>
void Ck2App::AddToRecentFileList(LPCTSTR lpszPathName)
	{
    // Somehow determine doc type, I used file extension
    CString strExt;
    CString strPathName = lpszPathName;
    int nPos = strPathName.ReverseFind( '.' );
    if ( nPos != -1 )
            strExt = strPathName.Mid( nPos + 1 );
    if ( strExt.CompareNoCase( &quot;XXX&quot; ) == 0 )
        {
        if (m_pRecentListMyFiles!= NULL)
           {
                // fully qualify the path name
                TCHAR szTemp[_MAX_PATH];
                AfxFullPath(szTemp, lpszPathName);

                // then add to recent file list
                m_pRecentListMyFiles-&gt;Add(szTemp);
            }
        }
        else    // Otherwise, let base class put it on default MRU
            CWinApp::AddToRecentFileList(lpszPathName);
    }
</pre>
        </li>
        <li>当然,也不要忘了在应用程序的析构函数中删除m_pRecentListMyFiles </li>
      </ol>
      <a href="#PageBegin"><p align="right">返回页首</a> <a name="vol25q3"></a> </p>
      <font color="Red"><h3>校验框类问题</h3>
      </font><p>问：我想创建这样一个校验框类,它的自动特性只出现在用户点击校验标记时,而不是当文本 
      被点击时.在点击文本时,我只想设置焦点,就象CheckListBox那样.<br>
      答：在按钮类的派生类中,例如CCheckBox,处理WM_LBUTTONDOWN消息: </p>
      <pre>
	void CCheckBox::OnLButtonDown( UINT nFlags, CPoint point )
		{
	   // if the checkmark was clicked, pass the message onto the button
	   if ( HitTest( point ) )
    	   CButton::OnLButtonDown( nFlags, point );
	    else   // otherwise set the focus only
    	   SetFocus();
		}	

	BOOL CCheckBox::HitTest( CPoint&amp; point )
		{
		CRect rcClient;
	    GetClientRect( rcClient );

	   // Checkmark rect
	   CRect rc;
	   // Checkmark square size, hard coded here because I couldn't find any method to obtain this value from </pre>
      <pre>the system.
	   // Maybe someone else knows how to do it?
	   const int nCheckSize = 13;

	   DWORD dwStyle = GetStyle();
	   if ( ( dwStyle &amp; BS_VCENTER ) == BS_VCENTER )
    	  rc.top = rcClient.top + ( ( rcClient.bottom - rcClient.top ) -nCheckSize ) / 2;
	   else if ( dwStyle &amp; BS_TOP )
    	  rc.top = rcClient.top + 1;
	   else if ( dwStyle &amp; BS_BOTTOM )
    	  rc.top = rcClient.bottom - nCheckSize - 2;
	   else  // Default
    	  rc.top = rcClient.top + ( ( rcClient.bottom - rcClient.top ) -nCheckSize ) / 2;

	   if ( dwStyle &amp; BS_LEFTTEXT )
    	  rc.left = rcClient.right - nCheckSize;
	   else
    	  rc.left = rcClient.left;

	   rc.right = rc.left + nCheckSize;
	   rc.bottom = rc.top + nCheckSize;
	   return rc.PtInRect( point );
	}
</pre>
      <a href="#PageBegin"><p align="right">返回页首</a> </p>
      <hr>
      <a href="cmfcv26.htm"><p align="center">前一期</a>|<a href="cmfcv24.htm">后一期</a><br>
      <a href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供! 
      </p>
    </blockquote>
    </td>
  </tr>
</table>

<p><a name="PageBegin"></a></p>
</body>
</html>
