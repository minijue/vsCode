<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title></title>
</head>

<body bgcolor="#8080C0">
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="95%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="Vcidx098.htm">Visual 
    C++/C++</a> --&gt;</b> MFC邮递表的中文翻译(第四十一期)</span></td>
  </tr>
</table>
</center></div><div align="center"><center>

<table border="1" width="95%" style="font-size: 9pt" bgcolor="#FFFFFF"
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"
    bordercolordark="#FFFFFF">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://chinaprog.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<h2 align="center"><span style="font-size: 9pt">MFC邮递表的中文翻译</span></h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;我是一名mfc程序设计的爱好者,订阅了mfc的maillist,利用业余时间 
    将它翻译出来,希望能对mfc编程的朋友有所帮助,请朋友们指正.<br>
    </p>
    <h3><font color="#FF0000">第四十一期目录</font> <fontsize="2">杨晓东 1999.6.7</h3>
    <ol>
      <li><a href="#volq1">OWNERDRAW树形视和列表视</a> </li>
      <li><a href="#volq2">用CSocket传播数据包</a> </li>
      <li><a href="#volq3">如何截获PRINT SCREEN键</a> </li>
      <li><a href="#volq4">CAsyncSocket和NT服务</a> </li>
      <li><a href="#volq5">为什么当我关闭程序时交互线程挂起</a> </li>
      <li><a href="#volq6">AfxMessageBox()</a> </li>
      <li><a href="#volq7">在属性页的文件open/Save对象框</a> </li>
      <li><a href="#volq8">AfxMessageBox()</a> </li>
      <li><a href="#volq9">重载new和delete</a> </li>
    </ol>
    <p><a name="volq1"></a></p>
    <p><br>
    </p>
    <font color="Red"><h3>OWNERDRAW树形视和列表视</h3>
    </font><p>问：我使用的是VC6，我需要为列表视和树形视的单独项目显示不同的颜色。我试过了用 
    DrawItem，但没有成功。谁能给我一些好的建议？</p>
    <p>答：你可以注意一下使用“custom draw”选项，它比起owner draw简单的多，使用起 
    来也友好的多，可以在MSDN中查找关于NM_CUSTOMDRAW的帮助。<br>
    <a href="#PageBegin"></p>
    <p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq2"></a><br>
    </p>
    <font color="Red"><h3>用CSocket传播数据包</h3>
    </font><p>问：当我用CSocket传播一个数据包时碰上了一个错误消息 </p>
    <pre>&quot;The virtual circuit was reset by the remote side.&quot;</pre>
    <p>我的用法是CSocket:::SendTo(buf, sizeof(buf), NULL, 0)，环境是95/98网络。 
    其中一台也使用拨号网络。 </p>
    <pre>    sock=new CSocket;
    if (sock-&gt;Create(1025,SOCK_DGRAM))
    if (result=sock-&gt;SendTo(s, strlen(s),
1025,NULL,MSG_DONTROUTE)==SOCKET_ERROR)
        {
         .... // displays error explanation
        }</pre>
    <p>答： <ul>
      <li>我从来不用零为地址进行传播，但我却可以实现，只要得到本地机器的地址，将其最 
        后一个数字改成255，就可以了。 我的IP地址为10.12.130.5 
        程序中是这样使用的 <pre>SendTo(s, lstrlen(s), MYPORT, &quot;10.12.130.255&quot;, 0);</pre>
      </li>
      <li>你可能不必设置SO_BROADCAST，下面是我的代码，我用他在局域网上传输大量的小块 
        数据。 <pre>CAsyncSocket socket;
if (!socket.Create(0, SOCK_DGRAM))
        return; // Failed to create socket
// Set broadcast option for this socket
BOOL bBroadcast = TRUE;
socket.SetSockOpt(SO_BROADCAST, &amp;bBroadcast, sizeof(BOOL));
// Send the data on port 1971
socket.SendTo(&amp;buf, sizeof(buf), 1971);</pre>
      </li>
    </ul>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq3"></a><br>
    </p>
    <font color="Red"><h3>如何截获PRINT SCREEN键</h3>
    </font><p>答： <ul>
      <li>可以用GetAsyncKeyState()来实现（你必须反复的使用） 比如： <pre>void
CSomeClass::OnIdle()
{
    if (::GetAsyncKeyState( VK_SCROLL ) &amp; 1)
    {
        ::MessageBox(NULL, &quot;Scroll Lock has been pressed!&quot;,NULL, MB_OK);
    }
}</pre>
      </li>
      <li>WM_KEYDOWN/WM_KEYUP截获大部分键盘的按键，WM_SYSKEYDOWN/WM_SYSKEYUP用来处理 
        Shift,Ctrl 和 Alt ，但PRINT SCREEN不会发送到当前程序，它由系统来处理，象 
        Ctrl-Alt-Del。你可能需要一个键盘句柄，但我不能确定肯定有效，如果你想使用 
        Print Screen键，你必须写一个键盘设备驱动。 </li>
    </ul>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq4"></a><br>
    </p>
    <font color="Red"><h3>CAsyncSocket和NT服务</h3>
    </font><p>问：我想写一个服务程序用来处理接收数据包。我用了一个从CAsyncSocket继承的类。并在 
    重载的OnReceive().完成了所需要的工作。当服务程序初始化时，我调用 
    CAsyncSocket::Create建立一个数据包端口，该函数成功调用了。可是，我从同一个机器 
    别的程序向他发送数据时，重载的OnReceive并没有被调用。</p>
    <p>答：我有一个例子使用的是STREM socket，它可以工作，至少在我的项目中没有问题，我相信 
    无论是STREAM 还是 DATAGRAM sockets. 它们的概念是相同的。 </p>
    <pre>#define WM_STOP_REQUEST (WM_USER+1)
CMyHttpService theMyService;

void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
  theMyService.InitInstance();
  theMyService.Run(DWORD dwArgc, LPTSTR* lpszArgv);
  theMyService.ExitInstance();// cleanup
}

BOOL CMyHttpService::InitInstance()
{
  // .........
  m_dwSocketThreadID = ::GetCurrentThreadId();
  StartListening();
  // .........
}

BOOL CMyHttpService::StartListening()
{
 BOOL bOk = FALSE;
 m_pListenSocket = new CListenSocket( );
 if ( m_pListenSocket )
 {
   if ( m_pListenSocket-&gt;Create( m_uPort, SOCK_STREAM, FD_ACCEPT ) )
   bOk = m_pListenSocket-&gt;Listen();
   if ( !bOk )
   {
    m_pListenSocket-&gt;Close();
    delete m_pListenSocket;
    m_pListenSocket = NULL;
    }
  }
  return bOk;
}

int CMyHttpService::Run(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
  MSG msg;
  while( ::GetMessage( &amp;msg, NULL, 0, 0 ) )
  {
    if( msg.message == WM_STOP_REQUEST )
    ::PostQuitMessage(0);
        else
            ::DispatchMessage( &amp;msg );
    }
    return 0;
};

void CMyHttpService::RequestStopService()
{
  ASSERT( ::PostThreadMessage(m_dwSocketThreadID, WM_STOP_REQUEST, 0, 0));
}</pre>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq5"></a><br>
    </p>
    <font color="Red"><h3>为什么当我关闭程序时交互线程挂起</h3>
    </font><p>问：我程序中有一个主窗口，几个子窗口是在不同的交互线程中实现的。当我关闭程序 
    时我截获了主窗口的OnClose句柄，我给每个线程窗口发送消息告诉它们关闭。然后我 
    等候关闭线程的标志设置正确，然后关闭窗口。但如果我使用</p>
    <pre>PostMessage
::DestroyWindow</pre>
    <p>,线程窗口被挂起。</p>
    <p>答 <ul>
      <li>SendMessage在发送消息之后会马上运行。<br>
        PostMessage会替换掉消息队列中的消息，我猜想在你向队列发送消息时，已经有了一 
        个WM_CLOSE已经在队列中了。那么WM_CLOSE马上关闭你的主窗口不会给其他子窗口足够 
        的时间退出。<br>
      </li>
      <li>WaitForSingleObject不能在消息循环运行，所以你发送的消息并不能得到处理，你的 
        程序却一直在等线程结束标志……<br>
      </li>
      <li>SendMessage是同步的，PostMessage是异步的，可以看一下::SendMessage文档。在消息 
        处理完以前它将一直阻塞线程消息。可以考虑用某些方法阻塞主线程直到其他线程结束 
        为止。以上只是一个猜测。<br>
      </li>
    </ul>
    <a href="#PageBegin"><p align="right">回到本期目录</a><br>
    </p>
    <p><a name="volq6"></a><br>
    </p>
    <p>AfxMessageBox() 问：是否可以重载AfxMessagBox()的MB_OKCANCEL？ 答： <ul>
      <li>重载CwinApp::DoMessageBox()，然后按你的自己的意愿去做……<br>
      </li>
      <li>是的，你能改变该对话框的按钮的标题，但需要一点小小的工作。你要重载DefWindowProc 
        函数，在调用MessageBox先登记一个窗口消息，然后在你的DefWindowProc(假定为 
        MyDefWindowProc)。先检查最顶层的窗口是否是同样你登录的消息对话框，如果是的话 
        使用GetWindowLong你能很容易的发现当前的按钮控件并不是一个静态文本控件，用 
        SetWindowLong函数来改变按钮的文本。代码象这样 <pre>LRESULT MyDefwindowProc(...)
{
....
if(uMsg == YourRegisterMessage)
{
// loop for all message box control
for(hwndControl = GetTopWindow(hwndMess);
    hwndControl &amp;&amp; ((lpstrCaption = *(&amp;((MESSAGE_INFO *)
    lParam)-&gt;Button1+uLoop)) != NULL);
    hwndControl = GetWindow(hwndControl, GW_HWNDNEXT))
{
    // if static text, continue.
    if (GetWindowLong(hwndControl, GWL_ID) == -1)
        continue;
    else // change text.
    {
    SetWindowText(hwndControl, lpstrCaption);
    uLoop++;
    }
}
SetWindowLong(hwndMess, GWL_HWNDPARENT, (long)hwnd);
.... // other codes line
}
else // if not your register message
    DefWindowProc(...);
}</pre>
        <a href="#PageBegin"><p align="right">回到本期目录</a><br>
        </p>
        <p><a name="volq7"></a><br>
        </p>
        <font color="Red"><h3>在属性页的文件open/Save对象框</font> 问：我建立了MFC程序，我想在属性表的一页中显示一个Explorer类型的文件Open/Save 
        对话框页。</h3>
        <p>答；定义一个文件Open/Save对话框对象（一个CFileDialog类的对象）在你从CPropertySheet 
        继承的类的构造函数中定义。然后使用AddPage函数将这个对象加入<br>
        <a href="#PageBegin"></p>
        <p align="right">回到本期目录</a><br>
        </p>
        <p><a name="volq8"></a><br>
        </p>
        <font color="Red"><h3>95的异常与GDI有关</font> 
        问：我们有一个程序准备发行，但有一个问题：在95或98中但不是NT4，程序运行缓慢， 
        随机性出错。</h3>
        <p>答： <ul>
          <li>我近来也遇到过相同的问题，后来发现我使用了许多的GDI资源（笔，刷子等）但 
            没有正确的释放它们，在我这种情况下时间不长就会发生错误。所以你们应该看看是否 
            正确的释放了他们。<br>
          </li>
          <li>你们可能造成了资源漏洞，之所以你们没有在NT中遇上这种情况是因为NT要比9X中 
            分配更多的句柄可供使用。确定你为每个GDI对象都用DeleteObject删除。当然我不认为 
            这是必须的，但这是一个好的习惯：当你不需要自己的GDI对象时将其恢复了原来的对象。 
            你也可以使用程序来检查GDI漏洞。比如象BoundChecker，它可能会找出漏洞，你可以从 
            www.numega.com下载一个DEMO。<br>
          </li>
        </ul>
        <a href="#PageBegin"><p align="right">回到本期目录</a><br>
        </p>
        <p><a name="volq9"></a><br>
        </p>
        <font color="Red"><h3>重载new和delete</font> 问：我想重载一个CObject继承类的new和delete操作。这是一个可系列化的类（使用 
        了IMPLEMENT_SERIAL宏） </h3>
        <pre>public:
    void *operator new(size_t size);
    void operator delete(void *pObj, size_t size);</pre>
        <p>当我编译时得到了下列错误。 </p>
        <pre>void *__cdecl CSPattern::operator new(unsigned int)' : no matching operator delete found;</pre>
        <p>答： <ul>
          <li>我认为你必须移去delete的第二个参数size_t。编译器会查找delete(void*)函数 
            但并不是delete(void*, size_t)。<br>
          </li>
          <li>我也曾经遇到过这样的问题，例子很简单。但当我加入下面一行代码时就会有警告： 
            <pre>void operator delete(void *p) {CObject::operator delete(p);}</pre>
            <p>从阅读的一些资料中得知delete(void *, size_t) 和delete(void *p)应该可以互换。 
            但VC++并不是这样的，我做了些小测试，因为两个参数的delete被忽略所以加入一个 
            参数的delete。当你需要带一个尺寸参数来释放内存时会是个问题。所以我们的程序 
            总是警告但又不抛出错误。<br>
            注意：你可能需要下面这些代码，因为MFC在debug中需要用new(). </p>
            <pre>#if defined(_DEBUG)
  void *new(size_t, LPCSTR, int); // for the ternary debug new
  void delete(void *p, LPCSTR, int); // w/o this, you get THE WARNING
#endif

Make sure the body for new(,,) goes before the ubiquitous:
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif</pre>
            <a href="#PageBegin"><p align="right">回到本期目录</a><br>
            </p>
            <hr>
            <p align="center">前一期|<a href="cmfcv40.htm">后一期</a><br>
            <a href="http://mfc2000.yeah.net" target="_top">玉海园</a>[http://mfc2000.yeah.net]友情提供! 
            </p>
          </li>
        </ul>
      </li>
    </ul>
    </td>
  </tr>
</table>
</center></div>

<p><a name="PageBegin"></a></p>
</body>
</html>
