<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>C++ Builder中保持控件的位置及大小</title>
<link rel="stylesheet" href="../images/my.css">
</head>

<body style="font-size: 9pt" bgcolor="#FFFFFF">

<table border="0" cellspacing="2" cellpadding="0" bordercolor="#DED8CD" width="100%">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是：<a href="Vc_idx.htm">Visual C++/C++</a> 
    <b>&gt;</b> C++ Builder中保持控件的位置及大小</span></td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%">
      <tr>
        <td width="100%"></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><p align="center"><span style="font-size: 9pt"><font color="#000000"><strong>C++ 
    Builder中保持控件的位置及大小</strong></font></span></td>
  </tr>
  <tr>
    <td width="100%"></td>
  </tr>
  <tr>
    <td style="font-size: 9pt">C++ Builder/Delphi是Inprise（原Borland）公司广受欢迎的可视化C++/Pascal开发工具，利用它可极大地加快应用程序的开发速度。但是，也正因为其是可视化编程工具，将控件拖放到Form后，控件的位置就固定死了。随着Form的大小或屏幕分辨率的改变，控件和Form本身的位置往往变得非常混乱。本文将介绍一些正确定位控件及Form的方法。<br>
    <strong>利用OnResize事件改变控件位置及大小</strong><br>
    &nbsp;&nbsp; C++ Builder/Delphi中的Form控件有一个OnResize事件，Form的所有与大小变化有关的动作可以触发这个事件，包括Form的创建、最大化/最小化/还原、用鼠标拖动改变大小等。因此，在此事件中动态地改变各个控件的位置可以确保其在Form中的相对位置正确。因为CBuilder与Delphi的程序有很多共同之处，所以这里只列出CBuilder的代码。<br>
    &nbsp;&nbsp; 下面的代码将确保控件在任何情况下都居中。<br>
    程序一：<br>
    void __fastcall TForm1::FofmResize(TObject*Sender)<br>
    {<br>
    &nbsp;&nbsp;&nbsp; int midLoc=Width/2;&nbsp; //取Form的中点<br>
    &nbsp;&nbsp;&nbsp; Label1-&gt;Left=midLoc-Label1-&gt;Width/2;&nbsp; //设置Label1的位置为Form居中<br>
    &nbsp;&nbsp;&nbsp; Button1-&gt;Left=midLoc-Button1-&gt;Width/2;&nbsp; //设置Button1的位置为Form居中<br>
    }<br>
    &nbsp;&nbsp; 
    稍微修改这段代码，可以使控件保持在任何想要的位置。同样，也可以利用OnResize事件改变控件的大小。当Form中控件很多时，分别对每一个控件单独调整位置是件非常麻烦的事，在TFrom类中有一个Controls数组维护所有From中的控件，利用它可方便地对所有控件进行操作。下面是其源代码：<br>
    程序二：<br>
    void __fastcall TForm1::FormResize(TObject*Sender)<br>
    {<br>
    &nbsp;&nbsp;&nbsp; int midLoc=Width/2;<br>
    &nbsp;&nbsp;&nbsp; TControl * ChildControl;<br>
    &nbsp;&nbsp;&nbsp; fof(int i=0; i&lt;ControlCount; i++)<br>
    &nbsp;&nbsp;&nbsp; {//遍历Controls数组，ControlCount是数组元素个数<br>
    &nbsp;&nbsp;&nbsp; ChildControl = Controls[i];<br>
    &nbsp;&nbsp;&nbsp; ChildCotrol-&gt;Left = midLoc-ChildControl-&gt;Width/2;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    }<br>
    <strong>利用“容器”控制成组控件位置</strong><br>
    &nbsp;&nbsp; 
    上面的代码对维持所有控制到统一位置非常方便，但不利于对成组控件进行操作。<br>
    &nbsp;&nbsp; 在C++Builder中提供了一些能安放其它控件的“容器”控件，如TPanel、TGroupBox等，可以将控件放在“容器”控件中：然后对“容器”控件进行操作，从而达到成组控制控件的目的。利用“容器”控件控制控件位置的结果，所有控件都自动居中，但是在GroupBox1控件中的子控件却没有居中，这是因为Controls数组只维护Form的直接子控件，对Form中控件的子控件则无能为力。因此，GroupBox1控件中的子控件仍然在初始位置，必须编写相应代码动态控制其位置及大小。这种技术非常重要，特别是在动态改变“容器”控件大小时。其实，“容器”控件与From一样有Controls数组，只要对其进行与程序2类似的操作即可。代码见程序3<br>
    程序三<br>
    void __fastcall TForm1::FormResize(TObject*Sender)<br>
    {<br>
    &nbsp;&nbsp;&nbsp; int midLoc=Width/2;<br>
    &nbsp;&nbsp;&nbsp; TControl * ChildControl;<br>
    &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;ControlConnt; i++)<br>
    &nbsp;&nbsp;&nbsp; {//遍历Controls数组，ControlCount是数组元素个数<br>
    &nbsp;&nbsp;&nbsp; ChildControl = Controls[i];<br>
    &nbsp;&nbsp;&nbsp; ChildControl-&gt;Left = midLoc-ChildControl-&gt;Width/2;<br>
    &nbsp;&nbsp;&nbsp; if (ChildControl ==GroupBox1)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {//若控件是GroupBox，对其子控件进行操作<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int SubMidLoc=GroupBox1-&gt;Width/2;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int 
    j=0;j&lt;GroupBox1-&gt;ControlCount;j++)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {//遍历GroupBox1的Controls数组。ControlCount是数组元素个数<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChildControl=GroupBox1-&gt;Controls[j];<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    ChildContro1-&gt;Left=SubMidLoc-ChildControl-&gt;Width/2;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; }<br>
    }<br>
    <strong>在不同分辨率下维护窗体位置及大小</strong><br>
    &nbsp;&nbsp; 
    商业程序一般要在各种分辨率下运行，正确判断当前分辨率就显得很重要。Windows函数GetDeviceCaps可以返回任意设备描述表中设备大小。<br>
    &nbsp;&nbsp; GetDeviceCaps有两个参数，第一个是要查询的设备描述表句柄，第二个是要查询参数的类型，其中HORZRES，VERTRES分别代表屏幕水平和垂直分辨率。程序4是获得当前屏幕分辨率的代码。一般可将这段代码放在“工程文件”（如Project1.cpp）中，并将i、j定义为全局变量，然后可以利用前面介绍的技术控制各种屏幕元素的大小及位置。<br>
    程序四：<br>
    HDC hdc=GetDC(NULL); //获得屏幕设备描述表句柄<br>
    int i=GetDeviceCaps(hdc,HORZRES); //查询屏幕水平分辨率，并返回在变量i中<br>
    int j=GetDeviceCaps(hdc,VERTRES); //查询屏幕水平分辨率，并返回在变量j中<br>
    ReleaseDC(NULL,hdc); //释放屏幕设备描述表<br>
    &nbsp;&nbsp; 
    用同样的方法，可以对不同大小纸张的打印进行控制，在这里不再赘述，有兴趣的朋友可查看GetDevice<br>
    Caps帮助及打印帮助。</td>
  </tr>
  <tr>
    <td width="100%"><hr>
    </td>
  </tr>
  <tr>
    <td width="100%">中国程序员网站版权所有</td>
  </tr>
</table>

<p><br>
<br>
</p>
</body>
</html>
