<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<meta NAME="Author" CONTENT="con">
<title>C 语言编程</title>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->
</head>

<body>

<table border="0" cellspacing="2" cellpadding="0" width="100%" style="font-size: 9pt">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">现在的位置是： <b><a href="linuxidx.htm">Unix/Linux</a> 
    &gt;</b> </span>Unix下的C语言编程</td>
  </tr>
  <tr>
    <td></td>
  </tr>
</table>

<table border="0" width="100%" style="font-size: 9pt" bgcolor="#E8E8E8">
  <tr>
    <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
    cellspacing="0" cellpadding="2">
      <tr>
        <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
        class="f">&middot;</span><a href="http://fasoft.yeah.net" target="_blank"
        style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">　<table border="0" width="100%" bgcolor="#E8E8E8">
      <tr>
        <td width="100%"></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%"><h2 align="center">Unix下的C语言编程</h2>
    </td>
  </tr>
  <tr>
    <td width="100%"></td>
  </tr>
  <tr>
    <td width="100%">　<h3 align="center">前言</h3>
    <p>&nbsp;&nbsp;&nbsp; 本文译自《Slackware Linux Unleashed》(第三版) 一书的第27章: 
    <a HREF="../slu/ch27.htm">Programming in C</a>. 
    关于本译文有任何的话请与我联系: <a HREF="mailto:con@nease.net">mailto:con@nease.net</a>. 
    </p>
    <p>Linux的发行版中包含了很多软件开发工具. 它们中的很多是用于 C 
    和 C++应用程序开发的. 本文介绍了在 Linux 下能用于 C 
    应用程序开发和调试的工具. 本文的主旨是介绍如何在 Linux 下使用 C 
    编译器和其他 C 编程工具, 而非 C 语言编程的教程. 
    在本文中你将学到以下知识: <br>
    &nbsp; <ul>
      <li>什么是 C</li>
      <li>GNU C 编译器</li>
      <li>用 <tt>gdb </tt>来调试GCC应用程序</li>
    </ul>
    <p>&nbsp;&nbsp;&nbsp; 你也能看到随 Linux 发行的其他有用的 C 编程工具. 
    这些工具包括源程序美化程序(pretty print programs), 附加的调试工具, 
    函数原型自动生成工具(automatic function prototypers). <dl>
      <dd><hr>
        <p><b>注意: </b>源程序美化程序(pretty print programs)自动帮你格式化源代码产生始终如一的缩进格式.&nbsp; 
        </p>
        <hr>
      </dd>
    </dl>
    <h3 align="center">什么是 C?</h3>
    <p>&nbsp;&nbsp;&nbsp; C 是一种在 UNIX 
    操作系统的早期就被广泛使用的通用编程语言. 
    它最早是由贝尔实验室的 Dennis Ritchie 为了 UNIX 的辅助开发而写的, 
    开始时 UNIX 是用汇编语言和一种叫 B 的语言编写的. 从那时候起, C 
    就成为世界上使用最广泛计算机语言. <br>
    &nbsp; <br>
    &nbsp;&nbsp;&nbsp; C 能在编程领域里得到如此广泛支持的原因有以下一些: 
    <ul>
      <li>它是一种非常通用的语言. 
        几乎你所能想到的任何一种计算机上都有至少一种能用的 C 编译器. 
        并且它的语法和函数库在不同的平台上都是统一的, 
        这个特性对开发者来说很有吸引力.</li>
      <li>用 C 写的程序执行速度很快.</li>
      <li>C 是所有版本的UNIX上的系统语言.</li>
    </ul>
    <p>&nbsp;&nbsp;&nbsp; C 在过去的二十年中有了很大的发展. 在80年代末期美国国家标准协会(American 
    National Standards Institute)发布了一个被称为 ANSI C 的 C 语言标准.这更加保证了将来在不同平台上的 
    C 的一致性. 在80年代还出现了一种 C 的面向对象的扩展称为 C++. C++ 
    将在另一篇文章 &quot;C++ 编程&quot;中描述. </p>
    <p align="center">&nbsp;&nbsp;&nbsp; Linux 上可用的 C 编译器是 GNU C 编译器, 
    它建立在自由软件基金会的编程许可证的基础上, 因此可以自由发布. 
    你能在 Linux 的发行光盘上找到它. <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp; </p>
    <h3 align="center">GNU C 编译器</h3>
    <p align="center">&nbsp;&nbsp;&nbsp; 随 Slackware Linux 发行的 GNU C 编译器(GCC)是一个全功能的 
    ANSI C 兼容编译器. 如果你熟悉其他操作系统或硬件平台上的一种 C 
    编译器, 你将能很快地掌握 GCC. 本节将介绍如何使用 GCC 和一些 GCC 
    编译器最常用的选项. <br>
    &nbsp; </p>
    <h4 align="center">使用 GCC</h4>
    <p>&nbsp;&nbsp;&nbsp; 通常后跟一些选项和文件名来使用 GCC 编译器. <tt>gcc 
    </tt>命令的基本用法如下: </p>
    <pre><font COLOR="#0066FF">gcc [options] [filenames]</font></pre>
    <p align="center">&nbsp;&nbsp;&nbsp; 
    命令行选项指定的操作将在命令行上每个给出的文件上执行. 
    下一小节将叙述一些你会最常用到的选项. <br>
    &nbsp; </p>
    <h4 align="center">GCC 选项</h4>
    <p>&nbsp;&nbsp;&nbsp; GCC 有超过100个的编译选项可用. 
    这些选项中的许多你可能永远都不会用到, 
    但一些主要的选项将会频繁用到. 很多的 GCC 
    选项包括一个以上的字符. 因此你必须为每个选项指定各自的连字符, 
    并且就象大多数 Linux 
    命令一样你不能在一个单独的连字符后跟一组选项. 例如, 
    下面的两个命令是不同的: </p>
    <pre><font COLOR="#0066FF">gcc -p -g test.c

gcc -pg test.c</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 第一条命令告诉 GCC 编译 <tt>test.c</tt> 时为 <tt>prof</tt> 
    命令建立剖析(profile)信息并且把调试信息加入到可执行的文件里. 
    第二条命令只告诉 GCC 为 <tt>gprof</tt> 命令建立剖析信息. <br>
    &nbsp; <br>
    &nbsp;&nbsp;&nbsp; 当你不用任何选项编译一个程序时, GCC 将会建立(假定编译成功)一个名为 
    <tt>a.out</tt> 的可执行文件. 例如, 
    下面的命令将在当前目录下产生一个叫 <tt>a.out</tt> 的文件: </p>
    <pre><font COLOR="#0066FF">gcc test.c</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 你能用 <tt>-o</tt> 
    编译选项来为将产生的可执行文件指定一个文件名来代替 <tt>a.out. </tt>例如, 
    将一个叫 <tt>count.c </tt>的 C 程序编译为名叫 <tt>count</tt> 
    的可执行文件, 你将输入下面的命令: </p>
    <pre><font COLOR="#0066FF">gcc -o count count.c</font></pre>
    <dl>
      <dd><hr>
        <p><b>注意:</b> 当你使用 <tt>-o</tt> 选项时, <tt>-o</tt> 
        后面必须跟一个文件名.&nbsp; </p>
        <hr>
      </dd>
    </dl>
    <p>&nbsp;&nbsp;&nbsp; GCC 同样有指定编译器处理多少的编译选项. <tt>-c</tt> 
    选项告诉 GCC 仅把源代码编译为目标代码而跳过汇编和连接的步骤. 
    这个选项使用的非常频繁因为它使得编译多个 C 
    程序时速度更快并且更易于管理. 缺省时 GCC 
    建立的目标代码文件有一个 <tt>.o</tt> 的扩展名. </p>
    <p align="center"><tt>&nbsp;&nbsp;&nbsp; -S</tt> 编译选项告诉 GCC 在为 C 
    代码产生了汇编语言文件后停止编译. GCC 
    产生的汇编语言文件的缺省扩展名是 <tt>.s .</tt> <tt>-E</tt> 
    选项指示编译<tt>器</tt>仅对输入文件进行预处理. 
    当这个选项被使用时, 
    预处理器的输出被送到标准输出而不是储存在文件里. </p>
    <h4 align="center">优 化 选 项</h4>
    <p>&nbsp;&nbsp;&nbsp; 当你用 GCC 编译 C 代码时, 
    它会试着用最少的时间完成编译并且使编译后的代码易于调试. 
    易于调试意味着编译后的代码与源代码有同样的执行次序, 
    编译后的代码没有经过优化. 有很多选项可用于告诉 GCC 
    在耗费更多编译时间和牺牲易调试性的基础上产生更小更快的可执行文件. 
    这些选项中最典型的是<tt>-O</tt> 和 <tt>-O2</tt> 选项. </p>
    <p>&nbsp;&nbsp;&nbsp; <tt>-O</tt> 选项告诉 GCC 对源代码进行基本优化. 
    这些优化在大多数情况下都会使程序执行的更快. <tt>-O2</tt> 选项告诉 
    GCC 产生尽可能小和尽可能快的代码. <tt>-O2</tt> 
    选项将使编译的速度比使用 <tt>-O</tt> 时慢. 
    但通常产生的代码执行速度会更快. </p>
    <p align="center">&nbsp;&nbsp;&nbsp; 除了 <tt>-O</tt> 和 <tt>-O2</tt> 优化选项外, 
    还有一些低级选项用于产生更快的代码. 这些选项非常的特殊, 
    而且最好只有当你完全理解这些选项将会对编译后的代码产生什么样的效果时再去使用. 
    这些选项的详细描述, 请参考 GCC 的指南页, 在命令行上键入 <tt>man gcc</tt> 
    . </p>
    <h4 align="center">调试和剖析选项</h4>
    <p align="center">&nbsp;&nbsp;&nbsp; GCC 支持数种调试和剖析选项. 
    在这些选项里你会最常用到的是 <tt>-g</tt> 和 <tt>-pg </tt>选项. <br>
    &nbsp;&nbsp;&nbsp; -g 选项告诉 GCC 产生能被 GNU 
    调试器使用的调试信息以便调试你的程序. GCC 提供了一个很多其他 C 
    编译器里没有的特性, 在 GCC 里你能使 -g 和 -O (产生优化代码)联用. 
    这一点非常有用因为你能在与最终产品尽可能相近的情况下调试你的代码. 
    在你同时使用这两个选项时你必须清楚你所写的某些代码已经在优化时被 
    GCC 作了改动. 关于调试 C 程序的更多信息请看下一节&quot;用 gdb 调试 
    C 程序&quot;&nbsp; . <br>
    &nbsp;&nbsp;&nbsp; -pg 选项告诉 GCC 在你的程序里加入额外的代码, 执行时, 
    产生 gprof 用的剖析信息以显示你的程序的耗时情况. 关于 gprof 
    的更多信息请参考 &quot;gprof&quot; 一节. <br>
    &nbsp; </p>
    <h3 align="center">用 gdb 调试 GCC 程序</h3>
    <p>&nbsp;&nbsp;&nbsp; Linux 包含了一个叫 gdb 的 GNU 调试程序. gdb 
    是一个用来调试 C 和 C++ 程序的强力调试器. 
    它使你能在程序运行时观察程序的内部结构和内存的使用情况. 
    以下是 gdb 所提供的一些功能: <ul>
      <li>它使你能监视你程序中变量的值.</li>
      <li>它使你能设置断点以使程序在指定的代码行上停止执行.</li>
      <li>它使你能一行行的执行你的代码.</li>
      <li><br>
        &nbsp;</li>
    </ul>
    <p>&nbsp;&nbsp;&nbsp; 在命令行上键入 <tt>gdb </tt>并按回车键就可以运行 <tt>gdb 
    </tt>了, 如果一切正常的话, <tt>gdb </tt>将被启动并且你将在屏幕上看到类似的内容: 
    </p>
    <pre><font COLOR="#0066FF">GDB is free software and you are welcome to distribute copies of it

under certain conditions; type &quot;show copying&quot; to see the conditions.

There is absolutely no warranty for GDB; type &quot;show warranty&quot; for details.

GDB 4.14 (i486-slakware-linux), Copyright 1995 Free Software Foundation, Inc.

(gdb)</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 当你启动 <tt>gdb </tt>后, 
    你能在命令行上指定很多的选项. 你也可以以下面的方式来运行 <tt>gdb</tt> 
    : </p>
    <pre><font COLOR="#0066FF">gdb &lt;fname&gt;</font></pre>
    <p align="center">&nbsp;&nbsp;&nbsp; 当你用这种方式运行 <tt>gdb</tt> , 
    你能直接指定想要调试的程序. 这将告诉<tt>gdb</tt> 装入名为 fname 
    的可执行文件. 你也可以用 <tt>gdb</tt> 
    去检查一个因程序异常终止而产生的 core 文件, 
    或者与一个正在运行的程序相连. 你可以参考 <tt>gdb </tt>指南页或在命令行上键入 
    <tt>gdb -h</tt> 得到一个有关这些选项的说明的简单列表. <br>
    &nbsp; </p>
    <h4 align="center">为调试编译代码(Compiling Code for Debugging)</h4>
    <p>&nbsp;&nbsp;&nbsp; 为了使 <tt>gdb</tt> 正常工作, 
    你必须使你的程序在编译时包含调试信息. 
    调试信息包含你程序里的每个变量的类型和在可执行文件里的地址映射以及源代码的行号.&nbsp; 
    <tt>gdb</tt> 利用这些信息使源代码和机器码相关联. </p>
    <p align="center">&nbsp;&nbsp;&nbsp; 在编译时用 -g 选项打开调试选项. <br>
    &nbsp; </p>
    <h4 align="center">gdb 基本命令</h4>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; <tt>gdb</tt> 
    支持很多的命令使你能实现不同的功能. 
    这些命令从简单的文件装入到允许你检查所调用的堆栈内容的复杂命令, 
    表27.1列出了你在用 <tt>gdb</tt> 调试时会用到的一些命令. 想了解 <tt>gdb</tt> 
    的详细使用请参考 <tt>gdb</tt> 的指南页. </p>
    <p align="center">&nbsp; <b><font SIZE="+1">表 27.1. 基本 gdb 命令.</font></b> &nbsp; 
    </p>
    <div align="center"><center><table BORDER="0">
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><i>命&nbsp;&nbsp; 令</i></td>
        <td ALIGN="LEFT"><i>描&nbsp; 述</i></td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>file</tt></td>
        <td ALIGN="LEFT">装入想要调试的可执行文件.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>kill</tt></td>
        <td ALIGN="LEFT">终止正在调试的程序.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>list</tt></td>
        <td ALIGN="LEFT">列出产生执行文件的源代码的一部分.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>next</tt></td>
        <td ALIGN="LEFT">执行一行源代码但不进入函数内部.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>step</tt></td>
        <td ALIGN="LEFT">执行一行源代码而且进入函数内部.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>run</tt></td>
        <td ALIGN="LEFT">执行当前被调试的程序</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>quit</tt></td>
        <td ALIGN="LEFT">终止 <tt>gdb</tt></td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>watch</tt></td>
        <td ALIGN="LEFT">使你能监视一个变量的值而不管它何时被改变.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>break</tt></td>
        <td ALIGN="LEFT">在代码里设置断点, 这将使程序执行到这里时被挂起.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>make</tt></td>
        <td ALIGN="LEFT">使你能不退出 <tt>gdb</tt> 就可以重新产生可执行文件.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT"><tt>shell</tt></td>
        <td ALIGN="LEFT">使你能不离开 <tt>gdb</tt> 就执行 UNIX shell 命令.&nbsp;</td>
      </tr>
    </table>
    </center></div><p>&nbsp; <br>
    &nbsp; </p>
    <p align="center">&nbsp;&nbsp;&nbsp;&nbsp; <tt>gdb</tt> 支持很多与 UNIX shell 
    程序一样的命令编辑特征. 你能象在 <tt>bash</tt> 或 <tt>tcsh</tt>里那样按 
    Tab<tt> </tt>键<tt>让</tt> <tt>gdb</tt> 帮你补齐一个唯一的命令, 
    如果不唯一的话 <tt>gdb</tt> 会列出所有匹配的命令. 
    你也能用光标键上下翻动历史命令. </p>
    <h4 align="center">gdb 应用举例</h4>
    <p>&nbsp;&nbsp;&nbsp; 本节用一个实例教你一步步的用 <tt>gdb</tt> 调试程序. 
    被调试的程序相当的简单, 但它展示了 <tt>gdb</tt> 的典型应用. <br>
    &nbsp; <br>
    &nbsp;&nbsp;&nbsp; 下面列出了将被调试的程序. 这个程序被称为 <tt>greeting</tt> 
    , 它显示一个简单的问候, 再用反序将它列出. </p>
    <pre><font COLOR="#0066FF">#include&nbsp; &lt;stdio.h&gt;



main ()

{

&nbsp; char my_string[] = &quot;hello there&quot;;



&nbsp; my_print (my_string);

&nbsp; my_print2 (my_string);

}



void my_print (char *string)

{

&nbsp; printf (&quot;The string is %s\n&quot;, string);

}



void my_print2 (char *string)

{

&nbsp; char *string2;

&nbsp; int size, i;



&nbsp; size = strlen (string);

&nbsp; string2 = (char *) malloc (size + 1);

&nbsp; for (i = 0; i &lt; size; i++)

&nbsp;&nbsp;&nbsp; string2[size - i] = string[i];

&nbsp; string2[size+1] = `\0';

&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

}</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 用下面的命令编译它: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">gcc -o test test.c</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 这个程序执行时显示如下结果: </p>
    <pre><font COLOR="#0066FF">The string is hello there

The string printed backward is</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 输出的第一行是正确的, 
    但第二行打印出的东西并不是我们所期望的. 
    我们所设想的输出应该是: </p>
    <pre><font COLOR="#0066FF">The string printed backward is ereht olleh</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 由于某些原因, <tt>my_print2</tt> 函数没有正常工作. 
    让我们用&nbsp; <tt>gdb</tt> 看看问题究竟出在哪儿, 先键入如下命令: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">gdb greeting</font></pre>
    <dl>
      <dd><hr>
        <p><b>注意:</b> 记得在编译 <tt>greeting</tt> 程序时把调试选项打开.&nbsp; </p>
        <hr>
      </dd>
    </dl>
    <p>&nbsp;&nbsp;&nbsp; 
    如果你在输入命令时忘了把要调试的程序作为参数传给 <tt>gdb</tt> , 
    你可以在 <tt>gdb</tt> 提示符下用 file 命令来载入它: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">(gdb) file greeting</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 这个命令将载入 <tt>greeting</tt> 可执行文件就象你在 <tt>gdb</tt> 
    命令行里装入它一样. </p>
    <p>&nbsp;&nbsp;&nbsp; 这时你能用 <tt>gdb</tt> 的 run 命令来运行 <tt>greeting</tt> 
    了. 当它在 <tt>gdb</tt> 里被运行后结果大约会象这样: </p>
    <pre><font COLOR="#0066FF">(gdb) run

Starting program: /root/greeting

The string is hello there

The string printed backward is

Program exited with code 041</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 这个输出和在 <tt>gdb</tt> 外面运行的结果一样. 
    问题是, 为什么反序打印没有工作? 为了找出症结所在, 我们可以在 <tt>my_print2</tt> 
    函数的 <tt>for</tt> 语句后设一个断点, 具体的做法是在 <tt>gdb</tt> 
    提示符下键入 <tt>list</tt> 命令三次, 列出源代码: </p>
    <pre><font COLOR="#0066FF">(gdb) list

(gdb) list

(gdb) list</font></pre>
    <dl>
      <dd><hr>
        <p><b>技巧:</b>&nbsp; 在 <tt>gdb</tt> 提示符下按回车健将重复上一个命令.&nbsp; 
        </p>
        <hr>
      </dd>
    </dl>
    <p>&nbsp;&nbsp;&nbsp; 第一次键入 <tt>list</tt> 命令的输出如下: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include&nbsp; &lt;stdio.h&gt;

2

3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main ()

4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char my_string[] = &quot;hello there&quot;;

6

7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_print (my_string);

8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_print2 (my_string);

9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

10</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 如果按下回车, <tt>gdb</tt> 将再执行一次 <tt>list</tt> 
    命令, 给出下列输出: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_print (char *string)

12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (&quot;The string is %s\n&quot;, string);

14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

15

16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_print2 (char *string)

17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *string2;

19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int size, i;

20</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 再按一次回车将列出 <tt>greeting</tt> 程序的剩余部分: 
    </p>
    <pre><font COLOR="#0066FF">21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = strlen (string);

22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2 = (char *) malloc (size + 1);

23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; size; i++)

24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2[size - i] = string[i];

25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2[size+1] = `\0';

26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 根据列出的源程序, 你能看到要设断点的地方在第24行, 
    在 <tt>gdb</tt> 命令行提示符下键入如下命令设置断点: </p>
    <pre><font COLOR="#0066FF">(gdb) break 24</font></pre>
    <tt><p>&nbsp;&nbsp;&nbsp; gdb</tt> 将作出如下的响应: </p>
    <pre><font COLOR="#0066FF">Breakpoint 1 at 0x139: file greeting.c, line 24

(gdb)</font></pre>
    <p>&nbsp; <br>
    &nbsp;&nbsp;&nbsp; 现在再键入 <tt>run </tt>命令, 将产生如下的输出: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">Starting program: /root/greeting

The string is hello there



Breakpoint 1, my_print2 (string = 0xbfffdc4 &quot;hello there&quot;) at greeting.c :24

24&nbsp; string2[size-i]=string[i]</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 你能通过设置一个观察 <tt>string2[size - i]</tt> 
    变量的值的观察点来看出错误是怎样产生的, 做法是键入: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">(gdb) watch string2[size - i]</font></pre>
    <tt><p>&nbsp;&nbsp;&nbsp; gdb</tt> 将作出如下回应: </p>
    <pre><font COLOR="#0066FF">Watchpoint 2: string2[size - i]</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 现在可以用 <tt>next</tt> 命令来一步步的执行 <tt>for</tt> 
    循环了: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">(gdb) next</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 经过第一次循环后,&nbsp; <tt>gdb</tt> 告诉我们 <tt>string2[size 
    - i]</tt> 的值是 <tt>`h`.</tt> <tt>gdb</tt> 用如下的显示来告诉你这个信息: 
    <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">Watchpoint 2, string2[size - i]

Old value = 0 `\000'

New value = 104 `h'

my_print2(string = 0xbfffdc4 &quot;hello there&quot;) at greeting.c:23

23 for (i=0; i&lt;size; i++)</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 这个值正是期望的. 
    后来的数次循环的结果都是正确的. 当 <tt>i=10 </tt>时, 表达式 <tt>string2[size 
    - i]</tt> 的值等于 <tt>`e`</tt>,&nbsp; <tt>size - i</tt> 的值等于 1, 
    最后一个字符已经拷到新串里了. </p>
    <p>&nbsp;&nbsp;&nbsp; 如果你再把循环执行下去, 
    你会看到已经没有值分配给 <tt>string2[0] </tt>了,<tt>&nbsp;</tt> 
    而它是新串的第一个字符, 因为 <tt>malloc</tt> 
    函数在分配内存时把它们初始化为空(null)字符. 所以 <tt>string2</tt> 
    的第一个字符是空字符. 这解释了为什么在打印 <tt>string2</tt> 
    时没有任何输出了. </p>
    <p>&nbsp;&nbsp;&nbsp; 现在找出了问题出在哪里, 修正这个错误是很容易的. 
    你得把代码里写入 <tt>string2</tt> 的第一个字符的的偏移量改为 <tt>size 
    - 1</tt> 而不是 <tt>size</tt>. 这是因为 <tt>string2</tt> 的大小为 12, 
    但起始偏移量是 0, 串内的字符从偏移量 0 到 偏移量 10, 偏移量 11 
    为空字符保留. </p>
    <p>&nbsp;&nbsp;&nbsp; 为了使代码正常工作有很多种修改办法. 
    一种是另设一个比串的实际大小小 1 的变量. 
    这是这种解决办法的代码: </p>
    <pre><font COLOR="#0066FF">#include&nbsp; &lt;stdio.h&gt;



main ()


{

&nbsp; char my_string[] = &quot;hello there&quot;;



&nbsp; my_print (my_string);

&nbsp; my_print2 (my_string);

}



my_print (char *string)

{

&nbsp; printf (&quot;The string is %s\n&quot;, string);

}



my_print2 (char *string)

{

&nbsp; char *string2;

&nbsp; int size, size2, i;



&nbsp; size = strlen (string);

&nbsp; size2 = size -1;

&nbsp; string2 = (char *) malloc (size + 1);

&nbsp; for (i = 0; i &lt; size; i++)

&nbsp;&nbsp;&nbsp; string2[size2 - i] = string[i];

&nbsp; string2[size] = `\0';

&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

}</font></pre>
    <h3 align="center">另外的 C 编程工具</h3>
    <p align="center">&nbsp;&nbsp;&nbsp; Slackware Linux 
    的发行版中还包括一些我们尚未提到的 C 开发工具. 
    本节将介绍这些工具和它们的典型用法. </p>
    <h4 align="center">xxgdb</h4>
    <tt><p>&nbsp;&nbsp;&nbsp; xxgdb</tt> 是 <tt>gdb</tt> 的一个基于 X Window 
    系统的图形界面.&nbsp; <tt>xxgdb </tt>包括了命令行版的 <tt>gdb</tt> 
    上的所有特性.&nbsp; <tt>xxgdb </tt>使你能通过按按钮来执行常用的命令. 
    设置了断点的地方也用图形来显示. <br>
    &nbsp; <br>
    &nbsp;&nbsp;&nbsp; 你能在一个 <tt>Xterm</tt> 
    窗口里键入下面的命令来运行它: </p>
    <pre><font COLOR="#0066FF">xxgdb</font></pre>
    <p align="center">&nbsp;&nbsp;&nbsp; 你能用 <tt>gdb</tt> 
    里任何有效的命令行选项来初始化 <tt>xxgdb</tt> . 此外 <tt>xxgdb</tt> 
    也有一些特有的命令行选项, 表 27.2 列出了这些选项. <br>
    &nbsp; <b><font SIZE="+1">表 27.2.&nbsp; xxgdb 命令行选项.</font></b> &nbsp; &nbsp; </p>
    <div align="center"><center><table BORDER="0">
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT" WIDTH="70"><i>选&nbsp; 项</i></td>
        <td ALIGN="LEFT"><i>描&nbsp; 述</i></td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT" WIDTH="70"><tt>db_name</tt></td>
        <td ALIGN="LEFT">指定所用调试器的名字, 缺省是 <tt>gdb</tt>.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT" WIDTH="70"><tt>db_prompt</tt></td>
        <td ALIGN="LEFT">指定调试器提示符, 缺省为 <tt>gdb</tt>.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT" WIDTH="70"><tt>gdbinit</tt></td>
        <td ALIGN="LEFT"><p align="center">指定初始化 <tt>gdb</tt> 
        的命令文件的文件名, 缺省为 <tt>.gdbinit</tt>.&nbsp; </td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT" WIDTH="70"><tt>nx</tt></td>
        <td ALIGN="LEFT">告诉 <tt>xxgdb</tt> 不执行 <tt>.gdbinit</tt> 文件.</td>
      </tr>
      <tr ALIGN="LEFT" rowspan="1">
        <td ALIGN="LEFT" WIDTH="70"><tt>bigicon</tt></td>
        <td ALIGN="LEFT">使用大图标.</td>
      </tr>
    </table>
    </center></div><p align="center">&nbsp; <br>
    &nbsp; <br>
    &nbsp; </p>
    <h4 align="center">calls</h4>
    <tt><p>&nbsp;&nbsp;&nbsp;&nbsp; </tt>你可以在 <tt>sunsite.unc.edu</tt> FTP 
    站点用下面的路径: </p>
    <p><tt><font COLOR="#3366FF">/pub/Linux/devel/lang/c/calls.tar.Z</font></tt> </p>
    <p>&nbsp;&nbsp;&nbsp; 来取得 <tt>calls , </tt>一些旧版本的 Linux CD-ROM 
    发行版里也附带有. 因为它是一个有用的工具, 
    我们在这里也介绍一下. 如果你觉得有用的话, 从 BBS, FTP, 或另一张CD-ROM 
    上弄一个拷贝.&nbsp; <tt>calls</tt> 调用 GCC 
    的预处理器来处理给出的源程序文件, 
    然后输出这些文件的里的函数调用树图. <br>
    &nbsp; <dl>
      <dd><hr>
        <p><b>注意:</b> 在你的系统上安装 <tt>calls</tt> , 
        以超级用户身份登录后执行下面的步骤: 1. 解压和 <tt>untar</tt> 文件. 
        2. <tt>cd</tt> 进入 <tt>calls</tt> untar 后建立的子目录. 3. 把名叫 <tt>calls</tt> 
        的文件移动到 <tt>/usr/bin</tt> 目录. 4. 把名叫 <tt>calls.1</tt> 
        的文件移动到目录 <tt>/usr/man/man1</tt> . 5. 删除 <tt>/tmp/calls</tt> 目录. 
        这些步骤将把 <tt>calls</tt> 程序和它的指南页安装载你的系统上.&nbsp; </p>
        <hr>
      </dd>
    </dl>
    <p>&nbsp;&nbsp;&nbsp; 当 <tt>calls</tt> 打印出调用跟踪结果时, 
    它在函数后面用中括号给出了函数所在文件的文件名: </p>
    <pre><font COLOR="#0066FF">main [test.c]</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 如果函数并不是向 <tt>calls</tt> 给出的文件里的,&nbsp; 
    <tt>calls </tt>不知道所调用的函数来自哪里, 则只显示函数的名字: </p>
    <pre><font COLOR="#0066FF">printf</font></pre>
    <tt><p>&nbsp;&nbsp;&nbsp; calls</tt> 不对递归和静态函数输出. 
    递归函数显示成下面的样子: </p>
    <pre><font COLOR="#0066FF">fact &lt;&lt;&lt; recursive in factorial.c &gt;&gt;&gt;</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 静态函数象这样显示: </p>
    <pre><font COLOR="#0066FF">total [static in calculate.c]</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 作为一个例子, 假设用 <tt>calls</tt> 处理下面的程序: <br>
    &nbsp; </p>
    <pre><font COLOR="#0066FF">#include &lt;stdio.h&gt;



main ()

{

char my_string[] = &quot;hello there&quot;;

my_print (my_string);

my_print2(my_string);

}



my_print (char *string)

{

printf (&quot;The string is %s\n&quot;, string);

}



my_print2 (char *string)

{

&nbsp; char *string2;

&nbsp; int size, size2, i;



&nbsp; size = strlen (string);

&nbsp; size2 = size -1;

&nbsp; string2 = (char *) malloc (size + 1);

&nbsp; for (i = 0; i &lt; size; i++)

&nbsp;&nbsp;&nbsp; string2[size2 - i] = string[i];

&nbsp; string2[size] = `\0';

&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

}</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 将产生如下的输出: </p>
    <pre><font COLOR="#0066FF">&nbsp;&nbsp;&nbsp; 1 main [test.c]

&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_print [test.c]

&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf

&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_print2 [test.c]

&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen

&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc

&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf</font></pre>
    <tt><p align="center">calls</tt> 有很多命令行选项来设置不同的输出格式, 
    有关这些选项的更多信息请参考 <tt>calls</tt> 的指南页. 
    方法是在命令行上键入 <tt>calls -h</tt> . <br>
    &nbsp; <br>
    &nbsp; </p>
    <h4 align="center">cproto</h4>
    <tt><p>&nbsp;&nbsp;&nbsp; cproto</tt> 读入 C 
    源程序文件并自动为每个函数产生原型申明. 用 <tt>cproto</tt> 
    可以在写程序时为你节省大量用来定义函数原型的时间. <br>
    &nbsp;&nbsp;&nbsp; 如果你让 <tt>cproto</tt> 处理下面的代码: </p>
    <pre><font COLOR="#0066FF">#include&nbsp; &lt;stdio.h&gt;



main ()

{

&nbsp; char my_string[] = &quot;hello there&quot;;

&nbsp; my_print (my_string);

&nbsp; my_print2(my_string);

}



my_print (char *string)

{

&nbsp; printf (&quot;The string is %s\n&quot;, *string);

}



my_print2 (char *string)

{

&nbsp; char *string2;

&nbsp; int size, size2, i;



&nbsp; size = strlen (string);

&nbsp; size2 = size -1;

&nbsp; string2 = (char *) malloc (size + 1);

&nbsp; for (i = 0; i &lt; size; i++)

&nbsp;&nbsp;&nbsp; string2[size2 - i] = string[i];

&nbsp; string2[size] = `\0';

&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

}</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 你将得到下面的输出: </p>
    <pre><font COLOR="#0066FF">/* test.c */

int main(void);

int my_print(char *string);

int my_print2(char *string);</font></pre>
    <p align="center">&nbsp;&nbsp;&nbsp; 
    这个输出可以重定向到一个定义函数原型的包含文件里. </p>
    <h4 align="center">indent</h4>
    <tt><p>&nbsp;&nbsp;&nbsp; indent</tt> 实用程序是 Linux 
    里包含的另一个编程实用工具. 
    这个工具简单的说就为你的代码产生美观的缩进的格式. <tt>indent</tt> 
    也有很多选项来指定如何格式化你的源代码.这些选项的更多信息请看<tt>indent</tt> 
    的指南页, 在命令行上键入 <tt>indent -h</tt> . <br>
    &nbsp; </p>
    <p>&nbsp;&nbsp;&nbsp; 下面的例子是 <tt>indent </tt>的缺省输出: </p>
    <p>&nbsp;&nbsp;&nbsp; 运行 <tt>indent </tt>以前的 C 代码: </p>
    <pre><font COLOR="#0066FF">#include&nbsp; &lt;stdio.h&gt;



main () {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char my_string[] = &quot;hello there&quot;;

&nbsp; my_print (my_string);

&nbsp;&nbsp;&nbsp;&nbsp; my_print2(my_string); }



my_print (char *string)

{

&nbsp; printf&nbsp;&nbsp;&nbsp; (&quot;The string is %s\n&quot;, *string);

}



my_print2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (char *string) {

&nbsp;&nbsp;&nbsp; char *string2;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int size, size2, i;



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = strlen (string);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size2 = size -1;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2 = (char *) malloc (size + 1);

&nbsp; for (i = 0; i &lt; size; i++)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2[size2 - i] = string[i];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2[size] = `\0';


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

}</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 运行 <tt>indent </tt>后的 C 代码: </p>
    <pre><font COLOR="#0066FF">#include&nbsp; &lt;stdio.h&gt;



main ()

{

&nbsp; char my_string[] = &quot;hello there&quot;;

&nbsp; my_print (my_string);

&nbsp; my_print2 (my_string);

}



my_print (char *string)

{

&nbsp; printf (&quot;The string is %s\n&quot;, *string);

}



my_print2 (char *string)

{

&nbsp; char *string2;

&nbsp; int size, size2, i;



&nbsp; size = strlen (string);

&nbsp; size2 = size -1;

&nbsp; string2 = (char *) malloc (size + 1);

&nbsp; for (i = 0; i &lt; size; i++)

&nbsp;&nbsp;&nbsp; string2[size2 - i] = string[i];

&nbsp; string2[size] = `\0';

&nbsp; printf (&quot;The string printed backward is %s\n&quot;, string2);

}</font></pre>
    <tt><p align="center">&nbsp;&nbsp;&nbsp;&nbsp;</tt> <tt>indent </tt>并不改变代码的实质内容, 
    而只是改变代码的外观. 使它变得更可读, 这永远是一件好事. </p>
    <h4 align="center">gprof</h4>
    <tt><p>&nbsp;&nbsp;&nbsp; gprof</tt> 是安装在你的 Linux 系统的 <tt>/usr/bin</tt> 
    目录下的一个程序. 
    它使你能剖析你的程序从而知道程序的哪一个部分在执行时最费时间. 
    </p>
    <p><tt>&nbsp;&nbsp;&nbsp; gprof</tt> 
    将告诉你程序里每个函数被调用的次数和每个函数执行时所占时间的百分比. 
    你如果想提高你的程序性能的话这些信息非常有用. </p>
    <p>&nbsp;&nbsp;&nbsp; 为了在你的程序上使用 gprof, 
    你必须在编译程序时加上 -pg 选项. 
    这将使程序在每次执行时产生一个叫 gmon.out 的文件. gprof 
    用这个文件产生剖析信息. </p>
    <p>&nbsp;&nbsp;&nbsp; 在你运行了你的程序并产生了 gmon.out 
    文件后你能用下面的命令获得剖析信息: </p>
    <pre><font COLOR="#0066FF">gprof &lt;program_name&gt;</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 参数 program_name 是产生 gmon.out 文件的程序的名字. <dl>
      <dd><hr>
        <p><b>技巧:</b> gprof 产生的剖析数据很大, 
        如果你想检查这些数据的话最好把输出重定向到一个文件里.&nbsp; </p>
        <hr>
      </dd>
    </dl>
    <h4 align="center">f2c 和 p2c</h4>
    <tt><p>&nbsp;&nbsp;&nbsp; f2c</tt> 和 <tt>p2c </tt>是两个源代码转换程序. f2c 
    把 FORTRAN 代码转换为 C 代码, p2c 把 Pascal 代码转换为 C 代码. 
    当你安装 GCC 时这两个程序都会被安装上去. </p>
    <p>&nbsp;&nbsp;&nbsp; 如果你有一些用 FORTRAN 或 Pascal 写的代码要用 C 
    重写的话, f2c 和 p2c 对你非常有用. 这两个程序产生的 C 
    代码一般不用修改就直接能被 GCC 编译. </p>
    <p>&nbsp;&nbsp;&nbsp; 如果要转换的 FORTRAN 或 Pascal 
    程序比较小的话可以直接使用 f2c 或 p2c 不用加任何选项. 
    如果要转换的程序比较庞大, 
    包含很多文件的话你可能要用到一些命令行选项. </p>
    <p>&nbsp;&nbsp;&nbsp; 在一个 FORTRAN 程序上使用 f2c , 输入下面的命令: </p>
    <pre><font COLOR="#0066FF">f2c my_fortranprog.f</font></pre>
    <dl>
      <dd><hr>
        <p><b>注意:</b> <tt>f2c</tt> 要求被转换的程序的扩展名为 <tt>.f</tt> 或 a <tt>.F</tt> 
        .&nbsp; </p>
        <hr>
      </dd>
    </dl>
    <p>&nbsp;&nbsp;&nbsp; 要把一个Pascal 程序装换为 C 程序, 输入下面的命令: </p>
    <pre><font COLOR="#0066FF">p2c my_pascalprogram.pas</font></pre>
    <p>&nbsp;&nbsp;&nbsp; 这两个程序产生的 C 
    源代码的文件名都和原来的文件名相同, 但扩展名由 .f 或 .pas 变为 
    .c. <br>
    &nbsp; </p>
    <p>　</td>
  </tr>
</table>
<i>

<p align="center"></i>&nbsp; <br>
&nbsp; </p>
</body>
</html>
