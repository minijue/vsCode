<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0061)http://person.zj.cninfo.net/~yao/document/delphi/delphi02.htm -->
<HTML><HEAD><TITLE>用Delphi实现程序间的数据传递</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<STYLE>TD {
	FONT-FAMILY: 宋体; FONT-SIZE: 10.5pt
}
</STYLE>

<META content="Microsoft FrontPage 4.0" name=GENERATOR></HEAD>
<BODY>
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../progidx.htm">编程技巧</a> --&gt; 
      <a href="Del_idx.htm">DELPHI</a></b></span></td>   
  </tr>   
</table>   
</center></div><div align="center"><center>   
   
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"   
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">   
  <tr>   
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"   
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"   
    bordercolordark="#FFFFFF">   
      <tr>   
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font   
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"   
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>   
      </tr>   
    </table>   
      <P align=center><STRONG>用Delphi实现程序间的数据传递</STRONG></P>
      <P 
      align=justify>在实际应用中，我们经常需要多个程序相互配合来完成某些特定功能。例如两个应用程序间的同步、互斥；应用程序在起第二份实例时的参数自动传递…。要实现这些功能，就必须能实现程序间的数据传递。</P>
      <P 
      align=justify>有些特殊的高级技术可在不同的程序间传递数据，如剪贴板、动态数据交换以及OLE自动化，但有条件限制并且相对较复杂。这里，我介绍三种有效的底层技术，希望对编程爱好者有所帮助。</P>
      <UL>
        <LI><STRONG>利用WM_COPYDATA消息</STRONG> </LI></UL>
      <P>　</P>
      <P align=justify>使用该消息涉及一个TcopyDataStruct结构类型的指针。该结构中有三个成员：</P>
      <P align=justify>dwData 是一个32位的附加参数</P> 
      <P align=justify>cbData 表示要传递的数据区的大小</P> 
      <P align=justify>lpData 表示要传递的数据区的指针</P> 
      <P align=justify>下面举个例子。该例子由两个程序构成，分别为SendData和GetData。</P> 
      <BLOCKQUOTE> 
        <BLOCKQUOTE> 
          <BLOCKQUOTE> 
            <P  
            align=justify>SendData程序向GetData程序发送消息，并传递edit1中的字符串；GetData在收到消息后，把SendData发送的字符串接受下来，并显示在相应的edit1中。</P></BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE> 
      <OL> 
        <OL> 
          <LI>SendData程序：  
          <P align=justify>……</P> 
          <P align=justify>var</P> 
          <P align=justify>Form1: TForm1;</P> 
          <P align=justify>implementation</P> 
          <P align=justify>{$R *.DFM}</P> 
          <P align=justify>procedure TForm1.Button1Click(Sender: TObject);</P> 
          <P align=justify>var</P> 
          <P align=justify>ds: TCopyDataStruct;</P> 
          <P align=justify>hd: THandle;</P> 
          <P align=justify>begin</P> 
          <P align=justify>ds.cbData := Length (Edit1.Text) + 1;</P> 
          <P align=justify>GetMem (ds.lpData, ds.cbData ); //为传递的数据区分配内存 </P> 
          <P align=justify>StrCopy (ds.lpData, PChar (Edit1.Text));</P> 
          <P align=justify>Hd := FindWindow (nil, 'Form2'); // 获得接受窗口的句柄 </P> 
          <P align=justify>if Hd &lt;&gt; 0 then</P> 
          <P align=justify>SendMessage (Hd, WM_COPYDATA, Handle,</P> 
          <P align=justify>Cardinal(@ds)) // 发送WM_COPYDATA消息 </P> 
          <P align=justify>else</P> 
          <P align=justify>ShowMessage ('目标窗口没找到！');</P> 
          <P align=justify>FreeMem (ds.lpData); //释放资源 </P> 
          <P align=justify>end;</P> 
          <LI>GetData程序： </LI></OL></OL> 
      <P>　</P> 
      <P align=justify>TForm2 = class(TForm)</P> 
      <P align=justify>Edit1: TEdit;</P> 
      <P align=justify>private</P> 
      <P align=justify>{ Private declarations }</P> 
      <P align=justify>public</P> 
      <P align=justify>procedure Mymessage(var t:TWmCopyData);message  
      WM_COPYDATA;</P> 
      <P align=justify>{ Public declarations }</P> 
      <P align=justify>end;</P> 
      <P align=justify>var</P> 
      <P align=justify>Form2: TForm2;</P> 
      <P align=justify>implementation</P> 
      <P align=justify>procedure TForm2.Mymessage(var t:TWmCopyData);</P> 
      <P align=justify>begin</P> 
      <P  
      align=justify>Edit1.text:=StrPas(t.CopyDataStruct^.lpData);//接受数据并显示。</P> 
      <P align=justify>end;</P> 
      <P align=justify>使用这种方法是WIN32应用程序进行交互的最简单的方法。</P> 
      <UL> 
        <LI><STRONG>使用全局原子</STRONG> </LI></UL> 
      <BLOCKQUOTE> 
        <BLOCKQUOTE> 
          <P  
          align=justify>Win32系统中，为了实现信息共享，系统维护了一张全局原子表。每个原子中存放了一些共享数据。关于对原子的操作，有一组专门的API函数：</P> 
          <P align=justify>GlobalAddAtom 在表中增加全局原子</P> 
          <P align=justify>GlobalDeleteAtom 在表中删除全局原子</P> 
          <P align=justify>GlobalFindAtom 在表中搜索全局原子</P> 
          <P align=justify>GlobalGetAtomName 从表中获取全局原子</P> 
          <P  
          align=justify>笔者用这种方法实现了避免程序二次启动，但把第二次启动所带的参数传到第一个实例中以进行相应的处理的程序。基本处理如下：</P> 
          <P align=justify>在工程文件中：</P> 
          <P align=justify>program Pvdde;</P> 
          <P align=justify>uses</P> 
          <P align=justify>Forms,shellapi,Windows,dialogs,dde in 'dde.pas'  
          {Form1};</P> 
          <P align=justify>{$R *.RES}</P> 
          <P align=justify>begin</P> 
          <P align=justify>if GlobalFindAtom(PChar('PDDE_IS_RUNNING')) = 0  
          then</P> 
          <P align=justify>//避免二次启动</P> 
          <P align=justify>begin</P> 
          <P align=justify>K:=GlobalAddAtom(PChar('PDDE_IS_RUNNING'));</P> 
          <P align=justify>Application.Initialize;</P> 
          <P align=justify>Application.CreateForm(TForm1, Form1);</P> 
          <P align=justify>Application.Run;</P> 
          <P align=justify>end</P> 
          <P align=justify>else</P> 
          <P align=justify>begin</P> 
          <P align=justify>//传递二次启动时的参数到第一个实例</P> 
          <P align=justify>H := FindWindow(PChar('TForm1'), PChar('资料保密  
          严禁外传'));</P> 
          <P align=justify>if ParamCount &gt; 0 then</P> 
          <P align=justify>begin</P> 
          <P align=justify>L := GlobalAddAtom(PChar(ParamStr(1)));</P> 
          <P align=justify>if H&lt;&gt;0 then</P> 
          <P align=justify>SendMessage(H, WM_MYMESSAGE, 0, L); </P> 
          <BLOCKQUOTE> 
            <BLOCKQUOTE> 
              <BLOCKQUOTE> 
                <BLOCKQUOTE> 
                  <BLOCKQUOTE> 
                    <P align=justify>{ 传递原子句柄  
              }</P></BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE> 
          <P align=justify>GlobalDeleteAtom(L); { 使用后释放 }</P> 
          <P align=justify>end;</P> 
          <P align=justify>Application.Terminate;</P> 
          <P align=justify>end;</P> 
          <P align=justify>end.</P> 
          <P align=justify>在相应的窗口单元dde.pas增加对自定义消息WM_MYMESSAGE的处理：</P> 
          <P align=justify>procedure TForm1.MyMessage(var T:TMessage); </P> 
          <P align=justify>{对 WM_MYMESSAGE消息进行处理 }</P> 
          <P align=justify>var</P> 
          <P align=justify>P:Array [0..255] of char;</P> 
          <P align=justify>begin</P> 
          <P align=justify>GlobalGetAtomName(T.LParam, P,255); { 接受数据到p数组中 }</P> 
          <P align=justify>。。。</P> 
          <P align=justify>end;</P></BLOCKQUOTE></BLOCKQUOTE> 
      <UL> 
        <LI><STRONG>使用存储映象文件</STRONG> </LI></UL> 
      <P>　</P> 
      <P align=justify>这种方法相对较复杂一些。</P> 
      <P align=justify>当Win95与Winows  
      Nt向内存中装载文件时，使用了特殊的全局内存区。在该区域内，应用程序的虚拟内存地址和文件中的相应位置一一对应。由于所有进程共享了一个用于存储映象文件的全局内存区域，因而当两个进程装载相同模块（应用程序或DLL文件）时，它们实际可以在内存中共享其执行代码。</P> 
      <P  
      align=justify>笔者通过调用一个带有特殊参数的CreateFileMapping函数，来间接达到程序间共享内存的目的。下面简要解释一下该函数。</P> 
      <P align=justify>HANDLE CreateFileMapping(</P> 
      <P align=justify>HANDLE hFile, //文件句柄 </P> 
      <P align=justify>LPSECURITY_ATTRIBUTES lpFileMappingAttributes, //  
      可选安全属性</P> 
      <P align=justify>DWORD flProtect, // 映象文件保护方式 </P> 
      <P align=justify>DWORD dwMaximumSizeHigh, // 映象文件区域的底值 </P> 
      <P align=justify>DWORD dwMaximumSizeLow, // 映象文件区域的顶值 </P> 
      <P align=justify>LPCTSTR lpName // 映象文件的名字</P> 
      <P align=justify>); </P> 
      <P align=justify>如果hFile是0xFFFFFFFF，在调用程序中必须指定dwMaximumSizeHigh  
      和dwMaximumSizeLow参数的值以确定映象文件的大小。通过这样的参数指定，该函数就创建了一个由操作系统页文件支持的特殊逻辑映象文件，而不是由实际操作系统的文件支持的逻辑映象文件。这个逻辑映象文件可以通过复制、继承或者按名字来达到共享。至于其它参数的详细说明，请参看在线帮助。</P> 
      <P  
      align=justify>在建立了映象文件之后，我们可以通过调用另外一个API函数MapViewOfFile来访问它的内存，该函数会返回一个指向共享内存块的特定指针。</P> 
      <P align=justify>LPVOID MapViewOfFile(</P> 
      <P align=justify>HANDLE hFileMappingObject, // 映象文件句柄 </P> 
      <P align=justify>DWORD dwDesiredAccess, // 访问方式 </P> 
      <P align=justify>DWORD dwFileOffsetHigh, // 映象文件区域的底值 </P> 
      <P align=justify>DWORD dwFileOffsetLow, // 映象文件区域的顶值</P> 
      <P align=justify>DWORD dwNumberOfBytesToMap // 映射字节数</P> 
      <P align=justify>);</P> 
      <P align=justify>如果 dwNumberOfBytesToMap 是0，映射整个文件。</P> 
      <P align=justify>以下举例说明：</P> 
      <P align=justify>private</P> 
      <P align=justify>hMapFile: THandle;</P> 
      <P align=justify>MapFilePointer: Pointer;</P> 
      <P align=justify>public</P> 
      <P align=justify>{ Public declarations }</P> 
      <P align=justify>end;</P> 
      <P align=justify>var</P> 
      <P align=justify>Form1: TForm1;</P> 
      <P align=justify>implementation</P> 
      <P align=justify>{$R *.DFM}</P> 
      <P align=justify>procedure TForm1.FormCreate(Sender: TObject);</P> 
      <P align=justify>begin</P> 
      <P align=justify>hMapFile := CreateFileMapping (</P> 
      <P align=justify>$FFFFFFFF, // 特殊内存映射句柄</P> 
      <P align=justify>nil, page_ReadWrite, 0,10000, </P> 
      <P align=justify>'DdhDemoMappedFile'); // 文件名</P> 
      <P align=justify>if hMapFile &lt;&gt; 0 then</P> 
      <P align=justify>MapFilePointer := MapViewOfFile (</P> 
      <P align=justify>hMapFile, // 上面映象文件的句柄</P> 
      <P align=justify>File_Map_All_Access, </P> 
      <P align=justify>0, 0, 0) // 访问整个映象文件</P> 
      <P align=justify>else</P> 
      <P align=justify>ShowMessage ('hMapFile = 0');</P> 
      <P align=justify>if MapFilePointer = nil then</P> 
      <P align=justify>ShowMessage ('MapFilePointer = nil');</P> 
      <P align=justify>end;</P> 
      <P align=justify>　</P>
      <P align=justify>procedure TForm1.BtnWriteClick(Sender: TObject);</P> 
      <P align=justify>begin</P> 
      <P align=justify>StrCopy (PChar (MapFilePointer),</P> 
      <P align=justify>PChar (EditWrite.Text));//把内容写入共享内存</P> 
      <P align=justify>end;</P> 
      <P align=justify>　</P>
      <P align=justify>procedure TForm1.BtnReadClick(Sender: TObject);</P> 
      <P align=justify>var</P> 
      <P align=justify>S: string;</P> 
      <P align=justify>begin</P> 
      <P align=justify>S := PChar (MapFilePointer);//从共享内存读出内容</P> 
      <P align=justify>EditRead.Text := S;</P> 
      <P align=justify>end;</P> 
      <BLOCKQUOTE> 
        <P  
        align=justify>用这种方法，不但可以在不同的程序之间共享数据，还可以在同一程序的不同实例间共享数据。为了及时通知其它进程共享数据的变化，可以自定义一条用户消息，通过发消息来实现，这里不再赘述。</P></BLOCKQUOTE> 
      <P>利用以上三种方法均可以有效地实现数据传递、共享，所有的例子程序均在Delphi 3.0,4.0下调试通过。如需源码，写信至<A  
      href="mailto:wj_email@yahoo.com">wj_email@yahoo.com</A>索要</P>   
      <p>　   
    </td>   
  </tr>   
</table>   
</center></div>   
<p>　</p>
</BODY></HTML>
