<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0061)http://person.zj.cninfo.net/~yao/document/delphi/delphi03.htm -->
<HTML><HEAD><TITLE>DELPHI构件制作方法</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<STYLE>TD {
	FONT-FAMILY: 宋体; FONT-SIZE: 10.5pt
}
</STYLE>

<META content="Microsoft FrontPage 4.0" name=GENERATOR></HEAD>
<BODY>
<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../progidx.htm">编程技巧</a> --&gt; 
      <a href="Del_idx.htm">delphi</a></b></span></td>   
  </tr>   
</table>   
</center></div><div align="center"><center>   
   
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"   
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">   
  <tr>   
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"   
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"   
    bordercolordark="#FFFFFF">   
      <tr>   
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font   
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"   
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>   
      </tr>   
    </table>   
      <P align=center><STRONG>DELPHI构件制作方法</STRONG></P>
      <P><BR>Delphi作为RAD工具，以其快速编译和友好的可视化界面受到广泛欢迎。Delphi提供了很多现成构件，而且随着版本更新不 <BR>断增加新构件。另外还可以买到第三方开发的特色构件，或从因特网下载免费构件。这些构件足以支持一般应用系统开发。但应用开发人员仍有必要自己制作构件。采用构件形式可以把对象严密封装，并加上一层直观外壳，有利于软件调试和代码重用。开发群体以构件为功能单位分工协作，比较容易实现工程化管理，从软件规划设计到测试修改都可以减少意外差错，大大提高工作效率。成熟的构件还可以作为商品软件出售，带来附加效益，且有利于软件开发的社会化分工协作。Delphi的构件使用和构件制作采用同样的工作环境和相似的编程方法，只要弄清基本原理，制作构件无需学习多少新东西。 <BR><BR>基本概念 <BR>制作构件的基本过程可以概括为： 
      <BR>1．编写构件单元（unit）。其中包含构件声明和构件实现代码。 <BR>2．按照与普通Delphi单元同样的方法编译和调试构件单元。 
      <BR>3．创建构件注册单元。其中用uses语句连接构件单元，并用Register过程完成构件的注册。 
      <BR>4．编写构件联机帮助信息，并编译成标准Windows帮助文件。全部工作完成后，生成构件单元二进制文件（．DCU）、构件注 
      <BR>册源文件（．PAS）和帮助信息文件（．HLP）及附加的关键词文件（．KWF）。用户拿到这些文件后，就可以安装使用了。在Delphi环境下调用菜单命令，启动安装过程（安装过程中需指定注册文件名），可以把构件注册到Delphi的VCL库中，并在构件工具条上生成一个新按钮。借助HelpInst安装工具可以把关键词文件并入Dephi帮助索引系统，用F1键实现联机帮助。这样制作出的．DCU文件与一般Delphi单元没有根本区别，即使不安装到VCL库中也可以由其他单元直接调用。最大的区别在于：构件单元中某些属性和事件声明为published，从而在程序设计期对用户是可见的，用户可以通过对象编辑窗口（ObjectInspector）访问这些属性和事件。这是可视化程序设计的关键所在。 <BR><BR>对象的继承与修改 
      <BR>制作构件第一件事就是选择适当的Delphi对象类型作为父对象，以派生新的对象。子对象可以继承父对象的全部非private部 
      <BR>件，但不能摆脱不需要的部件。因此，所选父对象应尽可能多地包含子对象所需的属性、事件和方法，但不应包含子对象不需要的东西。TComponent是所有Delphi构件的基点，但若直接从TComponent派生新构件，很多东西就需要自己从头做起。一般只有非可视构件才直接从TComponent派生。Delphi提供了若干专门用于制作控件（可视构件）的对象类型，都是从TControl和TWinControl派生而来。<br>
      其派生关系如下： 
      <BR>TControl－－－TGraphicControl－－－TCustomLabel 
      <BR>TWinControl－－TCustomControl－－－TCustomGrid 
      <BR>－－－TButtonControl－－TCustomGroupBox 
      <BR>－－－TScrollingWinControl－－TCustomPanel <BR>－－－TCustomComboBox 
      <BR>－－－TCustomEdit <BR>－－－TCustomListBox 
      <BR>TControl的子类型用于非窗口式控件，TWinControl的子类型 
      <BR>则用于窗口式控件。除非特殊需要，一般不直接从TControl和 <BR>TWinControl派生新控件，而是从其子类型派生。这样可以充分利 
      <BR>用原有的属性、事件和方法，减少很多工作量。 <BR>在这些构件类型中，非通用的属性、事件和方法都声明为 
      <BR>protected。这样可以禁止构件用户访问，又能被子类型继承和修 <BR>改。在新构件中，可以简单地把继承来的属性和事件重新声明为 
      <BR>published，使构件用户能在设计期通过对象编辑窗口访问，也可 
      <BR>以进而修改属性的默认值和读写方式，或是重载（override）事件 <BR>处理子过程和其他构件方法，以修改其中的程序代码。重声明可以 
      <BR>放宽访问权限，但不能 相反，例如，不可能把published属性 <BR>重声明为private或protected。 
      <BR>为了增加新功能，常常需要定义全新的属性、事件和方法。定 <BR>义时，一般总是把对用户开放的属性和事件声明为published，把 
      <BR>方法声明为public或protected。 <BR><BR>构件属性 <BR>在构件中，属性和方法往往可以相互替代。对构件用户来说， 
      <BR>属性比方法更直观简便。因此，只要可能，应尽量以属性取代方法。 
      <BR>属性类型包括简单类型（numeric，character，string）、枚 
      <BR>举类型、集合类型、对象类型（例如font）和数组类型（例如TStrings <BR>类型中的Strings）。其定义方法如下： 
      <BR>type <BR>private <BR>FLayers：Integer；｛内部存储用的变量｝ 
      <BR>functionGetLayers：Integer；｛用来读属性值的方法｝ 
      <BR>procedureSetLayers（ALayers：Integer）；｛用来写属性值的 <BR>方法｝ <BR>published 
      <BR>propertyLayers： <BR>IntegerreadGetLayerswriteSetLayersdefault1； 
      <BR>end； <BR>每个属性都需要相应的private变量用于内部存储。按照约 
      <BR>定，变量名以F打头，后跟属性名（此处为Layers），读写方法名 <BR>称分别为Get加属性名和Set加属性名。写方法总是带一个与属性 
      <BR>类型相同的参数，用以传送属性值。此参数可以传值，也可以传递 <BR>变量。如果不定义写方法（省略write部分），此属性便成为只读 
      <BR>属性。读写方法应该在private部分声明，以使其对构件用户 <BR>和构件的派生对象保持隐蔽。 
      <BR>读写方法除了取值和赋值之外，还可以附加其他操作代码，使 <BR>属性读写产生附加效应。这正是属性可以取代方法的原因。如果不 
      <BR>需要附加效应，可以不定义读写方法，采用直接访问格式来声明属 <BR>性： <BR>propertyLayers： 
      <BR>IntegerreadFLayerswriteFLayersdefault1； 
      <BR>default命令符用来指定属性的默认值，同时需要在构件的构 <BR>造函数中为属性设置初值。default命令的作用是在窗体文件存盘 
      <BR>时提供参照：若属性当前值与default命令指定的值不同，则把当 <BR>前值保存在文件中，否则便无需保存。如果省略default命令，属 
      <BR>性当前值总是保存在窗体文件中。 <BR><BR>事件与事件处理过程 <BR>创建构件时，事件也被当做属性来处理，区别仅在于事件必须 
      <BR>定义为过程类型，使其成为一个隐蔽指针，指向某个潜在的过程。 <BR>当构件用户为事件指定处理子程序后，事件便成为指向该子程序的 
      <BR>指针。事件的定义方式如下： <BR>type <BR>private 
      <BR>FOnClick：TNotifyEvent；｛声明事件变量以保存过程指针｝ <BR>published 
      <BR>propertyOnClick： <BR>TNotifyEventreadFOnClickwriteFOnClick； <BR>end； 
      <BR>此例正是Delphi标准控件中Click事件的定义方式。可以看 <BR>出，除了OnClick被定义为过程类型外，其定义格式与一般属性的 
      <BR>直接访问格式几乎完全相同。Delphi预定义了所有标准事件的过 <BR>程类型及标准事件所引发的虚方法。其中，Click事件将引发如下 
      <BR>虚方法： <BR>procedureTControl．Click； <BR>begin 
      <BR>ifAssigned（OnClick）thenOnClick（Self）； <BR>｛以下是默认处理部分｝ <BR>end； 
      <BR>其中，Assigned函数检验OnClick是否已分配了事件处理过 <BR>程。如果返回值为True，则调用用户指定的事件处理过程。通过 
      <BR>重载此虚方法，可以修改Click事件的处理方式。在重载的方法中， <BR>一般应先调用用户处理程序，然后再安排后续处理。在本例中，首 
      <BR>行代码应当是inheritedClick。 <BR>需要注意的是，构件用户不一定会给事件指定处理程序，因此 
      <BR>事件不能定义为函数类型，否则可能会指向返回值类型不定的空函 <BR>数。如果需要事件处理过程返回某个值，可以借助var参数。调用 
      <BR>用户程序之前应确保此参数包含有效返回值，以免用户未指定事件 <BR>处理过程时出错。 
      <BR>如果Delphi标准事件不能满足需要，也可以自己定义事件。 <BR>其核心思想是选择适当的Windows消息来引发构件中的事件过程。 
      <BR>篇幅所限，不拟详述，请读者参阅有关资料。 <BR><BR>方法处理要点 <BR>方法处理在创建构件时和使用构件时没有多大区别，但有些问 
      <BR>题仍需要注意。 <BR>首先要注意的是，构件通常是在事件处理过程中调用，而构件 
      <BR>作者又无法预测用户将在什么环境下如何调用构件。因此，构件中 <BR>的方法应尽量避免占用系统资源，避免使Windows停止对用户操作 
      <BR>的反应。 <BR>创建构件时应随时意识到，此构件不仅可以直接调用，而且可 <BR>用来创建别的构件。即使是对用户隐蔽的方法也应具有完整的功能 
      <BR>和清晰的接口。除了属性读写方法之外，内部方法一般应声明为 <BR>protected虚方法，以便被派生对象继承和重载。属性读写方法则 
      <BR>应采用private声明严密保护。派生对象如果需要读写父对象的属 <BR>性值，应该访问属性本身，没有必要直接访问其读写方法。 
      <BR><BR>构件测试 <BR>制作构件的核心工作是编写构件单元，包括根据构件功能要求 
      <BR>设定对用户开放的属性、事件和方法，设定用以实现这些部件的变 <BR>量、过程和函数等等。除了属性和事件有 特殊格式之外，构件 
      <BR>单元的设计方式与一般Delphi单元没有什么不同，只是单元中不 <BR>能包含窗体。 
      <BR>在编写构件单元的过程中，可以借助一个测试窗体直接对其测 <BR>试。以可视化方法在窗体上安排构件，本质上不过是自动生成调用 
      <BR>构件的代码。即使构件未并入VCL库，无法使用可视化操作，也可 <BR>以手工编写这些调用代码。这样测试，可以免去反复修改而导致的 
      <BR>反复安装。 <BR>测试时，需先建立一个窗体单元，然后进行以下操作： <BR>1．把被测构件单元名称加入窗体单元的uses语句中，并在 
      <BR>public部分声明被测构件的对象实例。 <BR>2．在窗体单元的FormCreate子程序中调用被测构件的Create 
      <BR>方法，以构造构件实例，其Owner参数设置为Self，即窗体本身。 
      <BR>然后给Parent属性赋值，并适当设置其他属性值。Parent是容纳 <BR>构件的父对象，如果是窗体本身，应设置为Self。 
      <BR>3．运行包含测试窗体的工程，找出构件程序中的错误。 <BR><BR>注册构件 
      <BR>注册构件用的程序代码可以放在构件单元中，但在Delphi下 <BR>注册构件时要求提供包含注册代码的源程序文件（．PAS文件）， 
      <BR>因此，比较好的方式是把构件核心代码编译成．DCU文件或．DLL <BR>动态链接库，在注册源文件中只放注册代码和外围程序。下面是注 
      －－－TCustomEdit <BR>－－－TCustomListBox 
      <BR>TControl的子类型用于非窗口式控件，TWinControl的子类型则用于窗口式控件。除非特殊需要，一般不直接从TControl和 <BR>TWinControl派生新控件，而是从其子类型派生。这样可以充分利用原有的属性、事件和方法，减少很多工作量。在这些构件类型中，非通用的属性、事件和方法都声明为protected。这样可以禁止构件用户访问，又能被子类型继承和修改。在新构件中，可以简单地把继承来的属性和事件重新声明为published，使构件用户能在设计期通过对象编辑窗口访问，也可以进而修改属性的默认值和读写方式，或是重载（override）事件处理子过程和其他构件方法，以修改其中的程序代码。重声明可以放宽访问权限，但不能 相反，例如，不可能把published属性重声明为private或protected。为了增加新功能，常常需要定义全新的属性、事件和方法。定义时，一般总是把对用户开放的属性和事件声明为published，把方法声明为public或protected。 <BR><BR>构件属性 <BR>在构件中，属性和方法往往可以相互替代。对构件用户来说，属性比方法更直观简便。因此，只要可能，应尽量以属性取代方法。  
      <BR>属性类型包括简单类型（numeric，character，string）、枚举类型、集合类型、对象类型（例如font）和数组类型（例如TStrings类型中的Strings）。其定义方法如下：  
      <BR>type <BR>private <BR>FLayers：Integer；｛内部存储用的变量｝  
      <BR>functionGetLayers：Integer；｛用来读属性值的方法｝  
      <BR>procedureSetLayers（ALayers：Integer）；｛用来写属性值的 <BR>方法｝ <BR>published  
      <BR>propertyLayers： <BR>IntegerreadGetLayerswriteSetLayersdefault1；  
      <BR>end； <BR>每个属性都需要相应的private变量用于内部存储。按照约定，变量名以F打头，后跟属性名（此处为Layers），读写方法名 <BR>称分别为Get加属性名和Set加属性名。写方法总是带一个与属性类型相同的参数，用以传送属性值。此参数可以传值，也可以传递 <BR>变量。如果不定义写方法（省略write部分），此属性便成为只读属性。读写方法应该在private部分声明，以使其对构件用户 <BR>和构件的派生对象保持隐蔽。读写方法除了取值和赋值之外，还可以附加其他操作代码，使属性读写产生附加效应。这正是属性可以取代方法的原因。如果不需要附加效应，可以不定义读写方法，采用直接访问格式来声明属性： <BR>propertyLayers：  
      <BR>IntegerreadFLayerswriteFLayersdefault1；  
      <BR>default命令符用来指定属性的默认值，同时需要在构件的构造函数中为属性设置初值。default命令的作用是在窗体文件存盘  
      <BR>时提供参照：若属性当前值与default命令指定的值不同，则把当前值保存在文件中，否则便无需保存。如果省略default命令，属性当前值总是保存在窗体文件中。 <BR><BR>事件与事件处理过程 <BR>创建构件时，事件也被当做属性来处理，区别仅在于事件必须定义为过程类型，使其成为一个隐蔽指针，指向某个潜在的过程。 <BR>当构件用户为事件指定处理子程序后，事件便成为指向该子程序的指针。事件的定义方式如下： <BR>type <BR>private  
      <BR>FOnClick：TNotifyEvent；｛声明事件变量以保存过程指针｝ <BR>published  
      <BR>propertyOnClick： <BR>TNotifyEventreadFOnClickwriteFOnClick； <BR>end；  
      <BR>此例正是Delphi标准控件中Click事件的定义方式。可以看出，除了OnClick被定义为过程类型外，其定义格式与一般属性的  
      <BR>直接访问格式几乎完全相同。Delphi预定义了所有标准事件的过程类型及标准事件所引发的虚方法。其中，Click事件将引发如下  
      <BR>虚方法： <BR>procedureTControl．Click； <BR>begin  
      <BR>ifAssigned（OnClick）thenOnClick（Self）； <BR>｛以下是默认处理部分｝ <BR>end；  
      <BR>其中，Assigned函数检验OnClick是否已分配了事件处理过程。如果返回值为True，则调用用户指定的事件处理过程。通过  
      <BR>重载此虚方法，可以修改Click事件的处理方式。在重载的方法中，一般应先调用用户处理程序，然后再安排后续处理。在本例中，首行代码应当是inheritedClick。需要注意的是，构件用户不一定会给事件指定处理程序，因此事件不能定义为函数类型，否则可能会指向返回值类型不定的空函数。如果需要事件处理过程返回某个值，可以借助var参数。调用用户程序之前应确保此参数包含有效返回值，以免用户未指定事件处理过程时出错。如果Delphi标准事件不能满足需要，也可以自己定义事件。其核心思想是选择适当的Windows消息来引发构件中的事件过程。篇幅所限，不拟详述，请读者参阅有关资料。 <BR><BR>方法处理要点 <BR>方法处理在创建构件时和使用构件时没有多大区别，但有些问题仍需要注意。首先要注意的是，构件通常是在事件处理过程中调用，而构件作者又无法预测用户将在什么环境下如何调用构件。因此，构件中的方法应尽量避免占用系统资源，避免使Windows停止对用户操作的反应。创建构件时应随时意识到，此构件不仅可以直接调用，而且可用来创建别的构件。即使是对用户隐蔽的方法也应具有完整的功能和清晰的接口。除了属性读写方法之外，内部方法一般应声明为protected虚方法，以便被派生对象继承和重载。属性读写方法则应采用private声明严密保护。派生对象如果需要读写父对象的属性值，应该访问属性本身，没有必要直接访问其读写方法。  
      <BR><BR>构件测试 <BR>制作构件的核心工作是编写构件单元，包括根据构件功能要求设定对用户开放的属性、事件和方法，设定用以实现这些部件的变 <BR>量、过程和函数等等。除了属性和事件有 特殊格式之外，构件单元的设计方式与一般Delphi单元没有什么不同，只是单元中不 <BR>能包含窗体。在编写构件单元的过程中，可以借助一个测试窗体直接对其测试。以可视化方法在窗体上安排构件，本质上不过是自动生成调用构件的代码。即使构件未并入VCL库，无法使用可视化操作，也可以手工编写这些调用代码。这样测试，可以免去反复修改而导致的反复安装。 <BR>测试时，需先建立一个窗体单元，然后进行以下操作： <BR>1．把被测构件单元名称加入窗体单元的uses语句中，并在public部分声明被测构件的对象实例。 <BR>2．在窗体单元的FormCreate子程序中调用被测构件的Create方法，以构造构件实例，其Owner参数设置为Self，即窗体本身。  
      <BR>然后给Parent属性赋值，并适当设置其他属性值。Parent是容纳构件的父对象，如果是窗体本身，应设置为Self。  
      <BR>3．运行包含测试窗体的工程，找出构件程序中的错误。 <BR><BR>注册构件  
      <BR>注册构件用的程序代码可以放在构件单元中，但在Delphi下注册构件时要求提供包含注册代码的源程序文件（．PAS文件），  
      <BR>因此，比较好的方式是把构件核心代码编译成．DCU文件或．DLL动态链接库，在注册源文件中只放注册代码和外围程序。下面是注  
      <BR>册代码实例： <BR>type <BR>TMyPanelΚclass（TCustomPanel）  
      <BR>TMyLabelΚclass（TCustomLabel） <BR>procedureRegister； <BR>implementation  
      <BR>procedureRegister； <BR>begin  
      <BR>RegisterComponents（′Samples′，［TMyPanel，TMyLabel］）； <BR>end；  
      <BR>注册过程名必须是Register。过程体中调用RegisterCompnents，其中的两个参数分别指定Delphi构件工具条页名和要  
      <BR>注册的构件类型。如果指定页不存在，Delphi将创建一个新页。Delphi环境提供了一个构件生成器（componentexpert）， <BR>可用来自动生成注册单元。构件工具条上每个构件需要一个24×24点阵bitmap图标。图标可以借助Delphi的ImageEditor编辑生成，以．DCR资源文件的形式提供给构件用户，文件与注册单元文件相同。如果不提供此文件，Delphi将采用默认图标。 <BR><BR>提供联机帮助  
      <BR>一个成熟的构件，无论是用于开发群体还是用做商品软件，都要有联机帮助信息才能正常使用。Delphi的帮助信息与Windows  
      <BR>一般帮助信息结构基本上相同，其编写方法可参见有关资料。但Delphi包含一个特殊的帮助搜索引擎，能跨越多个帮助文件搜索  
      <BR>关键词。因此，在构件帮助文件中不仅要有普通K型关键词脚注，还要包含Delphi所用的B型关键词脚注。脚注内容有如下约定：  
      <BR>在Delphi的对象编辑窗口和代码编辑窗口中，用F1键可以引发帮助搜索引擎，通过B型关键词调出有关帮助主题。为了实现这  
      <BR>种帮助机制，需借助KeywordGenerate程序来生成关键词文件（．KWF），与帮助信息文件（．HLP）一起交给构件用户。用户借  
      <BR>助HelpInst程序把关键词文件内容并入Delphi主帮助索引文件（．HDX）中。构件联机帮助信息应当与Delphi标准构件帮助信息格式相同。编写帮助文件时最好遵循如下约定：  
      <BR>1．每个构件有一个单独的帮助主题（Topic），内容包含构件简介及用户可见的属性、事件和方法列表。  
      <BR>2．新增的及修改较大的属性、事件和方法均应有单独的帮助主题，其中应包含所属构件、用途、声明格式等内容。  
      <BR>3．每个帮助主题都应包含K型脚注，以便用F1键引发。  
</P>    
      <p>　    
    </td>    
  </tr>    
</table>    
</center></div>    
<p>　</p> 
</BODY></HTML> 
