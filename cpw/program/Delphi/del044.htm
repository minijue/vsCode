<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>您现在的位置是</title>
</head>

<body>

<div align="center"><center>

<table border="1" cellspacing="0" cellpadding="2" width="100%" style="font-size: 9pt"
bordercolor="#000000" bordercolordark="#FFFFFF">
  <tr bgcolor="#CCFFCC">
    <td><span style="font-size: 9pt">您现在的位置是： <b><a href="../progidx.htm">编程技巧</a> --&gt; 
      <a href="Del_idx.htm">DELPHI</a></b></span></td>      
  </tr>      
</table>      
</center></div><div align="center"><center>      
      
<table border="1" width="100%" style="font-size: 9pt" bgcolor="#FFFFFF"      
bordercolor="#000000" cellpadding="2" cellspacing="0" bordercolordark="#FFFFFF">      
  <tr>      
    <td width="85%" align="left" valign="top"><table border="1" width="32%" style="font-size: 9pt" height="30"      
    cellspacing="0" cellpadding="2" bgcolor="#FFFFFF" bordercolor="#000000"      
    bordercolordark="#FFFFFF">      
      <tr>      
        <td width="100%" bgcolor="#4264B5"><p align="center"><span style="font-size: 9pt"><font      
        color="#FFFFFF">资料整理&middot;<a href="http://chinaprog.yeah.net" target="_blank"      
        style="color: rgb(255,255,255)">中国程序员网站</a></font></span></td>      
      </tr>      
    </table>      
      <p align="center">Delphi中对象解除技巧&nbsp;<br>
      <br>
                            郑州 邹国栋</p> 
      <p>　　在Delphi程序设计中，我们需要通过解除建立的所有对象来避免内存泄漏。但是，如果你在程序中不谨慎小心的话，很容易多次解除同一个对象，这将会引起很严重的错误，造成应用程序崩溃，甚至是死机。<br>
      　　请看下面的程序：<br>
      　　procedure TForm1.Button1Click(Sender:TObject);<br> 
      　　var<br>
      　　 Button2,Button3:TButton;<br> 
      　　begin<br>
      　　 Button2:=TButton.Create(self);<br> 
      　　 Button3:=TButton.Create(Button2);<br> 
      　　 Button2.Free;<br> 
      　　 Button3.Free;<br> 
      　　end;<br>
      　　在上例中，当执行到Button3.Free时会产生一个错误，因为在调用Button2.Free时，Button2被解除，但因为Button2是Button3的宿主，Button3也同时被解除，因此错误就不可避免地发生了。<br>
      　　要避免上述错误，有两种方法：第一，在解除宿主之前要先解除其所属的所有组件。这种方法很简单，只要将上例中Button2.Free和Button3.Free换位即可。第二，在Button3.Free执行之前将Button3变量设置为nil。程序如下：<br>
      　　Button2.Free;<br>
      　　Button3:=nil;<br>
      　　Button3.Free;<br>
      　　在上面的程序中，将Button3置为nil是为了阻止应用程序重新使用已解除对象的内存。在调用Free对象方法时，它会确定对象是否为nil，如果不是，Free对象方法会假定对象仍然存在，使用对象引用为它分配内存，然后调用Destroy释放对象内存，并清除任何相关的虚拟对象方法的数据表格信息。而Destroy对于有对象存在的内存地址不会做任何改变，所以如果在调用Destroy之后测试该内存地址，它仍可能有效。所以当在程序中两次调用一个对象而没有将对象引用置为nil时，对象引用将仍然引用对象解除之前所占用的内存地址，这就是产生错误的原因。<br>
      　　当然，在实际开发过程中，大多数错误不会这样明显，解决的方法也要依具体而定，不会这么简单地加一句话就能解决问题。我在这里只是说明一种编程思想，起一个抛砖引玉的作用，具体的东西还要靠你在实践中去探索，积累。     
    </td>     
  </tr>     
</table>     
</center></div>     

</body>

</html>
