<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title></title>
</head>

<body background="../../res/back.JPG">
<div align="center"><center>

<table border="0" width="560" height="4" cellspacing="0" cellpadding="0">
  <tr>
    <td width="570" height="7"><p align="center"><strong><span style="font-size: 9pt">用Delphi开发分隔线组件</span></strong></td>
  </tr>
  <tr>
    <td width="570" height="9"><p align="center"><span style="font-size: 9pt">(西安: 
    王为民 郭秀明)</span></td>
  </tr>
  <tr>
    <td width="570" height="8"><span style="font-size: 9pt"><p align="center">录入:江湖小子</span></td>
  </tr>
</table>
</center></div>

<p><span style="font-size: 9pt">【摘要】本文以分隔线为例，采用面向对象方法，介绍了如何用Delphi开发Windows 
的可视化控件。可视化控件具有较强的实用价值，用Delphi语言开发控件简便、方便、效率高。<br>
<br>
关键词：Delphi 控件 面向对象<br>
<br>
一、引言<br>
Delphi除了能采用可视化方法进行编程和系统开发外，还有非常重要的一个功能，就是能用其语言本身开发Delphi的可视化控件（Component）。Delphi是完全面向对象的语言，其各个控件都是从最基本的类TClass逐步继承而来，因此，编程者也可通过继承Delphi标准的控件类，开发出自己的控件，以满足某些特殊需要或使界面更为友好、美观。<br>
在Windows 95的某些窗口中，用到了很多分隔线（如在资源管理器窗口中）。分隔线将一个窗口分成两个或多个部分。这些部分可能是面板（Panel）、图形、列表框或编辑区。当鼠标移到分隔线上时，光标会变成左右箭头或上下箭头，将鼠标按住并按指示的方向左右或上下拖动，就会使其中某部分放大，而另一部分缩小，从而提高了窗口各部分的可视范围，增加了窗口的信息量。<br>
<br>
二、基本原理<br>
分隔线界于窗口中两个控件之间。首先要在当前窗口中找到分隔线控件，并记录它的状态；然后要在窗口中找到与它相邻的控件，并记录它们的当前状态，然后再通过分隔线的鼠标事件控制各个控件的移动及尺寸变化，从而达到用分隔线分隔窗口的动态效果。<br>
<br>
三、分隔线控件（TSplit）对象<br>
分隔线控件对象由现有的控件对象继承而来，在此基础上，还必须有它本身的私有变量（方法）和公有变量（方法）。具体为：<br>
1、首先定义分隔线控件类：TSplit。由于Delphi的面板控件Tpanel具有可改变其凸凹、形状大小等属性，所支持的事件方法也较多，因此采用Tpanel作为TSplit的父类。<br>
2、定义TSplit的私有变量和方法：与分隔线有关的一些控件，如其所在的窗口、分隔线本身、分隔线的坐标、分隔线在移动时使其大小改变的控件（主要指分隔线的左侧或上侧的控件，以下称目标）等，这些定义为私有变量；对分隔线和其周围控件的检测、画阴影线以及求其状态等过程（子程序），定义为私有方法。其中关键的变量有FSplitControl，FSizeTarget，它们为分隔线变量和所移动的目标控件变量，通过调用私有方法GetComponent可将它们赋值，得到分隔线和目标的实例，从而便于对他们操作。在分隔线移动时，DrawSizegLine方法画出它的阴影线。<br>
3、定义公共方法：公共方法定义了TSplit的构造函数、开始移动分隔线、改变分隔<br>
线 的 
位置、分隔线停止移动时调整目标（被分隔线改变形状的控件）尺寸等过程，以及分隔线的鼠标事件：按下、移动和弹起。另外，还定义了分隔线是否可移动的属性（property），以判断分隔线的当前状态。鼠标事件是分隔线移动和目标改变大小的触发点，对鼠标事件进行重载，使得移动和变化得以实现。在MouseDown事件中，加入了公共方法BeginSizing，对分隔线对象初始化；MouseMove事件中加入ChangeSizing方法，改变分隔线位置和画阴影；<br>
MouseUp事件中加入EndSizing，停止分隔线的移动，改变目标大小。<br>
4、分隔线控件实现过程 (见附录：split.pas程序及其说明。)<br>
<br>
四、控件的安装方法<br>
在Delphi 1.0的系统菜单Options下(2.0为Components)，选择Install Component子菜单，弹出对话框，按Add按纽，在输入栏键入程序名及其路径，再按OK键，等待编译完毕，在Delphi的控件列表中的Sample栏中就会出现我们所开发的新控件：Split。<br>
<br>
五、使用方法<br>
1、建立一个新的项目文件（Project），在新窗口上放置一个面板（或列表框、树型结构列表、图形框、记忆框等），将其Align属性设为Left；<br>
2、从控件列表中的Sample栏中选取Split控件放于窗口，将其形状改为垂直的长条窄棒，并将Align属性设为Left，Cursor属性设为crHSplit；<br>
3、 再在窗口中放一个面板（或其他控件），将其Align属性设为Client;<br>
4、运行该项目文件，当鼠标移动到分隔线上，且光标变为左右箭头时，即能将其两边的部分放大或缩小。<br>
若想做成上下分隔线，将以上1和2中的Align属性设为Top，2中的Cursor属性设为crVSplit，其余不变即可。<br>
另外用户还可在3中的面板上再按1、2、3的步骤进行操作，将整个窗口用两个分隔线分为3个部分。以此类推，可将窗口分为任意多个部分。<br>
本程序在Delphi 1.0和2.0下调试通过。<br>
<br>
附录：源程序split.pas<br>
<br>
unit Split;<br>
interface <br>
uses<br>
SysUtils, WinTypes, WinProcs, Messages, Classes, Graphics, Controls,Forms,<br>
Dialogs, ExtCtrls;<br>
type {定义分隔线控件类}<br>
TSpliter = class(TPanel) {TSpliter类从Tpanel类继承} <br>
private {定义私有变量和方法}<br>
FForm: TForm; {分隔线所在的窗口变量}<br>
FSplitControl, FSizeTarget: Tcontrol; {分隔线及要改变的目标控件变量}<br>
FVertical: Boolean; {分隔线方向变量}<br>
FSplit: TPoint; {分隔线坐标变量}<br>
FAOwner: TComponent; {分隔线的拥有者变量}<br>
procedure GetComponents; {获得分隔线和目标实例}<br>
function GetSizing: Boolean; {判断分隔线状态}<br>
procedure DrawSizingLine; {画分隔线阴影}<br>
public {定义公共方法}<br>
constructor Create(AOwner: TComponent);override; {构造函数}<br>
procedure BeginSizing; {移动前初始化}<br>
procedure ChangeSizing(X, Y: Integer); {改变分隔线位置}<br>
procedure EndSizing; {终止移动}<br>
property Sizing: Boolean read GetSizing; {分隔线是否可移动属性}<br>
procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y:Integer);<br>
Override; {按下鼠标事件}<br>
procedure MouseMove(Shift: TShiftState; X, Y: Integer);override; {移动鼠<br>
标事件}<br>
procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y:<br>
Integer);override; {弹起鼠标事件}<br>
end;<br>
procedure Register; {控件注册}<br>
implementation <br>
constructor TSpliter.Create(AOwner: TComponent);<br>
begin<br>
inherited Create(AOwner); <br>
FAOwner := AOwner;<br>
FForm:= TForm(FAOwner); {定义分隔线所在的窗口类}<br>
end;<br>
function CToC(C1, C2: TControl; P: TPoint): TPoint; {转换分隔线坐标函数}<br>
begin<br>
Result := C1.ScreenToClient(C2.ClientToScreen(P));<br>
{将分隔线坐标转化为窗<br>
口坐标}<br>
end;<br>
function TSpliter.GetSizing: Boolean;<br>
begin<br>
Result := FSplitControl &lt;&gt; nil; {是否获得了分隔线变量}<br>
end;<br>
procedure TSpliter.DrawSizingLine;<br>
var P: TPoint;<br>
begin<br>
P := CToC(FForm, FSplitControl, FSplit);<br>
with FForm.Canvas do begin<br>
MoveTo(P.X, P.Y);<br>
if FVertical then {若为上下移动的分隔线，画横向阴影线}<br>
LineTo(CToC(FForm, FSplitControl, Point(FSplitControl.Width, 0)).X, P.Y)<br>
else {否则}<br>
LineTo(P.X, CToC(FForm, FSplitControl, Point(0, FSplitControl.Height)<br>
).Y) {画竖直的阴影线}<br>
end;<br>
end;<br>
procedure TSpliter.BeginSizing;<br>
begin<br>
GetComponents;<br>
SetCaptureControl(FSplitControl); {使分隔线可接受鼠标事件}<br>
if FVertical then {获得分隔线的坐标}<br>
FSplit := Point(0, FSplitControl.Top) else<br>
FSplit := Point(FSplitControl.Left, 0);<br>
FForm.Canvas.Handle := GetDCEx(FForm.Handle, 0, DCX_CACHE or <br>
DCX_CLIPSIBLINGS<br>
or DCX_LOCKWINDOWUPDATE); {取窗口句柄}<br>
with FForm.Canvas do begin {设置画笔状态模式}<br>
Pen.Color := clWhite;<br>
if FVertical then<br>
Pen.Width := FSplitControl.Height else<br>
Pen.Width := FSplitControl.Width;<br>
Pen.Mode := pmXOR;<br>
end;<br>
DrawSizingLine;<br>
end;<br>
procedure TSpliter.ChangeSizing(X, Y: Integer);<br>
begin<br>
DrawSizingLine;<br>
if FVertical then FSplit.Y := Y else FSplit.X := X; {移动分隔线位置}<br>
DrawSizingLine;<br>
end;<br>
procedure TSpliter.EndSizing;<br>
var<br>
DC: HDC;<br>
P: TPoint;<br>
begin<br>
DrawSizingLine;<br>
P := CToC(FSizeTarget, FSplitControl, FSplit); {将分隔线坐标转化为目标控<br>
件坐标}<br>
SetCaptureControl(nil); {将可接收鼠标事件的控件置空}<br>
FSplitControl := nil; {分隔线对象指向空}<br>
with FForm do begin<br>
DC := Canvas.Handle;<br>
Canvas.Handle := 0;<br>
ReleaseDC(Handle, DC); {释放窗口句柄}<br>
end;<br>
if FVertical then begin {若为上下移动的分隔线}<br>
if P.Y &gt;= FSizeTarget.Parent.Height then Exit {若分隔线超过窗口高度退出}<br>
else FSizeTarget.Height := P.Y; {否则改变目标高度}<br>
end<br>
else begin<br>
if P.X &gt;= FSizeTarget.Parent.Width then Exit {若分隔线超过窗口宽度退出}<br>
else FSizeTarget.Width:= P.X; {否则改变目标宽度}<br>
end;<br>
end;<br>
procedure TSpliter.MouseDown(Button: TMouseButton; Shift: TShiftState; <br>
X, Y: Integer);<br>
begin<br>
inherited MouseDown(Button, Shift, X, Y); {继承原方法}<br>
if (Button = mbLeft) and (Shift = [ssLeft]) then BeginSizing; {判断鼠标按<br>
键，开始移动}<br>
end;<br>
procedure TSpliter.MouseMove(Shift: TShiftState; X, Y: Integer);<br>
begin<br>
inherited MouseMove(Shift, X, Y);<br>
if Sizing then ChangeSizing(X, Y);<br>
end;<br>
procedure TSpliter.MouseUp(Button: TMouseButton; Shift: TShiftState;X,<br>
Y: Integer);<br>
begin<br>
inherited MouseUp(Button, Shift, X, Y);<br>
if Sizing then EndSizing; {若获得分隔线对象，结束移动}<br>
end;<br>
procedure TSpliter.GetComponents;<br>
var I: Integer;<br>
begin<br>
FSplitControl:= GetCaptureControl; {获得窗口中的分隔线对象}<br>
FVertical := FSplitControl.Width &gt; FSplitControl.Height;<br>
if not FVertical then begin {若为横向分隔线}<br>
for I:= 0 to FSplitControl.Parent.ControlCount-1 do {在分隔线所在的控件上<br>
搜寻与它相邻的控件}<br>
begin<br>
if (FSplitControl &lt;&gt; FSplitControl.Parent.Controls[I]) and<br>
(FSplitControl.Left - FSplitControl.Parent.Controls[I].Width &gt;= 0) and<br>
(FSplitControl.Left - FSplitControl.Parent.Controls[I].Width &lt; 8) then<br>
begin<br>
FSizeTarget:= TControl(FSplitControl.Parent.Controls[I]); {获得目标控件}<br>
Break; {跳出循环}<br>
end<br>
end;<br>
end<br>
else begin {若为纵向分隔线}<br>
for I:= 0 to FSplitControl.Parent.ControlCount-1 do begin<br>
if (FSplitControl &lt;&gt; FSplitControl.Parent.Controls[I]) and<br>
(FSplitControl.Top - FSplitControl.Parent.Controls[I].Height &gt;= 0) and<br>
(FSplitControl.Top - FSplitControl.Parent.Controls[I].Height &lt; 8) then<br>
begin<br>
FSizeTarget:= TControl(FSplitControl.Parent.Controls[I]);<br>
Break;<br>
end;<br>
end;<br>
end;<br>
end;<br>
procedure Register;<br>
begin<br>
RegisterComponents('Samples', [TSpliter]);<br>
{将分隔线控件注册到Sample控件<br>
列表中}<br>
end;<br>
end.<br>
</span></p>
</body>
</html>
