<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>设计工具之游戏引擎之三</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body style="font-size: 9pt" background="../res/back.JPG">

<p align="center">设计工具之游戏引擎之三:图像页CPICPAGE介绍</p>

<p><br>
　　图像页指的是内存中保存图像数据的各种表面,屏幕缓存,各种图片数据,窗口界面的界面数据等,不要只依靠DirectX的表面,最好单独用一个对象来管理这些内容,避免直接与DirectX打交道,这样改变引擎和移植到别的操作系统的工作量会小得多. 
<br>
　　在我们的引擎设计中,CPICPAGE是一个功能强大而且扩充性极好的对象,比如我们不想使用DirectX表面,而想自己设计一种表面结构,游戏的其余部分不须任何改变,只要从CPICPAGE发展出CSELFPAGE的对象即可.象我知道的&quot;腾图&quot;公司的余雪松和吴冬黎(两个非常优秀的程序师,我从他们那里收益非浅,他们也是国内比较早的&quot;xx&quot;游戏站点的主人)就有一套自己的功能强大的图像表面,他们不使用DirectX表面. 
<br>
　　游戏对图像的操作一般不是直接对具体类型的表面操作,而是调用他们的根对象CPICPAGE. 
<br>
<br>
在我们的游戏引擎中,图像页的结构是这样的： <br>
　　CPICPAGE <br>
CBitmapPage //标准windows的位图,如果使用16M色模式,对于一些不常更新的图像,使用 
<br>
　　　　　　 //16M色的DirectXDraw是种巨大的浪费,比如背景,我们可以保存一块比视 
<br>
//口大的DirectXDraw表面作为背景区,只在一定条件下才将256色原图 <br>
//CBitmapPage写入背景区(使用任意调色版可保证非常高的图像质量,特别 
<br>
//是使用Potoshop 5.0或Animatorfor Window 作为真彩转换256色工具,颜 <br>
//色失真极小),平时游戏读的是高速的DirectXDraw背景表面 <br>
CDirectXDrawPage//标准的DirectXDraw表面, <br>
CGifPage//Gif动画表面,随着时间自动修改图像内容,继承CDirectXDrawPage <br>
CAviPage//AVi动画表面,随着时间自动修改图像内容,继承CDirectXDrawPage,可以带自己线程 
<br>
CFlcPage//Flc动画表面,随着时间自动修改图像内容,继承CDirectXDrawPage <br>
<br>
目前我们只设计了这些类型,但可以供据需要随时扩充. <br>
class CPICPAGE <br>
{ <br>
protected: <br>
char picStyle;//图像类型 <br>
BOOL CanWrite;//是否可以写 <br>
int picWidth,picHeight;//尺寸 <br>
DWORD activeMode;//静态,可释放, <br>
unsigned short useTimeMark;//使用时间标记,如果长时间未使用,则保存到虚拟文件中 
<br>
char *programeBuf;//可以用代码来控制图像的改变, <br>
//我们支持脚本语言对图像进行特殊控制 <br>
char *lpImgBuf;//图像内存 <br>
long imgBufLen;//内存长度 <br>
HDC hDC;//标准设备句柄,指对CDirectXDrawPage和它的继承对象有效 <br>
BOOL hasChg;//图像内容是否已经改变 <br>
BOOL UseClip;//是否设定显示剪裁区 <br>
RECT clipRc;//显示剪裁区 <br>
public: <br>
CPICPAGE(); <br>
~CPICPAGE(); <br>
virtual void Destroy(void); <br>
char GetPicStyle(void); <br>
BOOL GetSize(int *w,int *h); <br>
void GetRect(RECT *lpRc); <br>
char *GetImgBuf(void); <br>
BOOL Load(char *lpFileName,long startOfs=0);从文件中读取内容 <br>
virtual BOOL LoadFile(FILE *lpFileHandle,long startOfs=0){return FALSE;}; <br>
virtual void BeginDraw(){};//如果是标准的DirectXDraw表面,再进行 <br>
//Window的标准图形读写时要获得HDC,如果是连续写,不要 <br>
//马上释放,反复申请和释放HDC会大大降低速度 <br>
virtual void EndDraw(){};//终止Window的标准图形读写,释放HDC <br>
virtual HDC GetHDC(void){return NULL;}; <br>
virtual void Line(int bx,int by,int ex,int ey,COLORREF rgb); <br>
virtual void drawStrgs(char *strg,short bx,short by,char drawBox,short choice); <br>
virtual void Draw(RECT *lpRc,COLORREF *lpCr,char drawStyle,DWORD otherMess); <br>
virtual void Fill(RECT *rc=NULL,COLORREF colorFill=0); <br>
virtual void DrawRect(RECT *rc,COLORREF colorLeft,COLORREF colorRight, <br>
COLORREF colorFill,COLORREF colorKey, DWORD drawStyle); <br>
virtual BOOL BltInView( CPICPAGE *lpDec, <br>
int srcInX, int srcInY, //x,y是souRectBlt相对于整个des表面的位置 <br>
DWORD flap=0, RECT *DecView=NULL, RECT *souRectBlt=NULL,//源图片目标区 <br>
RECT *lpFillRect=NULL) {return FALSE;}; <br>
virtual BOOL FillRect(CPICPAGE *lpSou,RECT *lpSouRect=NULL,RECT lpDecRect=NULL) <br>
{return FALSE;}; <br>
virtual BOOL Scroll(int scrollX,int scrollY,RECT *lpRect=NULL){return FALSE;}; <br>
virtual BOOL ChgSize(int chgWidth,int chgHeight,int mode=0) <br>
{return FALSE;};//0 设置尺寸,1 改变尺寸 <br>
virtual BOOL HasLost(void){return FALSE;}; //已经丢失图像数据 <br>
virtual BOOL Scroll(int scrollX,int scrollY,COLORREF fillColor=0, <br>
RECT *lpScrollRc=NULL){return FALSE;}; <br>
virtual void TimeTrace(vodi);//时间跟踪,动画可以在此时更改自己的图像 <br>
}; <br>
<br>
class CDIBPAGE:public CPICPAGE <br>
{ <br>
HDIB hDIB; <br>
LPSTR lpDIBHdr; <br>
unsigned aLineByte; <br>
BYTE biBitCount; <br>
char style; <br>
char *LpGetIMG(void); <br>
<br>
public: <br>
CDIBPAGE(){picStyle=BMPPIC;}; <br>
BOOL Creat(int width,int height,DWORD mode=0); <br>
BOOL SetBmp(char *_lpImgBuf); <br>
BOOL LoadFile(FILE *lpFileHandle,long startOfs=0); <br>
BOOL StretchDIBits(HDC hDC,LPRECT lpDCRect,LPRECT lpDIBRect,DWORD dwRop,BOOL 
canChg=FALSE); <br>
BOOL Blt(HDC hDC,LPRECT lpDCRect,LPRECT lpDIBRect,DWORD dwRop=SRCCOPY); <br>
virtual BOOL BltInView( CPICPAGE *lpDec, <br>
int srcInX, int srcInY,//x,y是souRectBlt相对于整个des表面的位置 <br>
DWORD flap=0, RECT *DecView=NULL, RECT *souRectBlt=NULL,//源图片目标区 <br>
RECT *lpFillRect=NULL); <br>
}; <br>
<br>
class CDirectPAGE:public CPICPAGE <br>
{ <br>
LPDIRECTDRAWSURFACE surf; <br>
public: <br>
CDirectPAGE(){surf=NULL;picStyle=DIRECTPIC;} <br>
~CDirectPAGE(); <br>
void Destroy(void); <br>
BOOL Creat(int width,int height,DWORD mode=0); <br>
LPDIRECTDRAWSURFACE GetSurface(void) {EndDraw();return surf;} <br>
virtual BOOL LoadFile(FILE *lpFileHandle,long startOfs=0); <br>
HDC GetHDC(void); <br>
void BeginDraw(); <br>
void EndDraw(); <br>
virtual BOOL BltInView( CPICPAGE *lpDec, <br>
int srcInX, int srcInY,//x,y是souRectBlt相对于整个des表面的位置 <br>
DWORD flap=0, RECT *DecView=NULL, RECT *souRectBlt=NULL,//源图片目标区 <br>
RECT *lpFillRect=NULL); <br>
void Fill(RECT *rc=NULL,COLORREF colorFill=0); <br>
BOOL Scroll(int scrollX,int scrollY,COLORREF fillColor=0, RECT *lpScrollRc=NULL); <br>
}; <br>
<br>
　　这里面我只列举了一些常用的接口,另外还有一些象带alpha通道的BLT,line,以及带亮度的BLT,Line等,可以供据游戏的要求随时扩充.对标准DirectXDraw表面,我们可以在开始时使用一些window的库函数,然后如果时间允许再改为自己的速度更快的函数.系统设计时一般先完成功能,中后期才作优化,不要一开始马上陷入过多的技术细节,除非是决定系统成败的关键的速度要求. 
<br>
　　通过二,三章的工作,现在系统便可以显示一些图像和动画了,显示部分有关的内容基本就完成,下一章介绍资源管理.声音部分在最后介绍,因为那部分实现起来比较简单. 
</p>
</body>
</html>
