<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>三维视图绘制与消隐技术</title>
</head>

<body>

<table border="0" width="100%">
<TBODY>
  <tr>
    <td width="100%"><div align="center"><center><table border="0" cellspacing="2"
    cellpadding="0" width="95%" style="font-size: 9pt">
      <tr bgcolor="#CCFFCC">
        <td><span style="font-size: 9pt">现在的位置是： <b><a href="mystru.htm">算法结构</a> 
        | <a href="../program/VisualC/Vcidx098.htm">Visual C++/C++</a> |--&gt;</b> </span>三维视图绘制与消隐技术</td>
      </tr>
      <tr>
        <td></td>
      </tr>
    </table>
    </center></div><div align="center"><center><table border="1" width="95%"
    style="font-size: 9pt" bgcolor="#E8E8E8" bordercolor="#C48C59" cellpadding="2">
      <tr>
        <td width="100%"><table border="1" width="32%" style="font-size: 9pt" height="30"
        cellspacing="0" cellpadding="2">
          <tr>
            <td width="100%" bgcolor="#4264B5"><p align="center"><font color="#FFFFFF">资料整理<span
            class="f">&middot;</span><a href="http://chinaprog.yeah.net" target="_blank"
            style="color: rgb(255,255,255)">中国程序员网站</a></font></td>
          </tr>
        </table>
        </td>
      </tr>
      <tr>
        <td width="100%"><p align="center"><strong>三维视图绘制与消隐技术</strong></p>
        <p align="center">　作者：周坚华 <br>
        </p>
        <p>　　1. 问题的提出 </p>
        <p>　　在一些数据库管理系统或办公自动化和统计类软件中，一般具有绘制三维视图的功能。使用时通常要求在给出的表格中输入绘图的数据及视角、比例尺等参数。这只适用于小批量的统计数据绘制统计三维视图。在地质、地貌、气象、水文、交通、林业等许多领域，需要描述的某一量通常具有空间分布特征，这种空间分布数据的数量一般十分庞大，当使用上述三维视图软件绘图时经常会遇到输数表格容纳不下的问题，而且按表格重新输入数据也容易出错和耗费许多人力。 
        </p>
        <p>　　三维视图的绘制及相应绘图数据的组织并不是一件十分困难的事，使用少量程序代码就可以实现这一目标。本文将介绍一种以C＋＋语言实现大批量数据绘制三维视图的简易方法。该法的关键技术在于：（1）以FoxPro数据库管理系统整理绘图数据并制成可为C＋＋语言包括和调用的.h文件；（2）在绘制三维视图中，以“多边形法”进行需遮蔽线段的消隐。 
        </p>
        <p>　　2. 绘图数据的准备 </p>
        <p>　　绘图的原始数据来自FoxPro（或FoxBase）数据库管理系统。可以将某幅图的数据置于一个一维数组中，并包括在一个.h文件中。这样只要在C＋＋的绘三维视图程序首包括该头文件，就可以在程序的任何位置调用这些数据。例如有一个数据串：3，8，10，11，27，6，……，设存放数组为A，数据文件名为data.h，在data.h中，该数据串的存放形式为： 
        </p>
        <p>　　A＝{ 3, </p>
        <p>　　 8， </p>
        <p>　　 10, </p>
        <p>　　 11, </p>
        <p>　　 27, </p>
        <p>　　 6， </p>
        <p>　　 ： </p>
        <p>　　 ：}； </p>
        <p>　　这些数据可由FoxPro的.dbf文件拷贝得到。当然，在拷贝前还需经过简单的加工。设在.dbf文件中，待绘图数据所在的字段为DT1，此时可增设一个字段DH（逗号），并将该字段的内容全以“，”替换，然后以如下命令拷贝到data.h文件中： 
        copy to data.h field DT1,DH dele with blank 随后打开data.h文件，在数据首加上“A={”，在数据尾加上“ 
        }；”即可。 </p>
        <p>　　3. 绘三维视图编程基本思想 </p>
        <p>　　绘三维视图的关键技术在“消隐”，即消去在三维观察时应该被挡住看不见的线。在有关“计算机图形学”的书籍中所介绍的消隐法多为“计算法”，即由当前数据点行计算在已绘出的线条中哪些应该隐去，再清除这些线条。笔者自己设计了一种简便新颖的消隐法（这里姑且称之为“多边形法”），不仅程序代码简单，而且这种消隐法的原理也十分简洁明了。现将其基本思想及运算步骤介绍如下： 
        </p>
        <p>　　3.1 首排数据绘X方向网线。以line函数将首排数据点连线； </p>
        <p>　　3.2 绘Y方向网线。将第2排与第1排在Y方向相对应的数据点连线； 
        </p>
        <p>　　3.3 以“多边形法”做消隐。据第2排点的数据以背景色涂刷一个多边形，这样，可能被第2排数据点连线所遮蔽的线条（即应消隐的线）即被擦除； 
        </p>
        <p>　　3.4 第2排数据绘X方向网线。以line函数将第2排数据点连线； </p>
        <p>　　3.5 重复步骤3.2～3.4，直至绘完全图。 </p>
        <p>　　 4. 绘三维视图源程序(for Windows) </p>
        <p>　　draw3d.cpp </p>
        <p>　　#include<WINDOWS.H> </p>
        <p>　　#include &quot;data.h&quot; </p>
        <p>　　int PASCAL WinMain (HANDLE, HANDLE, LPSTR, int); </p>
        <p>　　long FAR PASCAL WindowProc (HWND, WORD, WORD, LONG); </p>
        <p>　　int mv[15625]; // mv[ ] 为绘图数据数组，存于data.h中 </p>
        <p>　　HANDLE hInst; </p>
        <p>　　int PASCAL WinMain (HANDLE hInstance, HANDLE hPrevInstance, </p>
        <p>　　LPSTR lpszCmdLine, int nCmdShow) </p>
        <p>　　{ </p>
        <p>　　…… //此处略去了创建窗口的代码块 </p>
        <p>　　} </p>
        <p>　　long FAR PASCAL WindowProc (HWND hWnd, WORD message, </p>
        <p>　　WORD wParam, LONG lParam) </p>
        <p>　　{ </p>
        <p>　　HDC hDC; </p>
        <p>　　PAINTSTRUCT ps; </p>
        <p>　　HBRUSH hOldBrush; </p>
        <p>　　int i=0,j=0; </p>
        <p>　　int yy[MAXPTS]; //MAXPTS为绘图行或列数，在data.h中定义 </p>
        <p>　　static POINT PointTable[MAXPTS+2]; </p>
        <p>　　switch (message) </p>
        <p>　　{ // 定义画笔或画刷 </p>
        <p>　　static LOGPEN lpBlack={PS_SOLID,1,1,RGB(0,0,0)}; </p>
        <p>　　static LOGPEN lpGreen={PS_SOLID,1,1,RGB(0,255,0)}; </p>
        <p>　　static LOGPEN lpWhite={PS_SOLID,1,1,RGB(255,255,255)}; </p>
        <p>　　HBRUSH hBlackBrush; </p>
        <p>　　HBRUSH hWhiteBrush; </p>
        <p>　　HPEN hGreenPen; </p>
        <p>　　HPEN hWhitePen; </p>
        <p>　　HDC hDC; </p>
        <p>　　PAINTSTRUCT PtStr; </p>
        <p>　　LoadString (hInst, IDS_CAPTION, szCaption, 35); </p>
        <p>　　return 0; </p>
        <p>　　case WM_PAINT: </p>
        <p>　　hDC = BeginPaint (hWnd, &amp;PtStr); </p>
        <p>　　SetMapMode(hDC,MM_TEXT); </p>
        <p>　　hBlackPen=CreatePenIndirect(&amp;lpBlack); </p>
        <p>　　hGreenPen=CreatePenIndirect(&amp;lpGreen); </p>
        <p>　　hWhitePen=CreatePenIndirect(&amp;lpWhite); </p>
        <p>　　hBlackBrush=GetStockObject(BLACK_BRUSH); </p>
        <p>　　hWhiteBrush=GetStockObject(WHITE_BRUSH); </p>
        <p>　　hOldBrush = SelectObject (hDC,GetStockObject (NULL_BRUSH)); </p>
        <p>　　{ </p>
        <p>　　yy[j]=MOVE+j*SCALE1; //MOVE为绘图起始点Y坐标，在data.h中定义 </p>
        <p>　　for(i=0;i<MAXPTS;I++) <p SCALE1为各绘图行右移增量，在data.h中定义></p>
        <p>　　{ </p>
        <p>　　PointTable[i].x=i*SCALE2+j*SCALE4; // 形成多边形顶点数组 </p>
        <p>　　PointTable[i].y=yy[j]-(PointTable[i].x-PointTable[0].x)*ANGLE-(mv[j*MAXPTS+i]*SCALE3); 
        //SCALE2和SCALE4分别为X和Y方向的缩放系数 </p>
        <p>　　if(j&gt;0) //SCALE3为绘图数据（Z方向）的缩放系数 </p>
        <p>　　{ //ANGLE为视角，均在data.h中定义 </p>
        <p>　　SelectObject(hDC,hGreenPen); </p>
        <p>　　MoveTo(hDC,mx[i],my[i]); </p>
        <p>　　LineTo(hDC,PointTable[i].x,PointTable[i].y); // 绘 y 方 向 网 线 </p>
        <p>　　} </p>
        <p>　　} </p>
        <p>　　PointTable[MAXPTS].x=PointTable[MAXPTS-1].x; </p>
        <p>　　PointTable[MAXPTS].y=PointTable[MAXPTS-1].y+20; </p>
        <p>　　PointTable[MAXPTS+1].x=PointTable[0].x; </p>
        <p>　　PointTable[MAXPTS+1].y=PointTable[0].y+20; </p>
        <p>　　if(j==(MAXPTS-1)) </p>
        <p>　　{ </p>
        <p>　　SelectObject(hDC,hWhitePen); </p>
        <p>　　SelectObject(hDC,hWhiteBrush); </p>
        <p>　　Polygon(hDC,PointTable,MAXPTS); // 消 隐 </p>
        <p>　　} </p>
        <p>　　else </p>
        <p>　　{ </p>
        <p>　　SelectObject(hDC,hBlackPen); </p>
        <p>　　SelectObject(hDC,hBlackBrush); </p>
        <p>　　Polygon(hDC,PointTable,MAXPTS); // 消 隐 </p>
        <p>　　} </p>
        <p>　　for(i=0;i<MAXPTS;I++) <p></p>
        <p>　　{ </p>
        <p>　　mx[i]=PointTable[i].x; //将前排点数据存于mx[i] my[i], </p>
        <p>　　my[i]=PointTable[i].y; // 留待绘y方向网线 </p>
        <p>　　} </p>
        <p>　　for(i=0;i&lt;(MAXPTS-1);i++) </p>
        <p>　　{ </p>
        <p>　　SelectObject(hDC,hGreenPen); </p>
        <p>　　MoveTo(hDC,PointTable[i].x,PointTable[i].y); </p>
        <p>　　LineTo(hDC,PointTable[i+1].x,PointTable[i+1].y);// 绘 x方向网线 </p>
        <p>　　} </p>
        <p>　　} </p>
        <p>　　SelectObject (hDC, hOldBrush); </p>
        <p>　　EndPaint (hWnd, &amp;PtStr); </p>
        <p>　　return 0; </p>
        <p>　　case WM_DESTROY: </p>
        <p>　　ostQuitMessage (0); </p>
        <p>　　return 0; </p>
        <p>　　default: </p>
        <p>　　break; </p>
        <p>　　} </p>
        <p>　　return DefWindowProc (hWnd, message, wParam, lParam); </p>
        <p>　　} </p>
        <p>　　5. 结论 </p>
        <p>　　绘图数据及缩放、视角等参数皆存于data.h文件中，或在该文件中说明，所以当绘图参数等内容变化时，只要修改或重新制作data.h文件即可。由此可见该程序具有使用灵活，可容绘图数据量大等优点，可用于各种空间分布数据三维视图的绘制，尤其适合于大数据量绘图。 
        </p>
        <p>　</td>
      </tr>
    </table>
    </center></div></td>
  </tr>
</TBODY>
</table>
</body>
</html>
